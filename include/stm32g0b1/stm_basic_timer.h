/**
 * @file
 * @version 1.6
 * @brief Register access structs for None TIM6
 *
 * Basic timers
 *
 * @note This file is autogenerated using register-code-gen
 */

#ifndef TIM6_H_
#define TIM6_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "static_assert.h"

#include <stdint.h>

/**
 * Counter enable Note: Gated mode can work only if the CEN bit has been
 * previously set by software. However trigger mode can set the CEN bit
 * automatically by hardware. CEN is cleared automatically in one-pulse mode,
 * when an update event occurs.
 */
typedef enum TIM6_cen_e {
    /// Counter disabled
    TIM6_cen_b_0x0 = 0x0,
    /// Counter enabled
    TIM6_cen_b_0x1 = 0x1,
} TIM6_cen_t;

/**
 * Update disable This bit is set and cleared by software to enable/disable UEV
 * event generation. Counter overflow/underflow Setting the UG bit Update
 * generation through the slave mode controller Buffered registers are then
 * loaded with their preload values.
 */
typedef enum TIM6_udis_e {
    /// UEV enabled. The Update (UEV) event is generated by one of the following
    /// events:
    TIM6_udis_b_0x0 = 0x0,
    /// UEV disabled. The Update event is not generated, shadow registers keep
    /// their value (ARR, PSC). However the counter and the prescaler are
    /// reinitialized if the UG bit is set or if a hardware reset is received
    /// from the slave mode controller.
    TIM6_udis_b_0x1 = 0x1,
} TIM6_udis_t;

/**
 * Update request source This bit is set and cleared by software to select the
 * UEV event sources. Counter overflow/underflow Setting the UG bit Update
 * generation through the slave mode controller
 */
typedef enum TIM6_urs_e {
    /// Any of the following events generates an update interrupt or DMA request
    /// if enabled. These events can be:
    TIM6_urs_b_0x0 = 0x0,
    /// Only counter overflow/underflow generates an update interrupt or DMA
    /// request if enabled.
    TIM6_urs_b_0x1 = 0x1,
} TIM6_urs_t;

/**
 * One-pulse mode
 */
typedef enum TIM6_opm_e {
    /// Counter is not stopped at update event
    TIM6_opm_b_0x0 = 0x0,
    /// Counter stops counting at the next update event (clearing the CEN bit).
    TIM6_opm_b_0x1 = 0x1,
} TIM6_opm_t;

/**
 * Auto-reload preload enable
 */
typedef enum TIM6_arpe_e {
    /// TIMx_ARR register is not buffered.
    TIM6_arpe_b_0x0 = 0x0,
    /// TIMx_ARR register is buffered.
    TIM6_arpe_b_0x1 = 0x1,
} TIM6_arpe_t;

/**
 * UIF status bit remapping
 */
typedef enum TIM6_uifremap_e {
    /// No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.
    TIM6_uifremap_b_0x0 = 0x0,
    /// Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.
    TIM6_uifremap_b_0x1 = 0x1,
} TIM6_uifremap_t;

/**
 * control register 1
 */
typedef union TIM6_cr1_u {
    struct {
        /// Counter enable Note: Gated mode can work only if the CEN bit has
        /// been previously set by software. However trigger mode can set the
        /// CEN bit automatically by hardware. CEN is cleared automatically in
        /// one-pulse mode, when an update event occurs.
        TIM6_cen_t cen : 1;
        /// Update disable This bit is set and cleared by software to
        /// enable/disable UEV event generation. Counter overflow/underflow
        /// Setting the UG bit Update generation through the slave mode
        /// controller Buffered registers are then loaded with their preload
        /// values.
        TIM6_udis_t udis : 1;
        /// Update request source This bit is set and cleared by software to
        /// select the UEV event sources. Counter overflow/underflow Setting the
        /// UG bit Update generation through the slave mode controller
        TIM6_urs_t urs : 1;
        /// One-pulse mode
        TIM6_opm_t     opm : 1;
        uint32_t const reserved_04 : 3;
        /// Auto-reload preload enable
        TIM6_arpe_t    arpe : 1;
        uint32_t const reserved_08 : 3;
        /// UIF status bit remapping
        TIM6_uifremap_t uifremap : 1;
    };
    uint32_t bits;
} TIM6_cr1_t;
STATIC_ASSERT_TYPE_SIZE(TIM6_cr1_t, sizeof(uint32_t));

/**
 * Master mode selection These bits are used to select the information to be
 * sent in master mode to slave timers for synchronization (TRGO). The
 * combination is as follows: When the Counter Enable signal is controlled by
 * the trigger input, there is a delay on TRGO, except if the master/slave mode
 * is selected (see the MSM bit description in the TIMx_SMCR register). Note:
 * The clock of the slave timer or ADC must be enabled prior to receive events
 * from the master timer, and must not be changed on-the-fly while triggers are
 * received from the master timer.
 */
typedef enum TIM6_mms_e {
    /// Reset - the UG bit from the TIMx_EGR register is used as a trigger
    /// output (TRGO). If reset is generated by the trigger input (slave mode
    /// controller configured in reset mode) then the signal on TRGO is delayed
    /// compared to the actual reset.
    TIM6_mms_b_0x0 = 0x0,
    /// Enable - the Counter enable signal, CNT_EN, is used as a trigger output
    /// (TRGO). It is useful to start several timers at the same time or to
    /// control a window in which a slave timer is enabled. The Counter Enable
    /// signal is generated by a logic OR between CEN control bit and the
    /// trigger input when configured in gated mode.
    TIM6_mms_b_0x1 = 0x1,
    /// Update - The update event is selected as a trigger output (TRGO). For
    /// instance a master timer can then be used as a prescaler for a slave
    /// timer.
    TIM6_mms_b_0x2 = 0x2,
} TIM6_mms_t;

/**
 * control register 2
 */
typedef union TIM6_cr2_u {
    struct {
        uint32_t const reserved_00 : 4;
        /// Master mode selection These bits are used to select the information
        /// to be sent in master mode to slave timers for synchronization
        /// (TRGO). The combination is as follows: When the Counter Enable
        /// signal is controlled by the trigger input, there is a delay on TRGO,
        /// except if the master/slave mode is selected (see the MSM bit
        /// description in the TIMx_SMCR register). Note: The clock of the slave
        /// timer or ADC must be enabled prior to receive events from the master
        /// timer, and must not be changed on-the-fly while triggers are
        /// received from the master timer.
        TIM6_mms_t mms : 3;
    };
    uint32_t bits;
} TIM6_cr2_t;
STATIC_ASSERT_TYPE_SIZE(TIM6_cr2_t, sizeof(uint32_t));

/**
 * Update interrupt enable
 */
typedef enum TIM6_uie_e {
    /// Update interrupt disabled.
    TIM6_uie_b_0x0 = 0x0,
    /// Update interrupt enabled.
    TIM6_uie_b_0x1 = 0x1,
} TIM6_uie_t;

/**
 * Update DMA request enable
 */
typedef enum TIM6_ude_e {
    /// Update DMA request disabled.
    TIM6_ude_b_0x0 = 0x0,
    /// Update DMA request enabled.
    TIM6_ude_b_0x1 = 0x1,
} TIM6_ude_t;

/**
 * DMA/Interrupt enable register
 */
typedef union TIM6_dier_u {
    struct {
        /// Update interrupt enable
        TIM6_uie_t     uie : 1;
        uint32_t const reserved_01 : 7;
        /// Update DMA request enable
        TIM6_ude_t ude : 1;
    };
    uint32_t bits;
} TIM6_dier_t;
STATIC_ASSERT_TYPE_SIZE(TIM6_dier_t, sizeof(uint32_t));

/**
 * Update interrupt flag This bit is set by hardware on an update event. It is
 * cleared by software. At overflow or underflow regarding the repetition
 * counter value and if UDIS = 0 in the TIMx_CR1 register. When CNT is
 * reinitialized by software using the UG bit in the TIMx_EGR register, if URS =
 * 0 and UDIS = 0 in the TIMx_CR1 register.
 */
typedef enum TIM6_uif_e {
    /// No update occurred.
    TIM6_uif_b_0x0 = 0x0,
    /// Update interrupt pending. This bit is set by hardware when the registers
    /// are updated:
    TIM6_uif_b_0x1 = 0x1,
} TIM6_uif_t;

/**
 * status register
 */
typedef union TIM6_sr_u {
    struct {
        /// Update interrupt flag This bit is set by hardware on an update
        /// event. It is cleared by software. At overflow or underflow regarding
        /// the repetition counter value and if UDIS = 0 in the TIMx_CR1
        /// register. When CNT is reinitialized by software using the UG bit in
        /// the TIMx_EGR register, if URS = 0 and UDIS = 0 in the TIMx_CR1
        /// register.
        TIM6_uif_t uif : 1;
    };
    uint32_t bits;
} TIM6_sr_t;
STATIC_ASSERT_TYPE_SIZE(TIM6_sr_t, sizeof(uint32_t));

/**
 * Update generation This bit can be set by software, it is automatically
 * cleared by hardware.
 */
typedef enum TIM6_ug_e {
    /// No action.
    TIM6_ug_b_0x0 = 0x0,
    /// Re-initializes the timer counter and generates an update of the
    /// registers. Note that the prescaler counter is cleared too (but the
    /// prescaler ratio is not affected).
    TIM6_ug_b_0x1 = 0x1,
} TIM6_ug_t;

/**
 * event generation register
 */
typedef union TIM6_egr_u {
    struct {
        /// Update generation This bit can be set by software, it is
        /// automatically cleared by hardware.
        TIM6_ug_t ug : 1;
    };
    uint32_t bits;
} TIM6_egr_t;
STATIC_ASSERT_TYPE_SIZE(TIM6_egr_t, sizeof(uint32_t));

/**
 * counter
 */
typedef union TIM6_cnt_u {
    struct {
        /// Counter value
        uint32_t       cnt : 16;
        uint32_t const reserved_16 : 15;
        /// UIF Copy This bit is a read-only copy of the UIF bit of the TIMx_ISR
        /// register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is
        /// reserved and read as 0.
        uint32_t const uifcpy : 1;
    };
    uint32_t bits;
} TIM6_cnt_t;
STATIC_ASSERT_TYPE_SIZE(TIM6_cnt_t, sizeof(uint32_t));

/**
 * prescaler
 */
typedef union TIM6_psc_u {
    struct {
        /// Prescaler value
        uint32_t psc : 16;
    };
    uint32_t bits;
} TIM6_psc_t;
STATIC_ASSERT_TYPE_SIZE(TIM6_psc_t, sizeof(uint32_t));

/**
 * auto-reload register
 */
typedef union TIM6_arr_u {
    struct {
        /// Prescaler value
        uint32_t arr : 16;
    };
    uint32_t bits;
} TIM6_arr_t;
STATIC_ASSERT_TYPE_SIZE(TIM6_arr_t, sizeof(uint32_t));

/**
 * Basic timers
 */
typedef struct TIM6_peripheral_registers_s {
    /// control register 1
    TIM6_cr1_t cr1;
    /// control register 2
    TIM6_cr2_t    cr2;
    uint8_t const reserved_0x08[4];
    /// DMA/Interrupt enable register
    TIM6_dier_t dier;
    /// status register
    TIM6_sr_t sr;
    /// event generation register
    TIM6_egr_t    egr;
    uint8_t const reserved_0x18[12];
    /// counter
    TIM6_cnt_t cnt;
    /// prescaler
    TIM6_psc_t psc;
    /// auto-reload register
    TIM6_arr_t arr;
} TIM6_peripheral_registers_t;
STATIC_ASSERT_MEMBER_OFFSET(TIM6_peripheral_registers_t, cr1, 0x00);
STATIC_ASSERT_MEMBER_OFFSET(TIM6_peripheral_registers_t, cr2, 0x04);
STATIC_ASSERT_MEMBER_OFFSET(TIM6_peripheral_registers_t, dier, 0x0C);
STATIC_ASSERT_MEMBER_OFFSET(TIM6_peripheral_registers_t, sr, 0x10);
STATIC_ASSERT_MEMBER_OFFSET(TIM6_peripheral_registers_t, egr, 0x14);
STATIC_ASSERT_MEMBER_OFFSET(TIM6_peripheral_registers_t, cnt, 0x24);
STATIC_ASSERT_MEMBER_OFFSET(TIM6_peripheral_registers_t, psc, 0x28);
STATIC_ASSERT_MEMBER_OFFSET(TIM6_peripheral_registers_t, arr, 0x2C);

#ifdef __cplusplus
}
#endif
#endif // TIM6_H_

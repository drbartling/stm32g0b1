/**
 * @file
 * @version 1.6
 * @brief Register access structs for None DMA1
 *
 * Direct memory access controller
 *
 * @note This file is autogenerated using register-code-gen
 */

#ifndef DMA1_H_
#define DMA1_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "static_assert.h"

#include <stdint.h>

/**
 * global interrupt flag for channel 1
 */
typedef enum DMA1_gif1_e {
    /// no TE, HT or TC event
    DMA1_gif1_b_0x0 = 0x0,
    /// a TE, HT or TC event occurred
    DMA1_gif1_b_0x1 = 0x1,
} DMA1_gif1_t;

/**
 * transfer complete (TC) flag for channel 1
 */
typedef enum DMA1_tcif1_e {
    /// no TC event
    DMA1_tcif1_b_0x0 = 0x0,
    /// a TC event occurred
    DMA1_tcif1_b_0x1 = 0x1,
} DMA1_tcif1_t;

/**
 * half transfer (HT) flag for channel 1
 */
typedef enum DMA1_htif1_e {
    /// no HT event
    DMA1_htif1_b_0x0 = 0x0,
    /// a HT event occurred
    DMA1_htif1_b_0x1 = 0x1,
} DMA1_htif1_t;

/**
 * transfer error (TE) flag for channel 1
 */
typedef enum DMA1_teif1_e {
    /// no TE event
    DMA1_teif1_b_0x0 = 0x0,
    /// a TE event occurred
    DMA1_teif1_b_0x1 = 0x1,
} DMA1_teif1_t;

/**
 * global interrupt flag for channel 2
 */
typedef enum DMA1_gif2_e {
    /// no TE, HT or TC event
    DMA1_gif2_b_0x0 = 0x0,
    /// a TE, HT or TC event occurred
    DMA1_gif2_b_0x1 = 0x1,
} DMA1_gif2_t;

/**
 * transfer complete (TC) flag for channel 2
 */
typedef enum DMA1_tcif2_e {
    /// no TC event
    DMA1_tcif2_b_0x0 = 0x0,
    /// a TC event occurred
    DMA1_tcif2_b_0x1 = 0x1,
} DMA1_tcif2_t;

/**
 * half transfer (HT) flag for channel 2
 */
typedef enum DMA1_htif2_e {
    /// no HT event
    DMA1_htif2_b_0x0 = 0x0,
    /// a HT event occurred
    DMA1_htif2_b_0x1 = 0x1,
} DMA1_htif2_t;

/**
 * transfer error (TE) flag for channel 2
 */
typedef enum DMA1_teif2_e {
    /// no TE event
    DMA1_teif2_b_0x0 = 0x0,
    /// a TE event occurred
    DMA1_teif2_b_0x1 = 0x1,
} DMA1_teif2_t;

/**
 * global interrupt flag for channel 3
 */
typedef enum DMA1_gif3_e {
    /// no TE, HT or TC event
    DMA1_gif3_b_0x0 = 0x0,
    /// a TE, HT or TC event occurred
    DMA1_gif3_b_0x1 = 0x1,
} DMA1_gif3_t;

/**
 * transfer complete (TC) flag for channel 3
 */
typedef enum DMA1_tcif3_e {
    /// no TC event
    DMA1_tcif3_b_0x0 = 0x0,
    /// a TC event occurred
    DMA1_tcif3_b_0x1 = 0x1,
} DMA1_tcif3_t;

/**
 * half transfer (HT) flag for channel 3
 */
typedef enum DMA1_htif3_e {
    /// no HT event
    DMA1_htif3_b_0x0 = 0x0,
    /// a HT event occurred
    DMA1_htif3_b_0x1 = 0x1,
} DMA1_htif3_t;

/**
 * transfer error (TE) flag for channel 3
 */
typedef enum DMA1_teif3_e {
    /// no TE event
    DMA1_teif3_b_0x0 = 0x0,
    /// a TE event occurred
    DMA1_teif3_b_0x1 = 0x1,
} DMA1_teif3_t;

/**
 * global interrupt flag for channel 4
 */
typedef enum DMA1_gif4_e {
    /// no TE, HT or TC event
    DMA1_gif4_b_0x0 = 0x0,
    /// a TE, HT or TC event occurred
    DMA1_gif4_b_0x1 = 0x1,
} DMA1_gif4_t;

/**
 * transfer complete (TC) flag for channel 4
 */
typedef enum DMA1_tcif4_e {
    /// no TC event
    DMA1_tcif4_b_0x0 = 0x0,
    /// a TC event occurred
    DMA1_tcif4_b_0x1 = 0x1,
} DMA1_tcif4_t;

/**
 * half transfer (HT) flag for channel 4
 */
typedef enum DMA1_htif4_e {
    /// no HT event
    DMA1_htif4_b_0x0 = 0x0,
    /// a HT event occurred
    DMA1_htif4_b_0x1 = 0x1,
} DMA1_htif4_t;

/**
 * transfer error (TE) flag for channel 4
 */
typedef enum DMA1_teif4_e {
    /// no TE event
    DMA1_teif4_b_0x0 = 0x0,
    /// a TE event occurred
    DMA1_teif4_b_0x1 = 0x1,
} DMA1_teif4_t;

/**
 * global interrupt flag for channel 5
 */
typedef enum DMA1_gif5_e {
    /// no TE, HT or TC event
    DMA1_gif5_b_0x0 = 0x0,
    /// a TE, HT or TC event occurred
    DMA1_gif5_b_0x1 = 0x1,
} DMA1_gif5_t;

/**
 * transfer complete (TC) flag for channel 5
 */
typedef enum DMA1_tcif5_e {
    /// no TC event
    DMA1_tcif5_b_0x0 = 0x0,
    /// a TC event occurred
    DMA1_tcif5_b_0x1 = 0x1,
} DMA1_tcif5_t;

/**
 * half transfer (HT) flag for channel 5
 */
typedef enum DMA1_htif5_e {
    /// no HT event
    DMA1_htif5_b_0x0 = 0x0,
    /// a HT event occurred
    DMA1_htif5_b_0x1 = 0x1,
} DMA1_htif5_t;

/**
 * transfer error (TE) flag for channel 5
 */
typedef enum DMA1_teif5_e {
    /// no TE event
    DMA1_teif5_b_0x0 = 0x0,
    /// a TE event occurred
    DMA1_teif5_b_0x1 = 0x1,
} DMA1_teif5_t;

/**
 * global interrupt flag for channel 6
 */
typedef enum DMA1_gif6_e {
    /// no TE, HT or TC event
    DMA1_gif6_b_0x0 = 0x0,
    /// a TE, HT or TC event occurred
    DMA1_gif6_b_0x1 = 0x1,
} DMA1_gif6_t;

/**
 * transfer complete (TC) flag for channel 6
 */
typedef enum DMA1_tcif6_e {
    /// no TC event
    DMA1_tcif6_b_0x0 = 0x0,
    /// a TC event occurred
    DMA1_tcif6_b_0x1 = 0x1,
} DMA1_tcif6_t;

/**
 * half transfer (HT) flag for channel 6
 */
typedef enum DMA1_htif6_e {
    /// no HT event
    DMA1_htif6_b_0x0 = 0x0,
    /// a HT event occurred
    DMA1_htif6_b_0x1 = 0x1,
} DMA1_htif6_t;

/**
 * transfer error (TE) flag for channel 6
 */
typedef enum DMA1_teif6_e {
    /// no TE event
    DMA1_teif6_b_0x0 = 0x0,
    /// a TE event occurred
    DMA1_teif6_b_0x1 = 0x1,
} DMA1_teif6_t;

/**
 * global interrupt flag for channel 7
 */
typedef enum DMA1_gif7_e {
    /// no TE, HT or TC event
    DMA1_gif7_b_0x0 = 0x0,
    /// a TE, HT or TC event occurred
    DMA1_gif7_b_0x1 = 0x1,
} DMA1_gif7_t;

/**
 * transfer complete (TC) flag for channel 7
 */
typedef enum DMA1_tcif7_e {
    /// no TC event
    DMA1_tcif7_b_0x0 = 0x0,
    /// a TC event occurred
    DMA1_tcif7_b_0x1 = 0x1,
} DMA1_tcif7_t;

/**
 * half transfer (HT) flag for channel 7
 */
typedef enum DMA1_htif7_e {
    /// no HT event
    DMA1_htif7_b_0x0 = 0x0,
    /// a HT event occurred
    DMA1_htif7_b_0x1 = 0x1,
} DMA1_htif7_t;

/**
 * transfer error (TE) flag for channel 7
 */
typedef enum DMA1_teif7_e {
    /// no TE event
    DMA1_teif7_b_0x0 = 0x0,
    /// a TE event occurred
    DMA1_teif7_b_0x1 = 0x1,
} DMA1_teif7_t;

/**
 * DMA interrupt status register
 */
typedef union DMA1_dma_isr_u {
    struct {
        /// global interrupt flag for channel 1
        DMA1_gif1_t const gif1 : 1;
        /// transfer complete (TC) flag for channel 1
        DMA1_tcif1_t const tcif1 : 1;
        /// half transfer (HT) flag for channel 1
        DMA1_htif1_t const htif1 : 1;
        /// transfer error (TE) flag for channel 1
        DMA1_teif1_t const teif1 : 1;
        /// global interrupt flag for channel 2
        DMA1_gif2_t const gif2 : 1;
        /// transfer complete (TC) flag for channel 2
        DMA1_tcif2_t const tcif2 : 1;
        /// half transfer (HT) flag for channel 2
        DMA1_htif2_t const htif2 : 1;
        /// transfer error (TE) flag for channel 2
        DMA1_teif2_t const teif2 : 1;
        /// global interrupt flag for channel 3
        DMA1_gif3_t const gif3 : 1;
        /// transfer complete (TC) flag for channel 3
        DMA1_tcif3_t const tcif3 : 1;
        /// half transfer (HT) flag for channel 3
        DMA1_htif3_t const htif3 : 1;
        /// transfer error (TE) flag for channel 3
        DMA1_teif3_t const teif3 : 1;
        /// global interrupt flag for channel 4
        DMA1_gif4_t const gif4 : 1;
        /// transfer complete (TC) flag for channel 4
        DMA1_tcif4_t const tcif4 : 1;
        /// half transfer (HT) flag for channel 4
        DMA1_htif4_t const htif4 : 1;
        /// transfer error (TE) flag for channel 4
        DMA1_teif4_t const teif4 : 1;
        /// global interrupt flag for channel 5
        DMA1_gif5_t const gif5 : 1;
        /// transfer complete (TC) flag for channel 5
        DMA1_tcif5_t const tcif5 : 1;
        /// half transfer (HT) flag for channel 5
        DMA1_htif5_t const htif5 : 1;
        /// transfer error (TE) flag for channel 5
        DMA1_teif5_t const teif5 : 1;
        /// global interrupt flag for channel 6
        DMA1_gif6_t const gif6 : 1;
        /// transfer complete (TC) flag for channel 6
        DMA1_tcif6_t const tcif6 : 1;
        /// half transfer (HT) flag for channel 6
        DMA1_htif6_t const htif6 : 1;
        /// transfer error (TE) flag for channel 6
        DMA1_teif6_t const teif6 : 1;
        /// global interrupt flag for channel 7
        DMA1_gif7_t const gif7 : 1;
        /// transfer complete (TC) flag for channel 7
        DMA1_tcif7_t const tcif7 : 1;
        /// half transfer (HT) flag for channel 7
        DMA1_htif7_t const htif7 : 1;
        /// transfer error (TE) flag for channel 7
        DMA1_teif7_t const teif7 : 1;
    };
    uint32_t bits;
} DMA1_dma_isr_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_isr_t, sizeof(uint32_t));

/**
 * DMA interrupt flag clear register
 */
typedef union DMA1_dma_ifcr_u {
    struct {
        /// global interrupt flag clear for channel 1
        uint32_t cgif1 : 1;
        /// transfer complete flag clear for channel 1
        uint32_t ctcif1 : 1;
        /// half transfer flag clear for channel 1
        uint32_t chtif1 : 1;
        /// transfer error flag clear for channel 1
        uint32_t cteif1 : 1;
        /// global interrupt flag clear for channel 2
        uint32_t cgif2 : 1;
        /// transfer complete flag clear for channel 2
        uint32_t ctcif2 : 1;
        /// half transfer flag clear for channel 2
        uint32_t chtif2 : 1;
        /// transfer error flag clear for channel 2
        uint32_t cteif2 : 1;
        /// global interrupt flag clear for channel 3
        uint32_t cgif3 : 1;
        /// transfer complete flag clear for channel 3
        uint32_t ctcif3 : 1;
        /// half transfer flag clear for channel 3
        uint32_t chtif3 : 1;
        /// transfer error flag clear for channel 3
        uint32_t cteif3 : 1;
        /// global interrupt flag clear for channel 4
        uint32_t cgif4 : 1;
        /// transfer complete flag clear for channel 4
        uint32_t ctcif4 : 1;
        /// half transfer flag clear for channel 4
        uint32_t chtif4 : 1;
        /// transfer error flag clear for channel 4
        uint32_t cteif4 : 1;
        /// global interrupt flag clear for channel 5
        uint32_t cgif5 : 1;
        /// transfer complete flag clear for channel 5
        uint32_t ctcif5 : 1;
        /// half transfer flag clear for channel 5
        uint32_t chtif5 : 1;
        /// transfer error flag clear for channel 5
        uint32_t cteif5 : 1;
        /// global interrupt flag clear for channel 6
        uint32_t cgif6 : 1;
        /// transfer complete flag clear for channel 6
        uint32_t ctcif6 : 1;
        /// half transfer flag clear for channel 6
        uint32_t chtif6 : 1;
        /// transfer error flag clear for channel 6
        uint32_t cteif6 : 1;
        /// global interrupt flag clear for channel 7
        uint32_t cgif7 : 1;
        /// transfer complete flag clear for channel 7
        uint32_t ctcif7 : 1;
        /// half transfer flag clear for channel 7
        uint32_t chtif7 : 1;
        /// transfer error flag clear for channel 7
        uint32_t cteif7 : 1;
    };
    uint32_t bits;
} DMA1_dma_ifcr_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_ifcr_t, sizeof(uint32_t));

/**
 * channel enable When a channel transfer error occurs, this bit is cleared by
 * hardware. It can not be set again by software (channel x re-activated) until
 * the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit
 * of the DMA_IFCR register). Note: this bit is set and cleared by software.
 */
typedef enum DMA1_en_e {
    /// disabled
    DMA1_en_b_0x0 = 0x0,
    /// enabled
    DMA1_en_b_0x1 = 0x1,
} DMA1_en_t;

/**
 * transfer complete interrupt enable Note: this bit is set and cleared by
 * software. It must not be written when the channel is enabled (EN = 1). It is
 * not read-only when the channel is enabled (ENÂ =Â 1).
 */
typedef enum DMA1_tcie_e {
    /// disabled
    DMA1_tcie_b_0x0 = 0x0,
    /// enabled
    DMA1_tcie_b_0x1 = 0x1,
} DMA1_tcie_t;

/**
 * half transfer interrupt enable Note: this bit is set and cleared by software.
 * It must not be written when the channel is enabled (EN = 1). It is not
 * read-only when the channel is enabled (ENÂ =Â 1).
 */
typedef enum DMA1_htie_e {
    /// disabled
    DMA1_htie_b_0x0 = 0x0,
    /// enabled
    DMA1_htie_b_0x1 = 0x1,
} DMA1_htie_t;

/**
 * transfer error interrupt enable Note: this bit is set and cleared by
 * software. It must not be written when the channel is enabled (EN = 1). It is
 * not read-only when the channel is enabled (ENÂ =Â 1).
 */
typedef enum DMA1_teie_e {
    /// disabled
    DMA1_teie_b_0x0 = 0x0,
    /// enabled
    DMA1_teie_b_0x1 = 0x1,
} DMA1_teie_t;

/**
 * data transfer direction This bit must be set only in memory-to-peripheral and
 * peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC,
 * plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.
 * Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx
 * register. This is still valid in a peripheral-to-peripheral mode. Destination
 * attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This
 * is still valid in a memory-to-memory mode. Source attributes are defined by
 * MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a
 * peripheral-to-peripheral mode. Note: this bit is set and cleared by software.
 * It must not be written when the channel is enabled (EN = 1). It is read-only
 * when the channel is enabled (ENÂ =Â 1).
 */
typedef enum DMA1_dir_e {
    /// read from peripheral
    DMA1_dir_b_0x0 = 0x0,
    /// read from memory
    DMA1_dir_b_0x1 = 0x1,
} DMA1_dir_t;

/**
 * circular mode Note: this bit is set and cleared by software. It must not be
 * written when the channel is enabled (EN = 1). It is not read-only when the
 * channel is enabled (ENÂ =Â 1).
 */
typedef enum DMA1_circ_e {
    /// disabled
    DMA1_circ_b_0x0 = 0x0,
    /// enabled
    DMA1_circ_b_0x1 = 0x1,
} DMA1_circ_t;

/**
 * peripheral increment mode Defines the increment mode for each DMA transfer to
 * the identified peripheral. n memory-to-memory mode, this field identifies the
 * memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In
 * peripheral-to-peripheral mode, this field identifies the peripheral
 * destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this
 * bit is set and cleared by software. It must not be written when the channel
 * is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
 */
typedef enum DMA1_pinc_e {
    /// disabled
    DMA1_pinc_b_0x0 = 0x0,
    /// enabled
    DMA1_pinc_b_0x1 = 0x1,
} DMA1_pinc_t;

/**
 * memory increment mode Defines the increment mode for each DMA transfer to the
 * identified memory. In memory-to-memory mode, this field identifies the memory
 * source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In
 * peripheral-to-peripheral mode, this field identifies the peripheral source if
 * DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this bit is set
 * and cleared by software. It must not be written when the channel is enabled
 * (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
 */
typedef enum DMA1_minc_e {
    /// disabled
    DMA1_minc_b_0x0 = 0x0,
    /// enabled
    DMA1_minc_b_0x1 = 0x1,
} DMA1_minc_t;

/**
 * peripheral size Defines the data size of each DMA transfer to the identified
 * peripheral. In memory-to-memory mode, this field identifies the memory
 * destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In
 * peripheral-to-peripheral mode, this field identifies the peripheral
 * destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this
 * field is set and cleared by software. It must not be written when the channel
 * is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
 */
typedef enum DMA1_psize_e {
    /// 8 bits
    DMA1_psize_b_0x0 = 0x0,
    /// 16 bits
    DMA1_psize_b_0x1 = 0x1,
    /// 32 bits
    DMA1_psize_b_0x2 = 0x2,
} DMA1_psize_t;

/**
 * memory size Defines the data size of each DMA transfer to the identified
 * memory. In memory-to-memory mode, this field identifies the memory source if
 * DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In
 * peripheral-to-peripheral mode, this field identifies the peripheral source if
 * DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this field is
 * set and cleared by software. It must not be written when the channel is
 * enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
 */
typedef enum DMA1_msize_e {
    /// 8 bits
    DMA1_msize_b_0x0 = 0x0,
    /// 16 bits
    DMA1_msize_b_0x1 = 0x1,
    /// 32 bits
    DMA1_msize_b_0x2 = 0x2,
} DMA1_msize_t;

/**
 * priority level Note: this field is set and cleared by software. It must not
 * be written when the channel is enabled (EN = 1). It is read-only when the
 * channel is enabled (ENÂ =Â 1).
 */
typedef enum DMA1_pl_e {
    /// low
    DMA1_pl_b_0x0 = 0x0,
    /// medium
    DMA1_pl_b_0x1 = 0x1,
    /// high
    DMA1_pl_b_0x2 = 0x2,
    /// very high
    DMA1_pl_b_0x3 = 0x3,
} DMA1_pl_t;

/**
 * memory-to-memory mode Note: this bit is set and cleared by software. It must
 * not be written when the channel is enabled (EN = 1). It is read-only when the
 * channel is enabled (ENÂ =Â 1).
 */
typedef enum DMA1_mem2mem_e {
    /// disabled
    DMA1_mem2mem_b_0x0 = 0x0,
    /// enabled
    DMA1_mem2mem_b_0x1 = 0x1,
} DMA1_mem2mem_t;

/**
 * DMA channel 1 configuration register
 */
typedef union DMA1_dma_ccr1_u {
    struct {
        /// channel enable When a channel transfer error occurs, this bit is
        /// cleared by hardware. It can not be set again by software (channel x
        /// re-activated) until the TEIFx bit of the DMA_ISR register is cleared
        /// (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit
        /// is set and cleared by software.
        DMA1_en_t en : 1;
        /// transfer complete interrupt enable Note: this bit is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_tcie_t tcie : 1;
        /// half transfer interrupt enable Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_htie_t htie : 1;
        /// transfer error interrupt enable Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_teie_t teie : 1;
        /// data transfer direction This bit must be set only in
        /// memory-to-peripheral and peripheral-to-memory modes. Source
        /// attributes are defined by PSIZE and PINC, plus the DMA_CPARx
        /// register. This is still valid in a memory-to-memory mode.
        /// Destination attributes are defined by MSIZE and MINC, plus the
        /// DMA_CMARx register. This is still valid in a
        /// peripheral-to-peripheral mode. Destination attributes are defined by
        /// PSIZE and PINC, plus the DMA_CPARx register. This is still valid in
        /// a memory-to-memory mode. Source attributes are defined by MSIZE and
        /// MINC, plus the DMA_CMARx register. This is still valid in a
        /// peripheral-to-peripheral mode. Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_dir_t dir : 1;
        /// circular mode Note: this bit is set and cleared by software. It must
        /// not be written when the channel is enabled (EN = 1). It is not
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_circ_t circ : 1;
        /// peripheral increment mode Defines the increment mode for each DMA
        /// transfer to the identified peripheral. n memory-to-memory mode, this
        /// field identifies the memory destination if DIRÂ =Â 1 and the memory
        /// source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field
        /// identifies the peripheral destination if DIRÂ =Â 1 and the
        /// peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_pinc_t pinc : 1;
        /// memory increment mode Defines the increment mode for each DMA
        /// transfer to the identified memory. In memory-to-memory mode, this
        /// field identifies the memory source if DIRÂ =Â 1 and the memory
        /// destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this
        /// field identifies the peripheral source if DIRÂ =Â 1 and the
        /// peripheral destination if DIRÂ =Â 0. Note: this bit is set and
        /// cleared by software. It must not be written when the channel is
        /// enabled (EN = 1). It is read-only when the channel is enabled (ENÂ
        /// =Â 1).
        DMA1_minc_t minc : 1;
        /// peripheral size Defines the data size of each DMA transfer to the
        /// identified peripheral. In memory-to-memory mode, this field
        /// identifies the memory destination if DIRÂ =Â 1 and the memory source
        /// if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field
        /// identifies the peripheral destination if DIRÂ =Â 1 and the
        /// peripheral source if DIRÂ =Â 0. Note: this field is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_psize_t psize : 2;
        /// memory size Defines the data size of each DMA transfer to the
        /// identified memory. In memory-to-memory mode, this field identifies
        /// the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â
        /// 0. In peripheral-to-peripheral mode, this field identifies the
        /// peripheral source if DIRÂ =Â 1 and the peripheral destination if
        /// DIRÂ =Â 0. Note: this field is set and cleared by software. It must
        /// not be written when the channel is enabled (EN = 1). It is read-only
        /// when the channel is enabled (ENÂ =Â 1).
        DMA1_msize_t msize : 2;
        /// priority level Note: this field is set and cleared by software. It
        /// must not be written when the channel is enabled (EN = 1). It is
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_pl_t pl : 2;
        /// memory-to-memory mode Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1). It is
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_mem2mem_t mem2mem : 1;
    };
    uint32_t bits;
} DMA1_dma_ccr1_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_ccr1_t, sizeof(uint32_t));

/**
 * DMA channel 1 number of data to transfer register
 */
typedef union DMA1_dma_cndtr1_u {
    struct {
        /// number of data to transfer (0 to 216Â -Â 1) This field is updated by
        /// hardware when the channel is enabled: It is decremented after each
        /// single DMA 'read followed by writeâ transfer, indicating the
        /// remaining amount of data items to transfer. It is kept at zero when
        /// the programmed amount of data to transfer is reached, if the channel
        /// is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is
        /// reloaded automatically by the previously programmed value, when the
        /// transfer is complete, if the channel is in circular mode (CIRCÂ =Â
        /// 1). If this field is zero, no transfer can be served whatever the
        /// channel status (enabled or not). Note: this field is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        uint32_t ndt : 16;
    };
    uint32_t bits;
} DMA1_dma_cndtr1_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cndtr1_t, sizeof(uint32_t));

/**
 * DMA channel 1 peripheral address register
 */
typedef union DMA1_dma_cpar1_u {
    struct {
        /// peripheral address It contains the base address of the peripheral
        /// data register from/to which the data will be read/written. When
        /// PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is
        /// automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32
        /// bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically
        /// aligned to a word address. In memory-to-memory mode, this register
        /// identifies the memory destination address if DIRÂ =Â 1 and the
        /// memory source address if DIRÂ =Â 0. In peripheral-to-peripheral
        /// mode, this register identifies the peripheral destination address
        /// DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this
        /// register is set and cleared by software. It must not be written when
        /// the channel is enabled (EN = 1). It is not read-only when the
        /// channel is enabled (ENÂ =Â 1).
        uint32_t pa : 32;
    };
    uint32_t bits;
} DMA1_dma_cpar1_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cpar1_t, sizeof(uint32_t));

/**
 * DMA channel 1 memory address register
 */
typedef union DMA1_dma_cmar1_u {
    struct {
        /// peripheral address It contains the base address of the memory
        /// from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01
        /// (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically
        /// aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1
        /// and 0 of MA[31:0] are ignored. Access is automatically aligned to a
        /// word address. In memory-to-memory mode, this register identifies the
        /// memory source address if DIRÂ =Â 1 and the memory destination
        /// address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this
        /// register identifies the peripheral source address DIRÂ =Â 1 and the
        /// peripheral destination address if DIRÂ =Â 0. Note: this register is
        /// set and cleared by software. It must not be written when the channel
        /// is enabled (EN = 1). It is not read-only when the channel is enabled
        /// (ENÂ =Â 1).
        uint32_t ma : 32;
    };
    uint32_t bits;
} DMA1_dma_cmar1_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cmar1_t, sizeof(uint32_t));

/**
 * DMA channel 2 configuration register
 */
typedef union DMA1_dma_ccr2_u {
    struct {
        /// channel enable When a channel transfer error occurs, this bit is
        /// cleared by hardware. It can not be set again by software (channel x
        /// re-activated) until the TEIFx bit of the DMA_ISR register is cleared
        /// (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit
        /// is set and cleared by software.
        DMA1_en_t en : 1;
        /// transfer complete interrupt enable Note: this bit is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_tcie_t tcie : 1;
        /// half transfer interrupt enable Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_htie_t htie : 1;
        /// transfer error interrupt enable Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_teie_t teie : 1;
        /// data transfer direction This bit must be set only in
        /// memory-to-peripheral and peripheral-to-memory modes. Source
        /// attributes are defined by PSIZE and PINC, plus the DMA_CPARx
        /// register. This is still valid in a memory-to-memory mode.
        /// Destination attributes are defined by MSIZE and MINC, plus the
        /// DMA_CMARx register. This is still valid in a
        /// peripheral-to-peripheral mode. Destination attributes are defined by
        /// PSIZE and PINC, plus the DMA_CPARx register. This is still valid in
        /// a memory-to-memory mode. Source attributes are defined by MSIZE and
        /// MINC, plus the DMA_CMARx register. This is still valid in a
        /// peripheral-to-peripheral mode. Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_dir_t dir : 1;
        /// circular mode Note: this bit is set and cleared by software. It must
        /// not be written when the channel is enabled (EN = 1). It is not
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_circ_t circ : 1;
        /// peripheral increment mode Defines the increment mode for each DMA
        /// transfer to the identified peripheral. n memory-to-memory mode, this
        /// field identifies the memory destination if DIRÂ =Â 1 and the memory
        /// source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field
        /// identifies the peripheral destination if DIRÂ =Â 1 and the
        /// peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_pinc_t pinc : 1;
        /// memory increment mode Defines the increment mode for each DMA
        /// transfer to the identified memory. In memory-to-memory mode, this
        /// field identifies the memory source if DIRÂ =Â 1 and the memory
        /// destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this
        /// field identifies the peripheral source if DIRÂ =Â 1 and the
        /// peripheral destination if DIRÂ =Â 0. Note: this bit is set and
        /// cleared by software. It must not be written when the channel is
        /// enabled (EN = 1). It is read-only when the channel is enabled (ENÂ
        /// =Â 1).
        DMA1_minc_t minc : 1;
        /// peripheral size Defines the data size of each DMA transfer to the
        /// identified peripheral. In memory-to-memory mode, this field
        /// identifies the memory destination if DIRÂ =Â 1 and the memory source
        /// if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field
        /// identifies the peripheral destination if DIRÂ =Â 1 and the
        /// peripheral source if DIRÂ =Â 0. Note: this field is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_psize_t psize : 2;
        /// memory size Defines the data size of each DMA transfer to the
        /// identified memory. In memory-to-memory mode, this field identifies
        /// the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â
        /// 0. In peripheral-to-peripheral mode, this field identifies the
        /// peripheral source if DIRÂ =Â 1 and the peripheral destination if
        /// DIRÂ =Â 0. Note: this field is set and cleared by software. It must
        /// not be written when the channel is enabled (EN = 1). It is read-only
        /// when the channel is enabled (ENÂ =Â 1).
        DMA1_msize_t msize : 2;
        /// priority level Note: this field is set and cleared by software. It
        /// must not be written when the channel is enabled (EN = 1). It is
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_pl_t pl : 2;
        /// memory-to-memory mode Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1). It is
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_mem2mem_t mem2mem : 1;
    };
    uint32_t bits;
} DMA1_dma_ccr2_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_ccr2_t, sizeof(uint32_t));

/**
 * DMA channel 2 number of data to transfer register
 */
typedef union DMA1_dma_cndtr2_u {
    struct {
        /// number of data to transfer (0 to 216Â -Â 1) This field is updated by
        /// hardware when the channel is enabled: It is decremented after each
        /// single DMA 'read followed by writeâ transfer, indicating the
        /// remaining amount of data items to transfer. It is kept at zero when
        /// the programmed amount of data to transfer is reached, if the channel
        /// is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is
        /// reloaded automatically by the previously programmed value, when the
        /// transfer is complete, if the channel is in circular mode (CIRCÂ =Â
        /// 1). If this field is zero, no transfer can be served whatever the
        /// channel status (enabled or not). Note: this field is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        uint32_t ndt : 16;
    };
    uint32_t bits;
} DMA1_dma_cndtr2_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cndtr2_t, sizeof(uint32_t));

/**
 * DMA channel 2 peripheral address register
 */
typedef union DMA1_dma_cpar2_u {
    struct {
        /// peripheral address It contains the base address of the peripheral
        /// data register from/to which the data will be read/written. When
        /// PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is
        /// automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32
        /// bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically
        /// aligned to a word address. In memory-to-memory mode, this register
        /// identifies the memory destination address if DIRÂ =Â 1 and the
        /// memory source address if DIRÂ =Â 0. In peripheral-to-peripheral
        /// mode, this register identifies the peripheral destination address
        /// DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this
        /// register is set and cleared by software. It must not be written when
        /// the channel is enabled (EN = 1). It is not read-only when the
        /// channel is enabled (ENÂ =Â 1).
        uint32_t pa : 32;
    };
    uint32_t bits;
} DMA1_dma_cpar2_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cpar2_t, sizeof(uint32_t));

/**
 * DMA channel 2 memory address register
 */
typedef union DMA1_dma_cmar2_u {
    struct {
        /// peripheral address It contains the base address of the memory
        /// from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01
        /// (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically
        /// aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1
        /// and 0 of MA[31:0] are ignored. Access is automatically aligned to a
        /// word address. In memory-to-memory mode, this register identifies the
        /// memory source address if DIRÂ =Â 1 and the memory destination
        /// address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this
        /// register identifies the peripheral source address DIRÂ =Â 1 and the
        /// peripheral destination address if DIRÂ =Â 0. Note: this register is
        /// set and cleared by software. It must not be written when the channel
        /// is enabled (EN = 1). It is not read-only when the channel is enabled
        /// (ENÂ =Â 1).
        uint32_t ma : 32;
    };
    uint32_t bits;
} DMA1_dma_cmar2_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cmar2_t, sizeof(uint32_t));

/**
 * DMA channel 3 configuration register
 */
typedef union DMA1_dma_ccr3_u {
    struct {
        /// channel enable When a channel transfer error occurs, this bit is
        /// cleared by hardware. It can not be set again by software (channel x
        /// re-activated) until the TEIFx bit of the DMA_ISR register is cleared
        /// (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit
        /// is set and cleared by software.
        DMA1_en_t en : 1;
        /// transfer complete interrupt enable Note: this bit is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_tcie_t tcie : 1;
        /// half transfer interrupt enable Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_htie_t htie : 1;
        /// transfer error interrupt enable Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_teie_t teie : 1;
        /// data transfer direction This bit must be set only in
        /// memory-to-peripheral and peripheral-to-memory modes. Source
        /// attributes are defined by PSIZE and PINC, plus the DMA_CPARx
        /// register. This is still valid in a memory-to-memory mode.
        /// Destination attributes are defined by MSIZE and MINC, plus the
        /// DMA_CMARx register. This is still valid in a
        /// peripheral-to-peripheral mode. Destination attributes are defined by
        /// PSIZE and PINC, plus the DMA_CPARx register. This is still valid in
        /// a memory-to-memory mode. Source attributes are defined by MSIZE and
        /// MINC, plus the DMA_CMARx register. This is still valid in a
        /// peripheral-to-peripheral mode. Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_dir_t dir : 1;
        /// circular mode Note: this bit is set and cleared by software. It must
        /// not be written when the channel is enabled (EN = 1). It is not
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_circ_t circ : 1;
        /// peripheral increment mode Defines the increment mode for each DMA
        /// transfer to the identified peripheral. n memory-to-memory mode, this
        /// field identifies the memory destination if DIRÂ =Â 1 and the memory
        /// source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field
        /// identifies the peripheral destination if DIRÂ =Â 1 and the
        /// peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_pinc_t pinc : 1;
        /// memory increment mode Defines the increment mode for each DMA
        /// transfer to the identified memory. In memory-to-memory mode, this
        /// field identifies the memory source if DIRÂ =Â 1 and the memory
        /// destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this
        /// field identifies the peripheral source if DIRÂ =Â 1 and the
        /// peripheral destination if DIRÂ =Â 0. Note: this bit is set and
        /// cleared by software. It must not be written when the channel is
        /// enabled (EN = 1). It is read-only when the channel is enabled (ENÂ
        /// =Â 1).
        DMA1_minc_t minc : 1;
        /// peripheral size Defines the data size of each DMA transfer to the
        /// identified peripheral. In memory-to-memory mode, this field
        /// identifies the memory destination if DIRÂ =Â 1 and the memory source
        /// if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field
        /// identifies the peripheral destination if DIRÂ =Â 1 and the
        /// peripheral source if DIRÂ =Â 0. Note: this field is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_psize_t psize : 2;
        /// memory size Defines the data size of each DMA transfer to the
        /// identified memory. In memory-to-memory mode, this field identifies
        /// the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â
        /// 0. In peripheral-to-peripheral mode, this field identifies the
        /// peripheral source if DIRÂ =Â 1 and the peripheral destination if
        /// DIRÂ =Â 0. Note: this field is set and cleared by software. It must
        /// not be written when the channel is enabled (EN = 1). It is read-only
        /// when the channel is enabled (ENÂ =Â 1).
        DMA1_msize_t msize : 2;
        /// priority level Note: this field is set and cleared by software. It
        /// must not be written when the channel is enabled (EN = 1). It is
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_pl_t pl : 2;
        /// memory-to-memory mode Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1). It is
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_mem2mem_t mem2mem : 1;
    };
    uint32_t bits;
} DMA1_dma_ccr3_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_ccr3_t, sizeof(uint32_t));

/**
 * DMA channel 3 number of data to transfer register
 */
typedef union DMA1_dma_cndtr3_u {
    struct {
        /// number of data to transfer (0 to 216Â -Â 1) This field is updated by
        /// hardware when the channel is enabled: It is decremented after each
        /// single DMA 'read followed by writeâ transfer, indicating the
        /// remaining amount of data items to transfer. It is kept at zero when
        /// the programmed amount of data to transfer is reached, if the channel
        /// is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is
        /// reloaded automatically by the previously programmed value, when the
        /// transfer is complete, if the channel is in circular mode (CIRCÂ =Â
        /// 1). If this field is zero, no transfer can be served whatever the
        /// channel status (enabled or not). Note: this field is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        uint32_t ndt : 16;
    };
    uint32_t bits;
} DMA1_dma_cndtr3_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cndtr3_t, sizeof(uint32_t));

/**
 * DMA channel 3 peripheral address register
 */
typedef union DMA1_dma_cpar3_u {
    struct {
        /// peripheral address It contains the base address of the peripheral
        /// data register from/to which the data will be read/written. When
        /// PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is
        /// automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32
        /// bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically
        /// aligned to a word address. In memory-to-memory mode, this register
        /// identifies the memory destination address if DIRÂ =Â 1 and the
        /// memory source address if DIRÂ =Â 0. In peripheral-to-peripheral
        /// mode, this register identifies the peripheral destination address
        /// DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this
        /// register is set and cleared by software. It must not be written when
        /// the channel is enabled (EN = 1). It is not read-only when the
        /// channel is enabled (ENÂ =Â 1).
        uint32_t pa : 32;
    };
    uint32_t bits;
} DMA1_dma_cpar3_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cpar3_t, sizeof(uint32_t));

/**
 * DMA channel 3 memory address register
 */
typedef union DMA1_dma_cmar3_u {
    struct {
        /// peripheral address It contains the base address of the memory
        /// from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01
        /// (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically
        /// aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1
        /// and 0 of MA[31:0] are ignored. Access is automatically aligned to a
        /// word address. In memory-to-memory mode, this register identifies the
        /// memory source address if DIRÂ =Â 1 and the memory destination
        /// address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this
        /// register identifies the peripheral source address DIRÂ =Â 1 and the
        /// peripheral destination address if DIRÂ =Â 0. Note: this register is
        /// set and cleared by software. It must not be written when the channel
        /// is enabled (EN = 1). It is not read-only when the channel is enabled
        /// (ENÂ =Â 1).
        uint32_t ma : 32;
    };
    uint32_t bits;
} DMA1_dma_cmar3_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cmar3_t, sizeof(uint32_t));

/**
 * DMA channel 4 configuration register
 */
typedef union DMA1_dma_ccr4_u {
    struct {
        /// channel enable When a channel transfer error occurs, this bit is
        /// cleared by hardware. It can not be set again by software (channel x
        /// re-activated) until the TEIFx bit of the DMA_ISR register is cleared
        /// (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit
        /// is set and cleared by software.
        DMA1_en_t en : 1;
        /// transfer complete interrupt enable Note: this bit is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_tcie_t tcie : 1;
        /// half transfer interrupt enable Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_htie_t htie : 1;
        /// transfer error interrupt enable Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_teie_t teie : 1;
        /// data transfer direction This bit must be set only in
        /// memory-to-peripheral and peripheral-to-memory modes. Source
        /// attributes are defined by PSIZE and PINC, plus the DMA_CPARx
        /// register. This is still valid in a memory-to-memory mode.
        /// Destination attributes are defined by MSIZE and MINC, plus the
        /// DMA_CMARx register. This is still valid in a
        /// peripheral-to-peripheral mode. Destination attributes are defined by
        /// PSIZE and PINC, plus the DMA_CPARx register. This is still valid in
        /// a memory-to-memory mode. Source attributes are defined by MSIZE and
        /// MINC, plus the DMA_CMARx register. This is still valid in a
        /// peripheral-to-peripheral mode. Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_dir_t dir : 1;
        /// circular mode Note: this bit is set and cleared by software. It must
        /// not be written when the channel is enabled (EN = 1). It is not
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_circ_t circ : 1;
        /// peripheral increment mode Defines the increment mode for each DMA
        /// transfer to the identified peripheral. n memory-to-memory mode, this
        /// field identifies the memory destination if DIRÂ =Â 1 and the memory
        /// source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field
        /// identifies the peripheral destination if DIRÂ =Â 1 and the
        /// peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_pinc_t pinc : 1;
        /// memory increment mode Defines the increment mode for each DMA
        /// transfer to the identified memory. In memory-to-memory mode, this
        /// field identifies the memory source if DIRÂ =Â 1 and the memory
        /// destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this
        /// field identifies the peripheral source if DIRÂ =Â 1 and the
        /// peripheral destination if DIRÂ =Â 0. Note: this bit is set and
        /// cleared by software. It must not be written when the channel is
        /// enabled (EN = 1). It is read-only when the channel is enabled (ENÂ
        /// =Â 1).
        DMA1_minc_t minc : 1;
        /// peripheral size Defines the data size of each DMA transfer to the
        /// identified peripheral. In memory-to-memory mode, this field
        /// identifies the memory destination if DIRÂ =Â 1 and the memory source
        /// if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field
        /// identifies the peripheral destination if DIRÂ =Â 1 and the
        /// peripheral source if DIRÂ =Â 0. Note: this field is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_psize_t psize : 2;
        /// memory size Defines the data size of each DMA transfer to the
        /// identified memory. In memory-to-memory mode, this field identifies
        /// the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â
        /// 0. In peripheral-to-peripheral mode, this field identifies the
        /// peripheral source if DIRÂ =Â 1 and the peripheral destination if
        /// DIRÂ =Â 0. Note: this field is set and cleared by software. It must
        /// not be written when the channel is enabled (EN = 1). It is read-only
        /// when the channel is enabled (ENÂ =Â 1).
        DMA1_msize_t msize : 2;
        /// priority level Note: this field is set and cleared by software. It
        /// must not be written when the channel is enabled (EN = 1). It is
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_pl_t pl : 2;
        /// memory-to-memory mode Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1). It is
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_mem2mem_t mem2mem : 1;
    };
    uint32_t bits;
} DMA1_dma_ccr4_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_ccr4_t, sizeof(uint32_t));

/**
 * DMA channel 4 number of data to transfer register
 */
typedef union DMA1_dma_cndtr4_u {
    struct {
        /// number of data to transfer (0 to 216Â -Â 1) This field is updated by
        /// hardware when the channel is enabled: It is decremented after each
        /// single DMA 'read followed by writeâ transfer, indicating the
        /// remaining amount of data items to transfer. It is kept at zero when
        /// the programmed amount of data to transfer is reached, if the channel
        /// is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is
        /// reloaded automatically by the previously programmed value, when the
        /// transfer is complete, if the channel is in circular mode (CIRCÂ =Â
        /// 1). If this field is zero, no transfer can be served whatever the
        /// channel status (enabled or not). Note: this field is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        uint32_t ndt : 16;
    };
    uint32_t bits;
} DMA1_dma_cndtr4_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cndtr4_t, sizeof(uint32_t));

/**
 * DMA channel 4 peripheral address register
 */
typedef union DMA1_dma_cpar4_u {
    struct {
        /// peripheral address It contains the base address of the peripheral
        /// data register from/to which the data will be read/written. When
        /// PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is
        /// automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32
        /// bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically
        /// aligned to a word address. In memory-to-memory mode, this register
        /// identifies the memory destination address if DIRÂ =Â 1 and the
        /// memory source address if DIRÂ =Â 0. In peripheral-to-peripheral
        /// mode, this register identifies the peripheral destination address
        /// DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this
        /// register is set and cleared by software. It must not be written when
        /// the channel is enabled (EN = 1). It is not read-only when the
        /// channel is enabled (ENÂ =Â 1).
        uint32_t pa : 32;
    };
    uint32_t bits;
} DMA1_dma_cpar4_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cpar4_t, sizeof(uint32_t));

/**
 * DMA channel 4 memory address register
 */
typedef union DMA1_dma_cmar4_u {
    struct {
        /// peripheral address It contains the base address of the memory
        /// from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01
        /// (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically
        /// aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1
        /// and 0 of MA[31:0] are ignored. Access is automatically aligned to a
        /// word address. In memory-to-memory mode, this register identifies the
        /// memory source address if DIRÂ =Â 1 and the memory destination
        /// address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this
        /// register identifies the peripheral source address DIRÂ =Â 1 and the
        /// peripheral destination address if DIRÂ =Â 0. Note: this register is
        /// set and cleared by software. It must not be written when the channel
        /// is enabled (EN = 1). It is not read-only when the channel is enabled
        /// (ENÂ =Â 1).
        uint32_t ma : 32;
    };
    uint32_t bits;
} DMA1_dma_cmar4_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cmar4_t, sizeof(uint32_t));

/**
 * DMA channel 5 configuration register
 */
typedef union DMA1_dma_ccr5_u {
    struct {
        /// channel enable When a channel transfer error occurs, this bit is
        /// cleared by hardware. It can not be set again by software (channel x
        /// re-activated) until the TEIFx bit of the DMA_ISR register is cleared
        /// (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit
        /// is set and cleared by software.
        DMA1_en_t en : 1;
        /// transfer complete interrupt enable Note: this bit is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_tcie_t tcie : 1;
        /// half transfer interrupt enable Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_htie_t htie : 1;
        /// transfer error interrupt enable Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_teie_t teie : 1;
        /// data transfer direction This bit must be set only in
        /// memory-to-peripheral and peripheral-to-memory modes. Source
        /// attributes are defined by PSIZE and PINC, plus the DMA_CPARx
        /// register. This is still valid in a memory-to-memory mode.
        /// Destination attributes are defined by MSIZE and MINC, plus the
        /// DMA_CMARx register. This is still valid in a
        /// peripheral-to-peripheral mode. Destination attributes are defined by
        /// PSIZE and PINC, plus the DMA_CPARx register. This is still valid in
        /// a memory-to-memory mode. Source attributes are defined by MSIZE and
        /// MINC, plus the DMA_CMARx register. This is still valid in a
        /// peripheral-to-peripheral mode. Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_dir_t dir : 1;
        /// circular mode Note: this bit is set and cleared by software. It must
        /// not be written when the channel is enabled (EN = 1). It is not
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_circ_t circ : 1;
        /// peripheral increment mode Defines the increment mode for each DMA
        /// transfer to the identified peripheral. n memory-to-memory mode, this
        /// field identifies the memory destination if DIRÂ =Â 1 and the memory
        /// source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field
        /// identifies the peripheral destination if DIRÂ =Â 1 and the
        /// peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_pinc_t pinc : 1;
        /// memory increment mode Defines the increment mode for each DMA
        /// transfer to the identified memory. In memory-to-memory mode, this
        /// field identifies the memory source if DIRÂ =Â 1 and the memory
        /// destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this
        /// field identifies the peripheral source if DIRÂ =Â 1 and the
        /// peripheral destination if DIRÂ =Â 0. Note: this bit is set and
        /// cleared by software. It must not be written when the channel is
        /// enabled (EN = 1). It is read-only when the channel is enabled (ENÂ
        /// =Â 1).
        DMA1_minc_t minc : 1;
        /// peripheral size Defines the data size of each DMA transfer to the
        /// identified peripheral. In memory-to-memory mode, this field
        /// identifies the memory destination if DIRÂ =Â 1 and the memory source
        /// if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field
        /// identifies the peripheral destination if DIRÂ =Â 1 and the
        /// peripheral source if DIRÂ =Â 0. Note: this field is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_psize_t psize : 2;
        /// memory size Defines the data size of each DMA transfer to the
        /// identified memory. In memory-to-memory mode, this field identifies
        /// the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â
        /// 0. In peripheral-to-peripheral mode, this field identifies the
        /// peripheral source if DIRÂ =Â 1 and the peripheral destination if
        /// DIRÂ =Â 0. Note: this field is set and cleared by software. It must
        /// not be written when the channel is enabled (EN = 1). It is read-only
        /// when the channel is enabled (ENÂ =Â 1).
        DMA1_msize_t msize : 2;
        /// priority level Note: this field is set and cleared by software. It
        /// must not be written when the channel is enabled (EN = 1). It is
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_pl_t pl : 2;
        /// memory-to-memory mode Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1). It is
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_mem2mem_t mem2mem : 1;
    };
    uint32_t bits;
} DMA1_dma_ccr5_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_ccr5_t, sizeof(uint32_t));

/**
 * DMA channel 5 number of data to transfer register
 */
typedef union DMA1_dma_cndtr5_u {
    struct {
        /// number of data to transfer (0 to 216Â -Â 1) This field is updated by
        /// hardware when the channel is enabled: It is decremented after each
        /// single DMA 'read followed by writeâ transfer, indicating the
        /// remaining amount of data items to transfer. It is kept at zero when
        /// the programmed amount of data to transfer is reached, if the channel
        /// is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is
        /// reloaded automatically by the previously programmed value, when the
        /// transfer is complete, if the channel is in circular mode (CIRCÂ =Â
        /// 1). If this field is zero, no transfer can be served whatever the
        /// channel status (enabled or not). Note: this field is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        uint32_t ndt : 16;
    };
    uint32_t bits;
} DMA1_dma_cndtr5_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cndtr5_t, sizeof(uint32_t));

/**
 * DMA channel 5 peripheral address register
 */
typedef union DMA1_dma_cpar5_u {
    struct {
        /// peripheral address It contains the base address of the peripheral
        /// data register from/to which the data will be read/written. When
        /// PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is
        /// automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32
        /// bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically
        /// aligned to a word address. In memory-to-memory mode, this register
        /// identifies the memory destination address if DIRÂ =Â 1 and the
        /// memory source address if DIRÂ =Â 0. In peripheral-to-peripheral
        /// mode, this register identifies the peripheral destination address
        /// DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this
        /// register is set and cleared by software. It must not be written when
        /// the channel is enabled (EN = 1). It is not read-only when the
        /// channel is enabled (ENÂ =Â 1).
        uint32_t pa : 32;
    };
    uint32_t bits;
} DMA1_dma_cpar5_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cpar5_t, sizeof(uint32_t));

/**
 * DMA channel 5 memory address register
 */
typedef union DMA1_dma_cmar5_u {
    struct {
        /// peripheral address It contains the base address of the memory
        /// from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01
        /// (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically
        /// aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1
        /// and 0 of MA[31:0] are ignored. Access is automatically aligned to a
        /// word address. In memory-to-memory mode, this register identifies the
        /// memory source address if DIRÂ =Â 1 and the memory destination
        /// address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this
        /// register identifies the peripheral source address DIRÂ =Â 1 and the
        /// peripheral destination address if DIRÂ =Â 0. Note: this register is
        /// set and cleared by software. It must not be written when the channel
        /// is enabled (EN = 1). It is not read-only when the channel is enabled
        /// (ENÂ =Â 1).
        uint32_t ma : 32;
    };
    uint32_t bits;
} DMA1_dma_cmar5_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cmar5_t, sizeof(uint32_t));

/**
 * DMA channel 6 configuration register
 */
typedef union DMA1_dma_ccr6_u {
    struct {
        /// channel enable When a channel transfer error occurs, this bit is
        /// cleared by hardware. It can not be set again by software (channel x
        /// re-activated) until the TEIFx bit of the DMA_ISR register is cleared
        /// (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit
        /// is set and cleared by software.
        DMA1_en_t en : 1;
        /// transfer complete interrupt enable Note: this bit is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_tcie_t tcie : 1;
        /// half transfer interrupt enable Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_htie_t htie : 1;
        /// transfer error interrupt enable Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_teie_t teie : 1;
        /// data transfer direction This bit must be set only in
        /// memory-to-peripheral and peripheral-to-memory modes. Source
        /// attributes are defined by PSIZE and PINC, plus the DMA_CPARx
        /// register. This is still valid in a memory-to-memory mode.
        /// Destination attributes are defined by MSIZE and MINC, plus the
        /// DMA_CMARx register. This is still valid in a
        /// peripheral-to-peripheral mode. Destination attributes are defined by
        /// PSIZE and PINC, plus the DMA_CPARx register. This is still valid in
        /// a memory-to-memory mode. Source attributes are defined by MSIZE and
        /// MINC, plus the DMA_CMARx register. This is still valid in a
        /// peripheral-to-peripheral mode. Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_dir_t dir : 1;
        /// circular mode Note: this bit is set and cleared by software. It must
        /// not be written when the channel is enabled (EN = 1). It is not
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_circ_t circ : 1;
        /// peripheral increment mode Defines the increment mode for each DMA
        /// transfer to the identified peripheral. n memory-to-memory mode, this
        /// field identifies the memory destination if DIRÂ =Â 1 and the memory
        /// source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field
        /// identifies the peripheral destination if DIRÂ =Â 1 and the
        /// peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_pinc_t pinc : 1;
        /// memory increment mode Defines the increment mode for each DMA
        /// transfer to the identified memory. In memory-to-memory mode, this
        /// field identifies the memory source if DIRÂ =Â 1 and the memory
        /// destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this
        /// field identifies the peripheral source if DIRÂ =Â 1 and the
        /// peripheral destination if DIRÂ =Â 0. Note: this bit is set and
        /// cleared by software. It must not be written when the channel is
        /// enabled (EN = 1). It is read-only when the channel is enabled (ENÂ
        /// =Â 1).
        DMA1_minc_t minc : 1;
        /// peripheral size Defines the data size of each DMA transfer to the
        /// identified peripheral. In memory-to-memory mode, this field
        /// identifies the memory destination if DIRÂ =Â 1 and the memory source
        /// if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field
        /// identifies the peripheral destination if DIRÂ =Â 1 and the
        /// peripheral source if DIRÂ =Â 0. Note: this field is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_psize_t psize : 2;
        /// memory size Defines the data size of each DMA transfer to the
        /// identified memory. In memory-to-memory mode, this field identifies
        /// the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â
        /// 0. In peripheral-to-peripheral mode, this field identifies the
        /// peripheral source if DIRÂ =Â 1 and the peripheral destination if
        /// DIRÂ =Â 0. Note: this field is set and cleared by software. It must
        /// not be written when the channel is enabled (EN = 1). It is read-only
        /// when the channel is enabled (ENÂ =Â 1).
        DMA1_msize_t msize : 2;
        /// priority level Note: this field is set and cleared by software. It
        /// must not be written when the channel is enabled (EN = 1). It is
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_pl_t pl : 2;
        /// memory-to-memory mode Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1). It is
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_mem2mem_t mem2mem : 1;
    };
    uint32_t bits;
} DMA1_dma_ccr6_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_ccr6_t, sizeof(uint32_t));

/**
 * DMA channel 6 number of data to transfer register
 */
typedef union DMA1_dma_cndtr6_u {
    struct {
        /// number of data to transfer (0 to 216Â -Â 1) This field is updated by
        /// hardware when the channel is enabled: It is decremented after each
        /// single DMA 'read followed by writeâ transfer, indicating the
        /// remaining amount of data items to transfer. It is kept at zero when
        /// the programmed amount of data to transfer is reached, if the channel
        /// is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is
        /// reloaded automatically by the previously programmed value, when the
        /// transfer is complete, if the channel is in circular mode (CIRCÂ =Â
        /// 1). If this field is zero, no transfer can be served whatever the
        /// channel status (enabled or not). Note: this field is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        uint32_t ndt : 16;
    };
    uint32_t bits;
} DMA1_dma_cndtr6_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cndtr6_t, sizeof(uint32_t));

/**
 * DMA channel 6 peripheral address register
 */
typedef union DMA1_dma_cpar6_u {
    struct {
        /// peripheral address It contains the base address of the peripheral
        /// data register from/to which the data will be read/written. When
        /// PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is
        /// automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32
        /// bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically
        /// aligned to a word address. In memory-to-memory mode, this register
        /// identifies the memory destination address if DIRÂ =Â 1 and the
        /// memory source address if DIRÂ =Â 0. In peripheral-to-peripheral
        /// mode, this register identifies the peripheral destination address
        /// DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this
        /// register is set and cleared by software. It must not be written when
        /// the channel is enabled (EN = 1). It is not read-only when the
        /// channel is enabled (ENÂ =Â 1).
        uint32_t pa : 32;
    };
    uint32_t bits;
} DMA1_dma_cpar6_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cpar6_t, sizeof(uint32_t));

/**
 * DMA channel 6 memory address register
 */
typedef union DMA1_dma_cmar6_u {
    struct {
        /// peripheral address It contains the base address of the memory
        /// from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01
        /// (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically
        /// aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1
        /// and 0 of MA[31:0] are ignored. Access is automatically aligned to a
        /// word address. In memory-to-memory mode, this register identifies the
        /// memory source address if DIRÂ =Â 1 and the memory destination
        /// address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this
        /// register identifies the peripheral source address DIRÂ =Â 1 and the
        /// peripheral destination address if DIRÂ =Â 0. Note: this register is
        /// set and cleared by software. It must not be written when the channel
        /// is enabled (EN = 1). It is not read-only when the channel is enabled
        /// (ENÂ =Â 1).
        uint32_t ma : 32;
    };
    uint32_t bits;
} DMA1_dma_cmar6_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cmar6_t, sizeof(uint32_t));

/**
 * DMA channel 7 configuration register
 */
typedef union DMA1_dma_ccr7_u {
    struct {
        /// channel enable When a channel transfer error occurs, this bit is
        /// cleared by hardware. It can not be set again by software (channel x
        /// re-activated) until the TEIFx bit of the DMA_ISR register is cleared
        /// (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit
        /// is set and cleared by software.
        DMA1_en_t en : 1;
        /// transfer complete interrupt enable Note: this bit is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_tcie_t tcie : 1;
        /// half transfer interrupt enable Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_htie_t htie : 1;
        /// transfer error interrupt enable Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_teie_t teie : 1;
        /// data transfer direction This bit must be set only in
        /// memory-to-peripheral and peripheral-to-memory modes. Source
        /// attributes are defined by PSIZE and PINC, plus the DMA_CPARx
        /// register. This is still valid in a memory-to-memory mode.
        /// Destination attributes are defined by MSIZE and MINC, plus the
        /// DMA_CMARx register. This is still valid in a
        /// peripheral-to-peripheral mode. Destination attributes are defined by
        /// PSIZE and PINC, plus the DMA_CPARx register. This is still valid in
        /// a memory-to-memory mode. Source attributes are defined by MSIZE and
        /// MINC, plus the DMA_CMARx register. This is still valid in a
        /// peripheral-to-peripheral mode. Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_dir_t dir : 1;
        /// circular mode Note: this bit is set and cleared by software. It must
        /// not be written when the channel is enabled (EN = 1). It is not
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_circ_t circ : 1;
        /// peripheral increment mode Defines the increment mode for each DMA
        /// transfer to the identified peripheral. n memory-to-memory mode, this
        /// field identifies the memory destination if DIRÂ =Â 1 and the memory
        /// source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field
        /// identifies the peripheral destination if DIRÂ =Â 1 and the
        /// peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by
        /// software. It must not be written when the channel is enabled (EN =
        /// 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_pinc_t pinc : 1;
        /// memory increment mode Defines the increment mode for each DMA
        /// transfer to the identified memory. In memory-to-memory mode, this
        /// field identifies the memory source if DIRÂ =Â 1 and the memory
        /// destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this
        /// field identifies the peripheral source if DIRÂ =Â 1 and the
        /// peripheral destination if DIRÂ =Â 0. Note: this bit is set and
        /// cleared by software. It must not be written when the channel is
        /// enabled (EN = 1). It is read-only when the channel is enabled (ENÂ
        /// =Â 1).
        DMA1_minc_t minc : 1;
        /// peripheral size Defines the data size of each DMA transfer to the
        /// identified peripheral. In memory-to-memory mode, this field
        /// identifies the memory destination if DIRÂ =Â 1 and the memory source
        /// if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field
        /// identifies the peripheral destination if DIRÂ =Â 1 and the
        /// peripheral source if DIRÂ =Â 0. Note: this field is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_psize_t psize : 2;
        /// memory size Defines the data size of each DMA transfer to the
        /// identified memory. In memory-to-memory mode, this field identifies
        /// the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â
        /// 0. In peripheral-to-peripheral mode, this field identifies the
        /// peripheral source if DIRÂ =Â 1 and the peripheral destination if
        /// DIRÂ =Â 0. Note: this field is set and cleared by software. It must
        /// not be written when the channel is enabled (EN = 1). It is read-only
        /// when the channel is enabled (ENÂ =Â 1).
        DMA1_msize_t msize : 2;
        /// priority level Note: this field is set and cleared by software. It
        /// must not be written when the channel is enabled (EN = 1). It is
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_pl_t pl : 2;
        /// memory-to-memory mode Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1). It is
        /// read-only when the channel is enabled (ENÂ =Â 1).
        DMA1_mem2mem_t mem2mem : 1;
    };
    uint32_t bits;
} DMA1_dma_ccr7_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_ccr7_t, sizeof(uint32_t));

/**
 * DMA channel 7 number of data to transfer register
 */
typedef union DMA1_dma_cndtr7_u {
    struct {
        /// number of data to transfer (0 to 216Â -Â 1) This field is updated by
        /// hardware when the channel is enabled: It is decremented after each
        /// single DMA 'read followed by writeâ transfer, indicating the
        /// remaining amount of data items to transfer. It is kept at zero when
        /// the programmed amount of data to transfer is reached, if the channel
        /// is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is
        /// reloaded automatically by the previously programmed value, when the
        /// transfer is complete, if the channel is in circular mode (CIRCÂ =Â
        /// 1). If this field is zero, no transfer can be served whatever the
        /// channel status (enabled or not). Note: this field is set and cleared
        /// by software. It must not be written when the channel is enabled (EN
        /// = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
        uint32_t ndt : 16;
    };
    uint32_t bits;
} DMA1_dma_cndtr7_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cndtr7_t, sizeof(uint32_t));

/**
 * DMA channel 7 peripheral address register
 */
typedef union DMA1_dma_cpar7_u {
    struct {
        /// peripheral address It contains the base address of the peripheral
        /// data register from/to which the data will be read/written. When
        /// PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is
        /// automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32
        /// bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically
        /// aligned to a word address. In memory-to-memory mode, this register
        /// identifies the memory destination address if DIRÂ =Â 1 and the
        /// memory source address if DIRÂ =Â 0. In peripheral-to-peripheral
        /// mode, this register identifies the peripheral destination address
        /// DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this
        /// register is set and cleared by software. It must not be written when
        /// the channel is enabled (EN = 1). It is not read-only when the
        /// channel is enabled (ENÂ =Â 1).
        uint32_t pa : 32;
    };
    uint32_t bits;
} DMA1_dma_cpar7_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cpar7_t, sizeof(uint32_t));

/**
 * DMA channel 7 memory address register
 */
typedef union DMA1_dma_cmar7_u {
    struct {
        /// peripheral address It contains the base address of the memory
        /// from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01
        /// (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically
        /// aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1
        /// and 0 of MA[31:0] are ignored. Access is automatically aligned to a
        /// word address. In memory-to-memory mode, this register identifies the
        /// memory source address if DIRÂ =Â 1 and the memory destination
        /// address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this
        /// register identifies the peripheral source address DIRÂ =Â 1 and the
        /// peripheral destination address if DIRÂ =Â 0. Note: this register is
        /// set and cleared by software. It must not be written when the channel
        /// is enabled (EN = 1). It is not read-only when the channel is enabled
        /// (ENÂ =Â 1).
        uint32_t ma : 32;
    };
    uint32_t bits;
} DMA1_dma_cmar7_t;
STATIC_ASSERT_TYPE_SIZE(DMA1_dma_cmar7_t, sizeof(uint32_t));

/**
 * Direct memory access controller
 */
typedef struct DMA1_peripheral_registers_s {
    /// DMA interrupt status register
    DMA1_dma_isr_t dma_isr;
    /// DMA interrupt flag clear register
    DMA1_dma_ifcr_t dma_ifcr;
    /// DMA channel 1 configuration register
    DMA1_dma_ccr1_t dma_ccr1;
    /// DMA channel 1 number of data to transfer register
    DMA1_dma_cndtr1_t dma_cndtr1;
    /// DMA channel 1 peripheral address register
    DMA1_dma_cpar1_t dma_cpar1;
    /// DMA channel 1 memory address register
    DMA1_dma_cmar1_t dma_cmar1;
    uint8_t const    reserved_0x18[4];
    /// DMA channel 2 configuration register
    DMA1_dma_ccr2_t dma_ccr2;
    /// DMA channel 2 number of data to transfer register
    DMA1_dma_cndtr2_t dma_cndtr2;
    /// DMA channel 2 peripheral address register
    DMA1_dma_cpar2_t dma_cpar2;
    /// DMA channel 2 memory address register
    DMA1_dma_cmar2_t dma_cmar2;
    uint8_t const    reserved_0x2C[4];
    /// DMA channel 3 configuration register
    DMA1_dma_ccr3_t dma_ccr3;
    /// DMA channel 3 number of data to transfer register
    DMA1_dma_cndtr3_t dma_cndtr3;
    /// DMA channel 3 peripheral address register
    DMA1_dma_cpar3_t dma_cpar3;
    /// DMA channel 3 memory address register
    DMA1_dma_cmar3_t dma_cmar3;
    uint8_t const    reserved_0x40[4];
    /// DMA channel 4 configuration register
    DMA1_dma_ccr4_t dma_ccr4;
    /// DMA channel 4 number of data to transfer register
    DMA1_dma_cndtr4_t dma_cndtr4;
    /// DMA channel 4 peripheral address register
    DMA1_dma_cpar4_t dma_cpar4;
    /// DMA channel 4 memory address register
    DMA1_dma_cmar4_t dma_cmar4;
    uint8_t const    reserved_0x54[4];
    /// DMA channel 5 configuration register
    DMA1_dma_ccr5_t dma_ccr5;
    /// DMA channel 5 number of data to transfer register
    DMA1_dma_cndtr5_t dma_cndtr5;
    /// DMA channel 5 peripheral address register
    DMA1_dma_cpar5_t dma_cpar5;
    /// DMA channel 5 memory address register
    DMA1_dma_cmar5_t dma_cmar5;
    uint8_t const    reserved_0x68[4];
    /// DMA channel 6 configuration register
    DMA1_dma_ccr6_t dma_ccr6;
    /// DMA channel 6 number of data to transfer register
    DMA1_dma_cndtr6_t dma_cndtr6;
    /// DMA channel 6 peripheral address register
    DMA1_dma_cpar6_t dma_cpar6;
    /// DMA channel 6 memory address register
    DMA1_dma_cmar6_t dma_cmar6;
    uint8_t const    reserved_0x7C[4];
    /// DMA channel 7 configuration register
    DMA1_dma_ccr7_t dma_ccr7;
    /// DMA channel 7 number of data to transfer register
    DMA1_dma_cndtr7_t dma_cndtr7;
    /// DMA channel 7 peripheral address register
    DMA1_dma_cpar7_t dma_cpar7;
    /// DMA channel 7 memory address register
    DMA1_dma_cmar7_t dma_cmar7;
} DMA1_peripheral_registers_t;
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_isr, 0x00);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_ifcr, 0x04);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_ccr1, 0x08);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cndtr1, 0x0C);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cpar1, 0x10);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cmar1, 0x14);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_ccr2, 0x1C);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cndtr2, 0x20);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cpar2, 0x24);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cmar2, 0x28);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_ccr3, 0x30);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cndtr3, 0x34);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cpar3, 0x38);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cmar3, 0x3C);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_ccr4, 0x44);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cndtr4, 0x48);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cpar4, 0x4C);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cmar4, 0x50);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_ccr5, 0x58);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cndtr5, 0x5C);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cpar5, 0x60);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cmar5, 0x64);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_ccr6, 0x6C);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cndtr6, 0x70);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cpar6, 0x74);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cmar6, 0x78);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_ccr7, 0x80);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cndtr7, 0x84);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cpar7, 0x88);
STATIC_ASSERT_MEMBER_OFFSET(DMA1_peripheral_registers_t, dma_cmar7, 0x8C);

#ifdef __cplusplus
}
#endif
#endif // DMA1_H_

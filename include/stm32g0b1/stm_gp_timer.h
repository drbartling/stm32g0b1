/**
 * @file
 * @version 1.6
 * @brief Register access structs for STM TIM2
 *
 * General-purpose-timers
 *
 * @note This file is autogenerated using register-code-gen
 */

#ifndef TIM2_H_
#define TIM2_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "static_assert.h"

#include <stdint.h>

/**
 * Counter enable Note: External clock, gated mode and encoder mode can work
 * only if the CEN bit has been previously set by software. However trigger mode
 * can set the CEN bit automatically by hardware. CEN is cleared automatically
 * in one-pulse mode, when an update event occurs.
 */
typedef enum TIM2_cen_e {
    /// Counter disabled
    TIM2_cen_b_0x0 = 0x0,
    /// Counter enabled
    TIM2_cen_b_0x1 = 0x1,
} TIM2_cen_t;

/**
 * Update disable This bit is set and cleared by software to enable/disable UEV
 * event generation. Counter overflow/underflow Setting the UG bit Update
 * generation through the slave mode controller Buffered registers are then
 * loaded with their preload values.
 */
typedef enum TIM2_udis_e {
    /// UEV enabled. The Update (UEV) event is generated by one of the following
    /// events:
    TIM2_udis_b_0x0 = 0x0,
    /// UEV disabled. The Update event is not generated, shadow registers keep
    /// their value (ARR, PSC, CCRx). However the counter and the prescaler are
    /// reinitialized if the UG bit is set or if a hardware reset is received
    /// from the slave mode controller.
    TIM2_udis_b_0x1 = 0x1,
} TIM2_udis_t;

/**
 * Update request source This bit is set and cleared by software to select the
 * UEV event sources. Counter overflow/underflow Setting the UG bit Update
 * generation through the slave mode controller
 */
typedef enum TIM2_urs_e {
    /// Any of the following events generate an update interrupt or DMA request
    /// if enabled. These events can be:
    TIM2_urs_b_0x0 = 0x0,
    /// Only counter overflow/underflow generates an update interrupt or DMA
    /// request if enabled.
    TIM2_urs_b_0x1 = 0x1,
} TIM2_urs_t;

/**
 * One-pulse mode
 */
typedef enum TIM2_opm_e {
    /// Counter is not stopped at update event
    TIM2_opm_b_0x0 = 0x0,
    /// Counter stops counting at the next update event (clearing the bit CEN)
    TIM2_opm_b_0x1 = 0x1,
} TIM2_opm_t;

/**
 * Direction Note: This bit is read only when the timer is configured in
 * Center-aligned mode or Encoder mode.
 */
typedef enum TIM2_dir_e {
    /// Counter used as upcounter
    TIM2_dir_b_0x0 = 0x0,
    /// Counter used as downcounter
    TIM2_dir_b_0x1 = 0x1,
} TIM2_dir_t;

/**
 * Center-aligned mode selection Note: It is not allowed to switch from
 * edge-aligned mode to center-aligned mode as long as the counter is enabled
 * (CEN=1)
 */
typedef enum TIM2_cms_e {
    /// Edge-aligned mode. The counter counts up or down depending on the
    /// direction bit (DIR).
    TIM2_cms_b_0x0 = 0x0,
    /// Center-aligned mode 1. The counter counts up and down alternatively.
    /// Output compare interrupt flags of channels configured in output (CCxS=00
    /// in TIMx_CCMRx register) are set only when the counter is counting down.
    TIM2_cms_b_0x1 = 0x1,
    /// Center-aligned mode 2. The counter counts up and down alternatively.
    /// Output compare interrupt flags of channels configured in output (CCxS=00
    /// in TIMx_CCMRx register) are set only when the counter is counting up.
    TIM2_cms_b_0x2 = 0x2,
    /// Center-aligned mode 3. The counter counts up and down alternatively.
    /// Output compare interrupt flags of channels configured in output (CCxS=00
    /// in TIMx_CCMRx register) are set both when the counter is counting up or
    /// down.
    TIM2_cms_b_0x3 = 0x3,
} TIM2_cms_t;

/**
 * Auto-reload preload enable
 */
typedef enum TIM2_arpe_e {
    /// TIMx_ARR register is not buffered
    TIM2_arpe_b_0x0 = 0x0,
    /// TIMx_ARR register is buffered
    TIM2_arpe_b_0x1 = 0x1,
} TIM2_arpe_t;

/**
 * Clock division This bit-field indicates the division ratio between the timer
 * clock (CK_INT) frequency and sampling clock used by the digital filters (ETR,
 * TIx),
 */
typedef enum TIM2_ckd_e {
    /// tDTS = tCK_INT
    TIM2_ckd_b_0x0 = 0x0,
    /// tDTS = 2 Ã tCK_INT
    TIM2_ckd_b_0x1 = 0x1,
    /// tDTS = 4 Ã tCK_INT
    TIM2_ckd_b_0x2 = 0x2,
} TIM2_ckd_t;

/**
 * UIF status bit remapping
 */
typedef enum TIM2_uifremap_e {
    /// No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.
    TIM2_uifremap_b_0x0 = 0x0,
    /// Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.
    TIM2_uifremap_b_0x1 = 0x1,
} TIM2_uifremap_t;

/**
 * control register 1
 */
typedef union TIM2_cr1_u {
    struct {
        /// Counter enable Note: External clock, gated mode and encoder mode can
        /// work only if the CEN bit has been previously set by software.
        /// However trigger mode can set the CEN bit automatically by hardware.
        /// CEN is cleared automatically in one-pulse mode, when an update event
        /// occurs.
        TIM2_cen_t cen : 1;
        /// Update disable This bit is set and cleared by software to
        /// enable/disable UEV event generation. Counter overflow/underflow
        /// Setting the UG bit Update generation through the slave mode
        /// controller Buffered registers are then loaded with their preload
        /// values.
        TIM2_udis_t udis : 1;
        /// Update request source This bit is set and cleared by software to
        /// select the UEV event sources. Counter overflow/underflow Setting the
        /// UG bit Update generation through the slave mode controller
        TIM2_urs_t urs : 1;
        /// One-pulse mode
        TIM2_opm_t opm : 1;
        /// Direction Note: This bit is read only when the timer is configured
        /// in Center-aligned mode or Encoder mode.
        TIM2_dir_t dir : 1;
        /// Center-aligned mode selection Note: It is not allowed to switch from
        /// edge-aligned mode to center-aligned mode as long as the counter is
        /// enabled (CEN=1)
        TIM2_cms_t cms : 2;
        /// Auto-reload preload enable
        TIM2_arpe_t arpe : 1;
        /// Clock division This bit-field indicates the division ratio between
        /// the timer clock (CK_INT) frequency and sampling clock used by the
        /// digital filters (ETR, TIx),
        TIM2_ckd_t     ckd : 2;
        uint32_t const reserved_10 : 1;
        /// UIF status bit remapping
        TIM2_uifremap_t uifremap : 1;
    };
    uint32_t bits;
} TIM2_cr1_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_cr1_t, sizeof(uint32_t));

/**
 * Capture/compare DMA selection
 */
typedef enum TIM2_ccds_e {
    /// CCx DMA request sent when CCx event occurs
    TIM2_ccds_b_0x0 = 0x0,
    /// CCx DMA requests sent when update event occurs
    TIM2_ccds_b_0x1 = 0x1,
} TIM2_ccds_t;

/**
 * Master mode selection These bits permit to select the information to be sent
 * in master mode to slave timers for synchronization (TRGO). The combination is
 * as follows: When the Counter Enable signal is controlled by the trigger
 * input, there is a delay on TRGO, except if the master/slave mode is selected
 * (see the MSM bit description in TIMx_SMCR register). Note: The clock of the
 * slave timer or ADC must be enabled prior to receive events from the master
 * timer, and must not be changed on-the-fly while triggers are received from
 * the master timer.
 */
typedef enum TIM2_mms_e {
    /// Reset - the UG bit from the TIMx_EGR register is used as trigger output
    /// (TRGO). If the reset is generated by the trigger input (slave mode
    /// controller configured in reset mode) then the signal on TRGO is delayed
    /// compared to the actual reset.
    TIM2_mms_b_0x0 = 0x0,
    /// Enable - the Counter enable signal, CNT_EN, is used as trigger output
    /// (TRGO). It is useful to start several timers at the same time or to
    /// control a window in which a slave timer is enabled. The Counter Enable
    /// signal is generated by a logic AND between CEN control bit and the
    /// trigger input when configured in gated mode.
    TIM2_mms_b_0x1 = 0x1,
    /// Update - The update event is selected as trigger output (TRGO). For
    /// instance a master timer can then be used as a prescaler for a slave
    /// timer.
    TIM2_mms_b_0x2 = 0x2,
    /// Compare Pulse - The trigger output send a positive pulse when the CC1IF
    /// flag is to be set (even if it was already high), as soon as a capture or
    /// a compare match occurred. (TRGO)
    TIM2_mms_b_0x3 = 0x3,
    /// Compare - OC1REFC signal is used as trigger output (TRGO)
    TIM2_mms_b_0x4 = 0x4,
    /// Compare - OC2REFC signal is used as trigger output (TRGO)
    TIM2_mms_b_0x5 = 0x5,
    /// Compare - OC3REFC signal is used as trigger output (TRGO)
    TIM2_mms_b_0x6 = 0x6,
    /// Compare - OC4REFC signal is used as trigger output (TRGO)
    TIM2_mms_b_0x7 = 0x7,
} TIM2_mms_t;

/**
 * TI1 selection
 */
typedef enum TIM2_ti1s_e {
    /// The TIMx_CH1 pin is connected to TI1 input
    TIM2_ti1s_b_0x0 = 0x0,
    /// The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR
    /// combination) See also
    TIM2_ti1s_b_0x1 = 0x1,
} TIM2_ti1s_t;

/**
 * control register 2
 */
typedef union TIM2_cr2_u {
    struct {
        uint32_t const reserved_00 : 3;
        /// Capture/compare DMA selection
        TIM2_ccds_t ccds : 1;
        /// Master mode selection These bits permit to select the information to
        /// be sent in master mode to slave timers for synchronization (TRGO).
        /// The combination is as follows: When the Counter Enable signal is
        /// controlled by the trigger input, there is a delay on TRGO, except if
        /// the master/slave mode is selected (see the MSM bit description in
        /// TIMx_SMCR register). Note: The clock of the slave timer or ADC must
        /// be enabled prior to receive events from the master timer, and must
        /// not be changed on-the-fly while triggers are received from the
        /// master timer.
        TIM2_mms_t mms : 3;
        /// TI1 selection
        TIM2_ti1s_t ti1s : 1;
    };
    uint32_t bits;
} TIM2_cr2_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_cr2_t, sizeof(uint32_t));

/**
 * Slave mode selection When external signals are selected the active edge of
 * the trigger signal (TRGI) is linked to the polarity selected on the external
 * input (see Input Control register and Control Register description.
 * reinitializes the counter, generates an update of the registers and starts
 * the counter. Note: The gated mode must not be used if TI1F_ED is selected as
 * the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each
 * transition on TI1F, whereas the gated mode checks the level of the trigger
 * signal. Note: The clock of the slave peripherals (timer, ADC, ...) receiving
 * the TRGO or the TRGO2 signals must be enabled prior to receive events from
 * the master timer, and the clock frequency (prescaler) must not be changed
 * on-the-fly while triggers are received from the master timer.
 */
typedef enum TIM2_sms1_e {
    /// Slave mode disabled - if CEN = '1 then the prescaler is clocked directly
    /// by the internal clock.
    TIM2_sms1_b_0x0 = 0x0,
    /// Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on
    /// TI2FP2 level.
    TIM2_sms1_b_0x1 = 0x1,
    /// Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on
    /// TI1FP1 level.
    TIM2_sms1_b_0x2 = 0x2,
    /// Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges
    /// depending on the level of the other input.
    TIM2_sms1_b_0x3 = 0x3,
    /// Reset Mode - Rising edge of the selected trigger input (TRGI)
    /// reinitializes the counter and generates an update of the registers.
    TIM2_sms1_b_0x4 = 0x4,
    /// Gated Mode - The counter clock is enabled when the trigger input (TRGI)
    /// is high. The counter stops (but is not reset) as soon as the trigger
    /// becomes low. Both start and stop of the counter are controlled.
    TIM2_sms1_b_0x5 = 0x5,
    /// Trigger Mode - The counter starts at a rising edge of the trigger TRGI
    /// (but it is not reset). Only the start of the counter is controlled.
    TIM2_sms1_b_0x6 = 0x6,
    /// External Clock Mode 1 - Rising edges of the selected trigger (TRGI)
    /// clock the counter.
    TIM2_sms1_b_0x7 = 0x7,
    /// Combined reset + trigger mode - Rising edge of the selected trigger
    /// input (TRGI)
    TIM2_sms1_b_0x8 = 0x8,
} TIM2_sms1_t;

/**
 * OCREF clear selection This bit is used to select the OCREF clear source
 */
typedef enum TIM2_occs_e {
    /// OCREF_CLR_INT is connected to COMP1 or COMP2 output depending on
    /// TIMx_OR1.OCREF_CLR
    TIM2_occs_b_0x0 = 0x0,
    /// OCREF_CLR_INT is connected to ETRF
    TIM2_occs_b_0x1 = 0x1,
} TIM2_occs_t;

/**
 * Trigger selection This bit-field selects the trigger input to be used to
 * synchronize the counter. Others: Reserved See for more details on ITRx
 * meaning for each Timer. Note: These bits must be changed only when they are
 * not used (e.g. when SMS=000) to avoid wrong edge detections at the
 * transition.
 */
typedef enum TIM2_ts1_e {
    /// Internal Trigger 0 (ITR0)
    TIM2_ts1_b_0x0 = 0x0,
    /// Internal Trigger 1 (ITR1)
    TIM2_ts1_b_0x1 = 0x1,
    /// Internal Trigger 2 (ITR2)
    TIM2_ts1_b_0x2 = 0x2,
    /// Internal Trigger 3 (ITR3)
    TIM2_ts1_b_0x3 = 0x3,
    /// TI1 Edge Detector (TI1F_ED)
    TIM2_ts1_b_0x4 = 0x4,
    /// Filtered Timer Input 1 (TI1FP1)
    TIM2_ts1_b_0x5 = 0x5,
    /// Filtered Timer Input 2 (TI2FP2)
    TIM2_ts1_b_0x6 = 0x6,
    /// External Trigger input (ETRF)
    TIM2_ts1_b_0x7 = 0x7,
    /// Internal Trigger 4 (ITR4)
    TIM2_ts1_b_0x8 = 0x8,
    /// Internal Trigger 5 (ITR5)
    TIM2_ts1_b_0x9 = 0x9,
    /// Internal Trigger 6 (ITR6)
    TIM2_ts1_b_0xa = 0xA,
    /// Internal Trigger 7 (ITR7)
    TIM2_ts1_b_0xb = 0xB,
    /// Internal Trigger 8 (ITR8)
    TIM2_ts1_b_0xc = 0xC,
} TIM2_ts1_t;

/**
 * Master/Slave mode
 */
typedef enum TIM2_msm_e {
    /// No action
    TIM2_msm_b_0x0 = 0x0,
    /// The effect of an event on the trigger input (TRGI) is delayed to allow a
    /// perfect synchronization between the current timer and its slaves
    /// (through TRGO). It is useful if we want to synchronize several timers on
    /// a single external event.
    TIM2_msm_b_0x1 = 0x1,
} TIM2_msm_t;

/**
 * External trigger filter This bit-field then defines the frequency used to
 * sample ETRP signal and the length of the digital filter applied to ETRP. The
 * digital filter is made of an event counter in which N consecutive events are
 * needed to validate a transition on the output:
 */
typedef enum TIM2_etf_e {
    /// No filter, sampling is done at fDTS
    TIM2_etf_b_0x0 = 0x00,
    /// fSAMPLING=fCK_INT, N=2
    TIM2_etf_b_0x1 = 0x01,
    /// fSAMPLING=fCK_INT, N=4
    TIM2_etf_b_0x2 = 0x02,
    /// fSAMPLING=fCK_INT, N=8
    TIM2_etf_b_0x3 = 0x03,
    /// fSAMPLING=fDTS/2, N=6
    TIM2_etf_b_0x4 = 0x04,
    /// fSAMPLING=fDTS/2, N=8
    TIM2_etf_b_0x5 = 0x05,
    /// fSAMPLING=fDTS/4, N=6
    TIM2_etf_b_0x6 = 0x06,
    /// fSAMPLING=fDTS/4, N=8
    TIM2_etf_b_0x7 = 0x07,
    /// fSAMPLING=fDTS/8, N=6
    TIM2_etf_b_0x8 = 0x08,
    /// fSAMPLING=fDTS/8, N=8
    TIM2_etf_b_0x9 = 0x09,
    /// fSAMPLING=fDTS/16, N=5
    TIM2_etf_b_0xa = 0x0A,
    /// fSAMPLING=fDTS/16, N=6
    TIM2_etf_b_0xb = 0x0B,
    /// fSAMPLING=fDTS/16, N=8
    TIM2_etf_b_0xc = 0x0C,
    /// fSAMPLING=fDTS/32, N=5
    TIM2_etf_b_0xd = 0x0D,
    /// fSAMPLING=fDTS/32, N=6
    TIM2_etf_b_0xe = 0x0E,
    /// fSAMPLING=fDTS/32, N=8
    TIM2_etf_b_0xf = 0x0F,
} TIM2_etf_t;

/**
 * External trigger prescaler External trigger signal ETRP frequency must be at
 * most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP
 * frequency. It is useful when inputting fast external clocks.
 */
typedef enum TIM2_etps_e {
    /// Prescaler OFF
    TIM2_etps_b_0x0 = 0x0,
    /// ETRP frequency divided by 2
    TIM2_etps_b_0x1 = 0x1,
    /// ETRP frequency divided by 4
    TIM2_etps_b_0x2 = 0x2,
    /// ETRP frequency divided by 8
    TIM2_etps_b_0x3 = 0x3,
} TIM2_etps_t;

/**
 * External clock enable This bit enables External clock mode 2. Note: Setting
 * the ECE bit has the same effect as selecting external clock mode 1 with TRGI
 * connected to ETRF (SMS=111 and TS=00111). It is possible to simultaneously
 * use external clock mode 2 with the following slave modes: reset mode, gated
 * mode and trigger mode. Nevertheless, TRGI must not be connected to ETRF in
 * this case (TS bits must not be 00111). If external clock mode 1 and external
 * clock mode 2 are enabled at the same time, the external clock input is ETRF.
 */
typedef enum TIM2_ece_e {
    /// External clock mode 2 disabled
    TIM2_ece_b_0x0 = 0x0,
    /// External clock mode 2 enabled. The counter is clocked by any active edge
    /// on the ETRF signal.
    TIM2_ece_b_0x1 = 0x1,
} TIM2_ece_t;

/**
 * External trigger polarity This bit selects whether ETR or ETR is used for
 * trigger operations
 */
typedef enum TIM2_etp_e {
    /// ETR is non-inverted, active at high level or rising edge
    TIM2_etp_b_0x0 = 0x0,
    /// ETR is inverted, active at low level or falling edge
    TIM2_etp_b_0x1 = 0x1,
} TIM2_etp_t;

/**
 * Slave mode selection When external signals are selected the active edge of
 * the trigger signal (TRGI) is linked to the polarity selected on the external
 * input (see Input Control register and Control Register description.
 * reinitializes the counter, generates an update of the registers and starts
 * the counter. Note: The gated mode must not be used if TI1F_ED is selected as
 * the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each
 * transition on TI1F, whereas the gated mode checks the level of the trigger
 * signal. Note: The clock of the slave peripherals (timer, ADC, ...) receiving
 * the TRGO or the TRGO2 signals must be enabled prior to receive events from
 * the master timer, and the clock frequency (prescaler) must not be changed
 * on-the-fly while triggers are received from the master timer.
 */
typedef enum TIM2_sms2_e {
    /// Slave mode disabled - if CEN = '1 then the prescaler is clocked directly
    /// by the internal clock.
    TIM2_sms2_b_0x0 = 0x0,
    /// Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on
    /// TI2FP2 level.
    TIM2_sms2_b_0x1 = 0x1,
    /// Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on
    /// TI1FP1 level.
    TIM2_sms2_b_0x2 = 0x2,
    /// Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges
    /// depending on the level of the other input.
    TIM2_sms2_b_0x3 = 0x3,
    /// Reset Mode - Rising edge of the selected trigger input (TRGI)
    /// reinitializes the counter and generates an update of the registers.
    TIM2_sms2_b_0x4 = 0x4,
    /// Gated Mode - The counter clock is enabled when the trigger input (TRGI)
    /// is high. The counter stops (but is not reset) as soon as the trigger
    /// becomes low. Both start and stop of the counter are controlled.
    TIM2_sms2_b_0x5 = 0x5,
    /// Trigger Mode - The counter starts at a rising edge of the trigger TRGI
    /// (but it is not reset). Only the start of the counter is controlled.
    TIM2_sms2_b_0x6 = 0x6,
    /// External Clock Mode 1 - Rising edges of the selected trigger (TRGI)
    /// clock the counter.
    TIM2_sms2_b_0x7 = 0x7,
    /// Combined reset + trigger mode - Rising edge of the selected trigger
    /// input (TRGI)
    TIM2_sms2_b_0x8 = 0x8,
} TIM2_sms2_t;

/**
 * Trigger selection This bit-field selects the trigger input to be used to
 * synchronize the counter. Others: Reserved See for more details on ITRx
 * meaning for each Timer. Note: These bits must be changed only when they are
 * not used (e.g. when SMS=000) to avoid wrong edge detections at the
 * transition.
 */
typedef enum TIM2_ts2_e {
    /// Internal Trigger 0 (ITR0)
    TIM2_ts2_b_0x0 = 0x0,
    /// Internal Trigger 1 (ITR1)
    TIM2_ts2_b_0x1 = 0x1,
    /// Internal Trigger 2 (ITR2)
    TIM2_ts2_b_0x2 = 0x2,
    /// Internal Trigger 3 (ITR3)
    TIM2_ts2_b_0x3 = 0x3,
    /// TI1 Edge Detector (TI1F_ED)
    TIM2_ts2_b_0x4 = 0x4,
    /// Filtered Timer Input 1 (TI1FP1)
    TIM2_ts2_b_0x5 = 0x5,
    /// Filtered Timer Input 2 (TI2FP2)
    TIM2_ts2_b_0x6 = 0x6,
    /// External Trigger input (ETRF)
    TIM2_ts2_b_0x7 = 0x7,
    /// Internal Trigger 4 (ITR4)
    TIM2_ts2_b_0x8 = 0x8,
    /// Internal Trigger 5 (ITR5)
    TIM2_ts2_b_0x9 = 0x9,
    /// Internal Trigger 6 (ITR6)
    TIM2_ts2_b_0xa = 0xA,
    /// Internal Trigger 7 (ITR7)
    TIM2_ts2_b_0xb = 0xB,
    /// Internal Trigger 8 (ITR8)
    TIM2_ts2_b_0xc = 0xC,
} TIM2_ts2_t;

/**
 * slave mode control register
 */
typedef union TIM2_smcr_u {
    struct {
        /// Slave mode selection When external signals are selected the active
        /// edge of the trigger signal (TRGI) is linked to the polarity selected
        /// on the external input (see Input Control register and Control
        /// Register description. reinitializes the counter, generates an update
        /// of the registers and starts the counter. Note: The gated mode must
        /// not be used if TI1F_ED is selected as the trigger input (TS=00100).
        /// Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas
        /// the gated mode checks the level of the trigger signal. Note: The
        /// clock of the slave peripherals (timer, ADC, ...) receiving the TRGO
        /// or the TRGO2 signals must be enabled prior to receive events from
        /// the master timer, and the clock frequency (prescaler) must not be
        /// changed on-the-fly while triggers are received from the master
        /// timer.
        TIM2_sms1_t sms1 : 3;
        /// OCREF clear selection This bit is used to select the OCREF clear
        /// source
        TIM2_occs_t occs : 1;
        /// Trigger selection This bit-field selects the trigger input to be
        /// used to synchronize the counter. Others: Reserved See for more
        /// details on ITRx meaning for each Timer. Note: These bits must be
        /// changed only when they are not used (e.g. when SMS=000) to avoid
        /// wrong edge detections at the transition.
        TIM2_ts1_t ts1 : 3;
        /// Master/Slave mode
        TIM2_msm_t msm : 1;
        /// External trigger filter This bit-field then defines the frequency
        /// used to sample ETRP signal and the length of the digital filter
        /// applied to ETRP. The digital filter is made of an event counter in
        /// which N consecutive events are needed to validate a transition on
        /// the output:
        TIM2_etf_t etf : 4;
        /// External trigger prescaler External trigger signal ETRP frequency
        /// must be at most 1/4 of CK_INT frequency. A prescaler can be enabled
        /// to reduce ETRP frequency. It is useful when inputting fast external
        /// clocks.
        TIM2_etps_t etps : 2;
        /// External clock enable This bit enables External clock mode 2. Note:
        /// Setting the ECE bit has the same effect as selecting external clock
        /// mode 1 with TRGI connected to ETRF (SMS=111 and TS=00111). It is
        /// possible to simultaneously use external clock mode 2 with the
        /// following slave modes: reset mode, gated mode and trigger mode.
        /// Nevertheless, TRGI must not be connected to ETRF in this case (TS
        /// bits must not be 00111). If external clock mode 1 and external clock
        /// mode 2 are enabled at the same time, the external clock input is
        /// ETRF.
        TIM2_ece_t ece : 1;
        /// External trigger polarity This bit selects whether ETR or ETR is
        /// used for trigger operations
        TIM2_etp_t etp : 1;
        /// Slave mode selection When external signals are selected the active
        /// edge of the trigger signal (TRGI) is linked to the polarity selected
        /// on the external input (see Input Control register and Control
        /// Register description. reinitializes the counter, generates an update
        /// of the registers and starts the counter. Note: The gated mode must
        /// not be used if TI1F_ED is selected as the trigger input (TS=00100).
        /// Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas
        /// the gated mode checks the level of the trigger signal. Note: The
        /// clock of the slave peripherals (timer, ADC, ...) receiving the TRGO
        /// or the TRGO2 signals must be enabled prior to receive events from
        /// the master timer, and the clock frequency (prescaler) must not be
        /// changed on-the-fly while triggers are received from the master
        /// timer.
        TIM2_sms2_t    sms2 : 1;
        uint32_t const reserved_17 : 3;
        /// Trigger selection This bit-field selects the trigger input to be
        /// used to synchronize the counter. Others: Reserved See for more
        /// details on ITRx meaning for each Timer. Note: These bits must be
        /// changed only when they are not used (e.g. when SMS=000) to avoid
        /// wrong edge detections at the transition.
        TIM2_ts2_t ts2 : 2;
    };
    uint32_t bits;
} TIM2_smcr_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_smcr_t, sizeof(uint32_t));

/**
 * Update interrupt enable
 */
typedef enum TIM2_uie_e {
    /// Update interrupt disabled.
    TIM2_uie_b_0x0 = 0x0,
    /// Update interrupt enabled.
    TIM2_uie_b_0x1 = 0x1,
} TIM2_uie_t;

/**
 * Capture/Compare 1 interrupt enable
 */
typedef enum TIM2_cc1ie_e {
    /// CC1 interrupt disabled.
    TIM2_cc1ie_b_0x0 = 0x0,
    /// CC1 interrupt enabled.
    TIM2_cc1ie_b_0x1 = 0x1,
} TIM2_cc1ie_t;

/**
 * Capture/Compare 2 interrupt enable
 */
typedef enum TIM2_cc2ie_e {
    /// CC2 interrupt disabled.
    TIM2_cc2ie_b_0x0 = 0x0,
    /// CC2 interrupt enabled.
    TIM2_cc2ie_b_0x1 = 0x1,
} TIM2_cc2ie_t;

/**
 * Capture/Compare 3 interrupt enable
 */
typedef enum TIM2_cc3ie_e {
    /// CC3 interrupt disabled.
    TIM2_cc3ie_b_0x0 = 0x0,
    /// CC3 interrupt enabled.
    TIM2_cc3ie_b_0x1 = 0x1,
} TIM2_cc3ie_t;

/**
 * Capture/Compare 4 interrupt enable
 */
typedef enum TIM2_cc4ie_e {
    /// CC4 interrupt disabled.
    TIM2_cc4ie_b_0x0 = 0x0,
    /// CC4 interrupt enabled.
    TIM2_cc4ie_b_0x1 = 0x1,
} TIM2_cc4ie_t;

/**
 * Trigger interrupt enable
 */
typedef enum TIM2_tie_e {
    /// Trigger interrupt disabled.
    TIM2_tie_b_0x0 = 0x0,
    /// Trigger interrupt enabled.
    TIM2_tie_b_0x1 = 0x1,
} TIM2_tie_t;

/**
 * Update DMA request enable
 */
typedef enum TIM2_ude_e {
    /// Update DMA request disabled.
    TIM2_ude_b_0x0 = 0x0,
    /// Update DMA request enabled.
    TIM2_ude_b_0x1 = 0x1,
} TIM2_ude_t;

/**
 * Capture/Compare 1 DMA request enable
 */
typedef enum TIM2_cc1de_e {
    /// CC1 DMA request disabled.
    TIM2_cc1de_b_0x0 = 0x0,
    /// CC1 DMA request enabled.
    TIM2_cc1de_b_0x1 = 0x1,
} TIM2_cc1de_t;

/**
 * Capture/Compare 2 DMA request enable
 */
typedef enum TIM2_cc2de_e {
    /// CC2 DMA request disabled.
    TIM2_cc2de_b_0x0 = 0x0,
    /// CC2 DMA request enabled.
    TIM2_cc2de_b_0x1 = 0x1,
} TIM2_cc2de_t;

/**
 * Capture/Compare 3 DMA request enable
 */
typedef enum TIM2_cc3de_e {
    /// CC3 DMA request disabled.
    TIM2_cc3de_b_0x0 = 0x0,
    /// CC3 DMA request enabled.
    TIM2_cc3de_b_0x1 = 0x1,
} TIM2_cc3de_t;

/**
 * Capture/Compare 4 DMA request enable
 */
typedef enum TIM2_cc4de_e {
    /// CC4 DMA request disabled.
    TIM2_cc4de_b_0x0 = 0x0,
    /// CC4 DMA request enabled.
    TIM2_cc4de_b_0x1 = 0x1,
} TIM2_cc4de_t;

/**
 * Trigger DMA request enable
 */
typedef enum TIM2_tde_e {
    /// Trigger DMA request disabled.
    TIM2_tde_b_0x0 = 0x0,
    /// Trigger DMA request enabled.
    TIM2_tde_b_0x1 = 0x1,
} TIM2_tde_t;

/**
 * DMA/Interrupt enable register
 */
typedef union TIM2_dier_u {
    struct {
        /// Update interrupt enable
        TIM2_uie_t uie : 1;
        /// Capture/Compare 1 interrupt enable
        TIM2_cc1ie_t cc1ie : 1;
        /// Capture/Compare 2 interrupt enable
        TIM2_cc2ie_t cc2ie : 1;
        /// Capture/Compare 3 interrupt enable
        TIM2_cc3ie_t cc3ie : 1;
        /// Capture/Compare 4 interrupt enable
        TIM2_cc4ie_t   cc4ie : 1;
        uint32_t const reserved_05 : 1;
        /// Trigger interrupt enable
        TIM2_tie_t     tie : 1;
        uint32_t const reserved_07 : 1;
        /// Update DMA request enable
        TIM2_ude_t ude : 1;
        /// Capture/Compare 1 DMA request enable
        TIM2_cc1de_t cc1de : 1;
        /// Capture/Compare 2 DMA request enable
        TIM2_cc2de_t cc2de : 1;
        /// Capture/Compare 3 DMA request enable
        TIM2_cc3de_t cc3de : 1;
        /// Capture/Compare 4 DMA request enable
        TIM2_cc4de_t   cc4de : 1;
        uint32_t const reserved_13 : 1;
        /// Trigger DMA request enable
        TIM2_tde_t tde : 1;
    };
    uint32_t bits;
} TIM2_dier_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_dier_t, sizeof(uint32_t));

/**
 * Update interrupt flag This bit is set by hardware on an update event. It is
 * cleared by software. At overflow or underflow and if UDIS=0 in the TIMx_CR1
 * register. When CNT is reinitialized by software using the UG bit in TIMx_EGR
 * register, if URS=0 and UDIS=0 in the TIMx_CR1 register. When CNT is
 * reinitialized by a trigger event (refer to the synchro control register
 * description), if URS=0 and UDIS=0 in the TIMx_CR1 register.
 */
typedef enum TIM2_uif_e {
    /// No update occurred
    TIM2_uif_b_0x0 = 0x0,
    /// Update interrupt pending. This bit is set by hardware when the registers
    /// are updated:
    TIM2_uif_b_0x1 = 0x1,
} TIM2_uif_t;

/**
 * Capture/compare 1 interrupt flag This flag is set by hardware. It is cleared
 * by software (input capture or output compare mode) or by reading the
 * TIMx_CCR1 register (input capture mode only). If channel CC1 is configured as
 * output: this flag is set when the content of the counter TIMx_CNT matches the
 * content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater
 * than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow
 * (in up-counting and up/down-counting modes) or underflow (in down-counting
 * mode). There are 3 possible options for flag setting in center-aligned mode,
 * refer to the CMS bits in the TIMx_CR1 register for the full description. If
 * channel CC1 is configured as input: this bit is set when counter value has
 * been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per
 * the edge sensitivity defined with the CC1P and CC1NP bits setting, in
 * TIMx_CCER).
 */
typedef enum TIM2_cc1if_e {
    /// No compare match / No input capture occurred
    TIM2_cc1if_b_0x0 = 0x0,
    /// A compare match or an input capture occurred
    TIM2_cc1if_b_0x1 = 0x1,
} TIM2_cc1if_t;

/**
 * Trigger interrupt flag This flag is set by hardware on the TRG trigger event
 * (active edge detected on TRGI input when the slave mode controller is enabled
 * in all modes but gated mode. It is set when the counter starts or stops when
 * gated mode is selected. It is cleared by software.
 */
typedef enum TIM2_tif_e {
    /// No trigger event occurred.
    TIM2_tif_b_0x0 = 0x0,
    /// Trigger interrupt pending.
    TIM2_tif_b_0x1 = 0x1,
} TIM2_tif_t;

/**
 * Capture/Compare 1 overcapture flag This flag is set by hardware only when the
 * corresponding channel is configured in input capture mode. It is cleared by
 * software by writing it to '0â.
 */
typedef enum TIM2_cc1of_e {
    /// No overcapture has been detected.
    TIM2_cc1of_b_0x0 = 0x0,
    /// The counter value has been captured in TIMx_CCR1 register while CC1IF
    /// flag was already set
    TIM2_cc1of_b_0x1 = 0x1,
} TIM2_cc1of_t;

/**
 * status register
 */
typedef union TIM2_sr_u {
    struct {
        /// Update interrupt flag This bit is set by hardware on an update
        /// event. It is cleared by software. At overflow or underflow and if
        /// UDIS=0 in the TIMx_CR1 register. When CNT is reinitialized by
        /// software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0
        /// in the TIMx_CR1 register. When CNT is reinitialized by a trigger
        /// event (refer to the synchro control register description), if URS=0
        /// and UDIS=0 in the TIMx_CR1 register.
        TIM2_uif_t uif : 1;
        /// Capture/compare 1 interrupt flag This flag is set by hardware. It is
        /// cleared by software (input capture or output compare mode) or by
        /// reading the TIMx_CCR1 register (input capture mode only). If channel
        /// CC1 is configured as output: this flag is set when the content of
        /// the counter TIMx_CNT matches the content of the TIMx_CCR1 register.
        /// When the content of TIMx_CCR1 is greater than the content of
        /// TIMx_ARR, the CC1IF bit goes high on the counter overflow (in
        /// up-counting and up/down-counting modes) or underflow (in
        /// down-counting mode). There are 3 possible options for flag setting
        /// in center-aligned mode, refer to the CMS bits in the TIMx_CR1
        /// register for the full description. If channel CC1 is configured as
        /// input: this bit is set when counter value has been captured in
        /// TIMx_CCR1 register (an edge has been detected on IC1, as per the
        /// edge sensitivity defined with the CC1P and CC1NP bits setting, in
        /// TIMx_CCER).
        TIM2_cc1if_t cc1if : 1;
        /// Capture/Compare 2 interrupt flag Refer to CC1IF description
        uint32_t cc2if : 1;
        /// Capture/Compare 3 interrupt flag Refer to CC1IF description
        uint32_t cc3if : 1;
        /// Capture/Compare 4 interrupt flag Refer to CC1IF description
        uint32_t       cc4if : 1;
        uint32_t const reserved_05 : 1;
        /// Trigger interrupt flag This flag is set by hardware on the TRG
        /// trigger event (active edge detected on TRGI input when the slave
        /// mode controller is enabled in all modes but gated mode. It is set
        /// when the counter starts or stops when gated mode is selected. It is
        /// cleared by software.
        TIM2_tif_t     tif : 1;
        uint32_t const reserved_07 : 2;
        /// Capture/Compare 1 overcapture flag This flag is set by hardware only
        /// when the corresponding channel is configured in input capture mode.
        /// It is cleared by software by writing it to '0â.
        TIM2_cc1of_t cc1of : 1;
        /// Capture/compare 2 overcapture flag refer to CC1OF description
        uint32_t cc2of : 1;
        /// Capture/Compare 3 overcapture flag refer to CC1OF description
        uint32_t cc3of : 1;
        /// Capture/Compare 4 overcapture flag refer to CC1OF description
        uint32_t cc4of : 1;
    };
    uint32_t bits;
} TIM2_sr_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_sr_t, sizeof(uint32_t));

/**
 * Update generation This bit can be set by software, it is automatically
 * cleared by hardware.
 */
typedef enum TIM2_ug_e {
    /// No action
    TIM2_ug_b_0x0 = 0x0,
    /// Re-initialize the counter and generates an update of the registers. Note
    /// that the prescaler counter is cleared too (anyway the prescaler ratio is
    /// not affected). The counter is cleared if the center-aligned mode is
    /// selected or if DIR=0 (upcounting), else it takes the auto-reload value
    /// (TIMx_ARR) if DIR=1 (downcounting).
    TIM2_ug_b_0x1 = 0x1,
} TIM2_ug_t;

/**
 * Capture/compare 1 generation This bit is set by software in order to generate
 * an event, it is automatically cleared by hardware. If channel CC1 is
 * configured as output: CC1IF flag is set, Corresponding interrupt or DMA
 * request is sent if enabled. If channel CC1 is configured as input: The
 * current value of the counter is captured in TIMx_CCR1 register. The CC1IF
 * flag is set, the corresponding interrupt or DMA request is sent if enabled.
 * The CC1OF flag is set if the CC1IF flag was already high.
 */
typedef enum TIM2_cc1g_e {
    /// No action
    TIM2_cc1g_b_0x0 = 0x0,
    /// A capture/compare event is generated on channel 1:
    TIM2_cc1g_b_0x1 = 0x1,
} TIM2_cc1g_t;

/**
 * Trigger generation This bit is set by software in order to generate an event,
 * it is automatically cleared by hardware.
 */
typedef enum TIM2_tg_e {
    /// No action
    TIM2_tg_b_0x0 = 0x0,
    /// The TIF flag is set in TIMx_SR register. Related interrupt or DMA
    /// transfer can occur if enabled.
    TIM2_tg_b_0x1 = 0x1,
} TIM2_tg_t;

/**
 * event generation register
 */
typedef union TIM2_egr_u {
    struct {
        /// Update generation This bit can be set by software, it is
        /// automatically cleared by hardware.
        TIM2_ug_t ug : 1;
        /// Capture/compare 1 generation This bit is set by software in order to
        /// generate an event, it is automatically cleared by hardware. If
        /// channel CC1 is configured as output: CC1IF flag is set,
        /// Corresponding interrupt or DMA request is sent if enabled. If
        /// channel CC1 is configured as input: The current value of the counter
        /// is captured in TIMx_CCR1 register. The CC1IF flag is set, the
        /// corresponding interrupt or DMA request is sent if enabled. The CC1OF
        /// flag is set if the CC1IF flag was already high.
        TIM2_cc1g_t cc1g : 1;
        /// Capture/compare 2 generation Refer to CC1G description
        uint32_t cc2g : 1;
        /// Capture/compare 3 generation Refer to CC1G description
        uint32_t cc3g : 1;
        /// Capture/compare 4 generation Refer to CC1G description
        uint32_t       cc4g : 1;
        uint32_t const reserved_05 : 1;
        /// Trigger generation This bit is set by software in order to generate
        /// an event, it is automatically cleared by hardware.
        TIM2_tg_t tg : 1;
    };
    uint32_t bits;
} TIM2_egr_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_egr_t, sizeof(uint32_t));

/**
 * Capture/Compare 1 selection This bit-field defines the direction of the
 * channel (input/output) as well as the used input. Note: CC1S bits are
 * writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).
 */
typedef enum TIM2_cc1s_e {
    /// CC1 channel is configured as output
    TIM2_cc1s_b_0x0 = 0x0,
    /// CC1 channel is configured as input, IC1 is mapped on TI1
    TIM2_cc1s_b_0x1 = 0x1,
    /// CC1 channel is configured as input, IC1 is mapped on TI2
    TIM2_cc1s_b_0x2 = 0x2,
    /// CC1 channel is configured as input, IC1 is mapped on TRC. This mode is
    /// working only if an internal trigger input is selected through TS bit
    /// (TIMx_SMCR register)
    TIM2_cc1s_b_0x3 = 0x3,
} TIM2_cc1s_t;

/**
 * Output compare 1 preload enable Note: The PWM mode can be used without
 * validating the preload register only in one-pulse mode (OPM bit set in
 * TIMx_CR1 register). Else the behavior is not guaranteed.
 */
typedef enum TIM2_oc1pe_e {
    /// Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at
    /// anytime, the new value is taken in account immediately.
    TIM2_oc1pe_b_0x0 = 0x0,
    /// Preload register on TIMx_CCR1 enabled. Read/Write operations access the
    /// preload register. TIMx_CCR1 preload value is loaded in the active
    /// register at each update event.
    TIM2_oc1pe_b_0x1 = 0x1,
} TIM2_oc1pe_t;

/**
 * Output compare 1 mode These bits define the behavior of the output reference
 * signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high
 * whereas OC1 and OC1N active level depends on CC1P and CC1NP bits. Note: In
 * PWM mode, the OCREF level changes only when the result of the comparison
 * changes or when the output compare mode switches from âfrozenâ mode
 * to âPWMâ mode. Note: The OC1M[3] bit is not contiguous, located in
 * bit 16.
 */
typedef enum TIM2_oc1m1_e {
    /// Frozen - The comparison between the output compare register TIMx_CCR1
    /// and the counter TIMx_CNT has no effect on the outputs.(this mode is used
    /// to generate a timing base).
    TIM2_oc1m1_b_0x0 = 0x0,
    /// Set channel 1 to active level on match. OC1REF signal is forced high
    /// when the counter TIMx_CNT matches the capture/compare register 1
    /// (TIMx_CCR1).
    TIM2_oc1m1_b_0x1 = 0x1,
    /// Set channel 1 to inactive level on match. OC1REF signal is forced low
    /// when the counter TIMx_CNT matches the capture/compare register 1
    /// (TIMx_CCR1).
    TIM2_oc1m1_b_0x2 = 0x2,
    /// Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.
    TIM2_oc1m1_b_0x3 = 0x3,
    /// Force inactive level - OC1REF is forced low.
    TIM2_oc1m1_b_0x4 = 0x4,
    /// Force active level - OC1REF is forced high.
    TIM2_oc1m1_b_0x5 = 0x5,
    /// PWM mode 1 - In upcounting, channel 1 is active as long as
    /// TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive
    /// (OC1REF='0) as long as TIMx_CNT>TIMx_CCR1 else active (OC1REF=1).
    TIM2_oc1m1_b_0x6 = 0x6,
    /// PWM mode 2 - In upcounting, channel 1 is inactive as long as
    /// TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as
    /// long as TIMx_CNT>TIMx_CCR1 else inactive.
    TIM2_oc1m1_b_0x7 = 0x7,
    /// Retriggerable OPM mode 1 - In up-counting mode, the channel is active
    /// until a trigger event is detected (on TRGI signal). Then, a comparison
    /// is performed as in PWM mode 1 and the channels becomes inactive again at
    /// the next update. In down-counting mode, the channel is inactive until a
    /// trigger event is detected (on TRGI signal). Then, a comparison is
    /// performed as in PWM mode 1 and the channels becomes inactive again at
    /// the next update.
    TIM2_oc1m1_b_0x8 = 0x8,
    /// Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive
    /// until a trigger event is detected (on TRGI signal). Then, a comparison
    /// is performed as in PWM mode 2 and the channels becomes inactive again at
    /// the next update. In down-counting mode, the channel is active until a
    /// trigger event is detected (on TRGI signal). Then, a comparison is
    /// performed as in PWM mode 1 and the channels becomes active again at the
    /// next update.
    TIM2_oc1m1_b_0x9 = 0x9,
    /// Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1.
    /// OC1REFC is the logical OR between OC1REF and OC2REF.
    TIM2_oc1m1_b_0xc = 0xC,
    /// Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2.
    /// OC1REFC is the logical AND between OC1REF and OC2REF.
    TIM2_oc1m1_b_0xd = 0xD,
    /// Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1.
    /// OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it
    /// is counting down.
    TIM2_oc1m1_b_0xe = 0xE,
    /// Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2.
    /// OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it
    /// is counting down.
    TIM2_oc1m1_b_0xf = 0xF,
} TIM2_oc1m1_t;

/**
 * Output compare 1 clear enable
 */
typedef enum TIM2_oc1ce_e {
    /// OC1Ref is not affected by the ETRF input
    TIM2_oc1ce_b_0x0 = 0x0,
    /// OC1Ref is cleared as soon as a High level is detected on ETRF input
    TIM2_oc1ce_b_0x1 = 0x1,
} TIM2_oc1ce_t;

/**
 * Capture/compare 2 selection This bit-field defines the direction of the
 * channel (input/output) as well as the used input. Note: CC2S bits are
 * writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).
 */
typedef enum TIM2_cc2s_e {
    /// CC2 channel is configured as output.
    TIM2_cc2s_b_0x0 = 0x0,
    /// CC2 channel is configured as input, IC2 is mapped on TI2.
    TIM2_cc2s_b_0x1 = 0x1,
    /// CC2 channel is configured as input, IC2 is mapped on TI1.
    TIM2_cc2s_b_0x2 = 0x2,
    /// CC2 channel is configured as input, IC2 is mapped on TRC. This mode is
    /// working only if an internal trigger input is selected through TS bit
    /// (TIMx_SMCR register)
    TIM2_cc2s_b_0x3 = 0x3,
} TIM2_cc2s_t;

/**
 * capture/compare mode register 1 (output mode)
 */
typedef union TIM2_ccmr1_output_u {
    struct {
        /// Capture/Compare 1 selection This bit-field defines the direction of
        /// the channel (input/output) as well as the used input. Note: CC1S
        /// bits are writable only when the channel is OFF (CC1E = 0 in
        /// TIMx_CCER).
        TIM2_cc1s_t cc1s : 2;
        /// Output compare 1 fast enable
        uint32_t oc1fe : 1;
        /// Output compare 1 preload enable Note: The PWM mode can be used
        /// without validating the preload register only in one-pulse mode (OPM
        /// bit set in TIMx_CR1 register). Else the behavior is not guaranteed.
        TIM2_oc1pe_t oc1pe : 1;
        /// Output compare 1 mode These bits define the behavior of the output
        /// reference signal OC1REF from which OC1 and OC1N are derived. OC1REF
        /// is active high whereas OC1 and OC1N active level depends on CC1P and
        /// CC1NP bits. Note: In PWM mode, the OCREF level changes only when the
        /// result of the comparison changes or when the output compare mode
        /// switches from âfrozenâ mode to âPWMâ mode. Note:
        /// The OC1M[3] bit is not contiguous, located in bit 16.
        TIM2_oc1m1_t oc1m1 : 3;
        /// Output compare 1 clear enable
        TIM2_oc1ce_t oc1ce : 1;
        /// Capture/compare 2 selection This bit-field defines the direction of
        /// the channel (input/output) as well as the used input. Note: CC2S
        /// bits are writable only when the channel is OFF (CC2E = 0 in
        /// TIMx_CCER).
        TIM2_cc2s_t cc2s : 2;
        /// Output compare 2 fast enable
        uint32_t oc2fe : 1;
        /// Output compare 2 preload enable
        uint32_t oc2pe : 1;
        /// Output compare 2 mode
        uint32_t oc2m : 3;
        /// Output compare 2 clear enable
        uint32_t oc2ce : 1;
        /// Output Compare 1 mode - bit 3
        uint32_t       oc1m_3 : 1;
        uint32_t const reserved_17 : 7;
        /// Output Compare 2 mode - bit 3
        uint32_t oc2m_3 : 1;
    };
    uint32_t bits;
} TIM2_ccmr1_output_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_ccmr1_output_t, sizeof(uint32_t));

/**
 * capture/compare mode register 1 (input mode)
 */
typedef union TIM2_ccmr1_input_u {
    struct {
        /// Capture/Compare 1 selection
        uint32_t cc1s : 2;
        /// Input capture 1 prescaler
        uint32_t ic1psc : 2;
        /// Input capture 1 filter
        uint32_t ic1f : 4;
        /// Capture/compare 2 selection
        uint32_t cc2s : 2;
        /// Input capture 2 prescaler
        uint32_t ic2psc : 2;
        /// Input capture 2 filter
        uint32_t ic2f : 4;
    };
    uint32_t bits;
} TIM2_ccmr1_input_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_ccmr1_input_t, sizeof(uint32_t));

/**
 * capture/compare mode register 2 (output mode)
 */
typedef union TIM2_ccmr2_output_u {
    struct {
        /// Capture/Compare 3 selection
        uint32_t cc3s : 2;
        /// Output compare 3 fast enable
        uint32_t oc3fe : 1;
        /// Output compare 3 preload enable
        uint32_t oc3pe : 1;
        /// Output compare 3 mode
        uint32_t oc3m : 3;
        /// Output compare 3 clear enable
        uint32_t oc3ce : 1;
        /// Capture/Compare 4 selection
        uint32_t cc4s : 2;
        /// Output compare 4 fast enable
        uint32_t oc4fe : 1;
        /// Output compare 4 preload enable
        uint32_t oc4pe : 1;
        /// Output compare 4 mode
        uint32_t oc4m : 3;
        /// Output compare 4 clear enable
        uint32_t oc4ce : 1;
        /// Output Compare 3 mode - bit 3
        uint32_t       oc3m_3 : 1;
        uint32_t const reserved_17 : 7;
        /// Output Compare 4 mode - bit 3
        uint32_t oc4m_3 : 1;
    };
    uint32_t bits;
} TIM2_ccmr2_output_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_ccmr2_output_t, sizeof(uint32_t));

/**
 * Capture/Compare 3 selection This bit-field defines the direction of the
 * channel (input/output) as well as the used input. Note: CC3S bits are
 * writable only when the channel is OFF (CC3E = 0 in TIMx_CCER).
 */
typedef enum TIM2_cc3s_e {
    /// CC3 channel is configured as output
    TIM2_cc3s_b_0x0 = 0x0,
    /// CC3 channel is configured as input, IC3 is mapped on TI3
    TIM2_cc3s_b_0x1 = 0x1,
    /// CC3 channel is configured as input, IC3 is mapped on TI4
    TIM2_cc3s_b_0x2 = 0x2,
    /// CC3 channel is configured as input, IC3 is mapped on TRC. This mode is
    /// working only if an internal trigger input is selected through TS bit
    /// (TIMx_SMCR register)
    TIM2_cc3s_b_0x3 = 0x3,
} TIM2_cc3s_t;

/**
 * Capture/Compare 4 selection This bit-field defines the direction of the
 * channel (input/output) as well as the used input. Note: CC4S bits are
 * writable only when the channel is OFF (CC4E = 0 in TIMx_CCER).
 */
typedef enum TIM2_cc4s_e {
    /// CC4 channel is configured as output
    TIM2_cc4s_b_0x0 = 0x0,
    /// CC4 channel is configured as input, IC4 is mapped on TI4
    TIM2_cc4s_b_0x1 = 0x1,
    /// CC4 channel is configured as input, IC4 is mapped on TI3
    TIM2_cc4s_b_0x2 = 0x2,
    /// CC4 channel is configured as input, IC4 is mapped on TRC. This mode is
    /// working only if an internal trigger input is selected through TS bit
    /// (TIMx_SMCR register)
    TIM2_cc4s_b_0x3 = 0x3,
} TIM2_cc4s_t;

/**
 * capture/compare mode register 2 (input mode)
 */
typedef union TIM2_ccmr2_input_u {
    struct {
        /// Capture/Compare 3 selection This bit-field defines the direction of
        /// the channel (input/output) as well as the used input. Note: CC3S
        /// bits are writable only when the channel is OFF (CC3E = 0 in
        /// TIMx_CCER).
        TIM2_cc3s_t cc3s : 2;
        /// Input capture 3 prescaler
        uint32_t ic3psc : 2;
        /// Input capture 3 filter
        uint32_t ic3f : 4;
        /// Capture/Compare 4 selection This bit-field defines the direction of
        /// the channel (input/output) as well as the used input. Note: CC4S
        /// bits are writable only when the channel is OFF (CC4E = 0 in
        /// TIMx_CCER).
        TIM2_cc4s_t cc4s : 2;
        /// Input capture 4 prescaler
        uint32_t ic4psc : 2;
        /// Input capture 4 filter
        uint32_t ic4f : 4;
    };
    uint32_t bits;
} TIM2_ccmr2_input_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_ccmr2_input_t, sizeof(uint32_t));

/**
 * Capture/Compare 1 output enable.
 */
typedef enum TIM2_cc1e_e {
    /// Capture mode disabled / OC1 is not active
    TIM2_cc1e_b_0x0 = 0x0,
    /// Capture mode enabled / OC1 signal is output on the corresponding output
    /// pin
    TIM2_cc1e_b_0x1 = 0x1,
} TIM2_cc1e_t;

/**
 * Capture/Compare 1 output Polarity. When CC1 channel is configured as input,
 * both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for
 * trigger or capture operations. CC1NP=0, CC1P=0: non-inverted/rising edge. The
 * circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in
 * reset, external clock or trigger mode), TIxFP1 is not inverted (trigger
 * operation in gated mode or encoder mode). CC1NP=0, CC1P=1: inverted/falling
 * edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger
 * operations in reset, external clock or trigger mode), TIxFP1 is inverted
 * (trigger operation in gated mode or encoder mode). CC1NP=1, CC1P=1:
 * non-inverted/both edges. The circuit is sensitive to both TIxFP1 rising and
 * falling edges (capture or trigger operations in reset, external clock or
 * trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This
 * configuration must not be used in encoder mode. CC1NP=1, CC1P=0: This
 * configuration is reserved, it must not be used.
 */
typedef enum TIM2_cc1p_e {
    /// OC1 active high (output mode) / Edge sensitivity selection (input mode,
    /// see below)
    TIM2_cc1p_b_0x0 = 0x0,
    /// OC1 active low (output mode) / Edge sensitivity selection (input mode,
    /// see below)
    TIM2_cc1p_b_0x1 = 0x1,
} TIM2_cc1p_t;

/**
 * capture/compare enable register
 */
typedef union TIM2_ccer_u {
    struct {
        /// Capture/Compare 1 output enable.
        TIM2_cc1e_t cc1e : 1;
        /// Capture/Compare 1 output Polarity. When CC1 channel is configured as
        /// input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and
        /// TI2FP1 for trigger or capture operations. CC1NP=0, CC1P=0:
        /// non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising
        /// edge (capture or trigger operations in reset, external clock or
        /// trigger mode), TIxFP1 is not inverted (trigger operation in gated
        /// mode or encoder mode). CC1NP=0, CC1P=1: inverted/falling edge. The
        /// circuit is sensitive to TIxFP1 falling edge (capture or trigger
        /// operations in reset, external clock or trigger mode), TIxFP1 is
        /// inverted (trigger operation in gated mode or encoder mode). CC1NP=1,
        /// CC1P=1: non-inverted/both edges. The circuit is sensitive to both
        /// TIxFP1 rising and falling edges (capture or trigger operations in
        /// reset, external clock or trigger mode), TIxFP1is not inverted
        /// (trigger operation in gated mode). This configuration must not be
        /// used in encoder mode. CC1NP=1, CC1P=0: This configuration is
        /// reserved, it must not be used.
        TIM2_cc1p_t    cc1p : 1;
        uint32_t const reserved_02 : 1;
        /// Capture/Compare 1 output Polarity. CC1 channel configured as output:
        /// CC1NP must be kept cleared in this case. CC1 channel configured as
        /// input: This bit is used in conjunction with CC1P to define
        /// TI1FP1/TI2FP1 polarity. refer to CC1P description.
        uint32_t cc1np : 1;
        /// Capture/Compare 2 output enable. Refer to CC1E description
        uint32_t cc2e : 1;
        /// Capture/Compare 2 output Polarity. refer to CC1P description
        uint32_t       cc2p : 1;
        uint32_t const reserved_06 : 1;
        /// Capture/Compare 2 output Polarity. Refer to CC1NP description
        uint32_t cc2np : 1;
        /// Capture/Compare 3 output enable. Refer to CC1E description
        uint32_t cc3e : 1;
        /// Capture/Compare 3 output Polarity. Refer to CC1P description
        uint32_t       cc3p : 1;
        uint32_t const reserved_10 : 1;
        /// Capture/Compare 3 output Polarity. Refer to CC1NP description
        uint32_t cc3np : 1;
        /// Capture/Compare 4 output enable. refer to CC1E description
        uint32_t cc4e : 1;
        /// Capture/Compare 4 output Polarity. Refer to CC1P description
        uint32_t       cc4p : 1;
        uint32_t const reserved_14 : 1;
        /// Capture/Compare 4 output Polarity. Refer to CC1NP description
        uint32_t cc4np : 1;
    };
    uint32_t bits;
} TIM2_ccer_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_ccer_t, sizeof(uint32_t));

/**
 * counter
 */
typedef union TIM2_cnt_u {
    struct {
        /// Low counter value
        uint32_t cnt_l : 16;
        /// High counter value (TIM2 only)
        uint32_t cnt_h : 16;
    };
    uint32_t bits;
} TIM2_cnt_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_cnt_t, sizeof(uint32_t));

/**
 * counter
 */
typedef union TIM2_cnt_alternate5_u {
    struct {
        /// Most significant part counter value (TIM2) nullLeast significant
        /// part of counter value
        uint32_t cnt : 31;
        /// UIF Copy This bit is a read-only copy of the UIF bit of the TIMx_ISR
        /// register
        uint32_t uifcpy : 1;
    };
    uint32_t bits;
} TIM2_cnt_alternate5_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_cnt_alternate5_t, sizeof(uint32_t));

/**
 * prescaler
 */
typedef union TIM2_psc_u {
    struct {
        /// Prescaler value
        uint32_t psc : 16;
    };
    uint32_t bits;
} TIM2_psc_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_psc_t, sizeof(uint32_t));

/**
 * auto-reload register
 */
typedef union TIM2_arr_u {
    struct {
        /// High auto-reload value (TIM2) nullLow Auto-reload value ARR is the
        /// value to be loaded in the actual auto-reload register. Refer to the
        /// for more details about ARR update and behavior. The counter is
        /// blocked while the auto-reload value is null.
        uint32_t arr : 32;
    };
    uint32_t bits;
} TIM2_arr_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_arr_t, sizeof(uint32_t));

/**
 * capture/compare register 1
 */
typedef union TIM2_ccr1_u {
    struct {
        /// High Capture/Compare 1 value (TIM2) nullLow Capture/Compare 1 value
        /// If channel CC1 is configured as output: CCR1 is the value to be
        /// loaded in the actual capture/compare 1 register (preload value). It
        /// is loaded permanently if the preload feature is not selected in the
        /// TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in
        /// the active capture/compare 1 register when an update event occurs.
        /// The active capture/compare register contains the value to be
        /// compared to the counter TIMx_CNT and signaled on OC1 output. If
        /// channel CC1is configured as input: CCR1 is the counter value
        /// transferred by the last input capture 1 event (IC1). The TIMx_CCR1
        /// register is read-only and cannot be programmed.
        uint32_t ccr1 : 32;
    };
    uint32_t bits;
} TIM2_ccr1_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_ccr1_t, sizeof(uint32_t));

/**
 * capture/compare register 2
 */
typedef union TIM2_ccr2_u {
    struct {
        /// High Capture/Compare 2 value (TIM2) nullLow Capture/Compare 2 value
        /// If channel CC2 is configured as output: CCR2 is the value to be
        /// loaded in the actual capture/compare 2 register (preload value). It
        /// is loaded permanently if the preload feature is not selected in the
        /// TIMx_CCMR1 register (bit OC2PE). Else the preload value is copied in
        /// the active capture/compare 2 register when an update event occurs.
        /// The active capture/compare register contains the value to be
        /// compared to the counter TIMx_CNT and signalled on OC2 output. If
        /// channel CC2 is configured as input: CCR2 is the counter value
        /// transferred by the last input capture 2 event (IC2). The TIMx_CCR2
        /// register is read-only and cannot be programmed.
        uint32_t ccr2 : 32;
    };
    uint32_t bits;
} TIM2_ccr2_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_ccr2_t, sizeof(uint32_t));

/**
 * capture/compare register 3
 */
typedef union TIM2_ccr3_u {
    struct {
        /// High Capture/Compare 3 value (TIM2) nullLow Capture/Compare value If
        /// channel CC3 is configured as output: CCR3 is the value to be loaded
        /// in the actual capture/compare 3 register (preload value). It is
        /// loaded permanently if the preload feature is not selected in the
        /// TIMx_CCMR2 register (bit OC3PE). Else the preload value is copied in
        /// the active capture/compare 3 register when an update event occurs.
        /// The active capture/compare register contains the value to be
        /// compared to the counter TIMx_CNT and signalled on OC3 output. If
        /// channel CC3is configured as input: CCR3 is the counter value
        /// transferred by the last input capture 3 event (IC3). The TIMx_CCR3
        /// register is read-only and cannot be programmed.
        uint32_t ccr3 : 32;
    };
    uint32_t bits;
} TIM2_ccr3_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_ccr3_t, sizeof(uint32_t));

/**
 * capture/compare register 4
 */
typedef union TIM2_ccr4_u {
    struct {
        /// High Capture/Compare 4 value (TIM2) nullLow Capture/Compare value if
        /// CC4 channel is configured as output (CC4S bits): CCR4 is the value
        /// to be loaded in the actual capture/compare 4 register (preload
        /// value). It is loaded permanently if the preload feature is not
        /// selected in the TIMx_CCMR2 register (bit OC4PE). Else the preload
        /// value is copied in the active capture/compare 4 register when an
        /// update event occurs. The active capture/compare register contains
        /// the value to be compared to the counter TIMx_CNT and signalled on
        /// OC4 output. if CC4 channel is configured as input (CC4S bits in
        /// TIMx_CCMR4 register): CCR4 is the counter value transferred by the
        /// last input capture 4 event (IC4). The TIMx_CCR4 register is
        /// read-only and cannot be programmed.
        uint32_t ccr4 : 32;
    };
    uint32_t bits;
} TIM2_ccr4_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_ccr4_t, sizeof(uint32_t));

/**
 * DMA base address This 5-bit vector defines the base-address for DMA transfers
 * (when read/write access are done through the TIMx_DMAR address). DBA is
 * defined as an offset starting from the address of the TIMx_CR1 register.
 * Example: ... Example: Let us consider the following transfer: DBL = 7
 * transfers & DBA = TIMx_CR1. In this case the transfer is done to/from 7
 * registers starting from the TIMx_CR1 address.
 */
typedef enum TIM2_dba_e {
    /// TIMx_CR1
    TIM2_dba_b_0x0 = 0x00,
    /// TIMx_CR2
    TIM2_dba_b_0x1 = 0x01,
    /// TIMx_SMCR
    TIM2_dba_b_0x2 = 0x02,
} TIM2_dba_t;

/**
 * DMA burst length This 5-bit vector defines the number of DMA transfers (the
 * timer recognizes a burst transfer when a read or a write access is done to
 * the TIMx_DMAR address). ...
 */
typedef enum TIM2_dbl_e {
    /// 1 transfer,
    TIM2_dbl_b_0x0 = 0x00,
    /// 2 transfers,
    TIM2_dbl_b_0x1 = 0x01,
    /// 3 transfers,
    TIM2_dbl_b_0x2 = 0x02,
    /// 18 transfers.
    TIM2_dbl_b_0x11 = 0x11,
} TIM2_dbl_t;

/**
 * DMA control register
 */
typedef union TIM2_dcr_u {
    struct {
        /// DMA base address This 5-bit vector defines the base-address for DMA
        /// transfers (when read/write access are done through the TIMx_DMAR
        /// address). DBA is defined as an offset starting from the address of
        /// the TIMx_CR1 register. Example: ... Example: Let us consider the
        /// following transfer: DBL = 7 transfers & DBA = TIMx_CR1. In this case
        /// the transfer is done to/from 7 registers starting from the TIMx_CR1
        /// address.
        TIM2_dba_t     dba : 5;
        uint32_t const reserved_05 : 3;
        /// DMA burst length This 5-bit vector defines the number of DMA
        /// transfers (the timer recognizes a burst transfer when a read or a
        /// write access is done to the TIMx_DMAR address). ...
        TIM2_dbl_t dbl : 5;
    };
    uint32_t bits;
} TIM2_dcr_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_dcr_t, sizeof(uint32_t));

/**
 * DMA address for full transfer
 */
typedef union TIM2_dmar_u {
    struct {
        /// DMA register for burst accesses
        uint32_t dmab : 16;
    };
    uint32_t bits;
} TIM2_dmar_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_dmar_t, sizeof(uint32_t));

/**
 * Ocref_clr source selection This bit selects the ocref_clr input source.
 */
typedef enum TIM2_ocref_clr_e {
    /// COMP1 output is connected to the OCREF_CLR input
    TIM2_ocref_clr_b_0x0 = 0x0,
    /// COMP2 output is connected to the OCREF_CLR input
    TIM2_ocref_clr_b_0x1 = 0x1,
} TIM2_ocref_clr_t;

/**
 * TIM option register
 */
typedef union TIM2_or1_u {
    struct {
        /// Ocref_clr source selection This bit selects the ocref_clr input
        /// source.
        TIM2_ocref_clr_t ocref_clr : 1;
    };
    uint32_t bits;
} TIM2_or1_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_or1_t, sizeof(uint32_t));

/**
 * ETR source selection These bits select the ETR input source. Others: Reserved
 */
typedef enum TIM2_etrsel_e {
    /// ETR legacy mode
    TIM2_etrsel_b_0x0 = 0x00,
    /// COMP1
    TIM2_etrsel_b_0x1 = 0x01,
    /// COMP2
    TIM2_etrsel_b_0x2 = 0x02,
    /// LSE
    TIM2_etrsel_b_0x3 = 0x03,
} TIM2_etrsel_t;

/**
 * TIM alternate function option register 1
 */
typedef union TIM2_af1_u {
    struct {
        uint32_t const reserved_00 : 14;
        /// ETR source selection These bits select the ETR input source. Others:
        /// Reserved
        TIM2_etrsel_t etrsel : 4;
    };
    uint32_t bits;
} TIM2_af1_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_af1_t, sizeof(uint32_t));

/**
 * TI1[0] to TI1[15] input selection These bits select the TI1[0] to TI1[15]
 * input source. Others: Reserved
 */
typedef enum TIM2_ti1sel_e {
    /// TIM2_CH1 input
    TIM2_ti1sel_b_0x0 = 0x00,
    /// COMP1 output
    TIM2_ti1sel_b_0x1 = 0x01,
} TIM2_ti1sel_t;

/**
 * TI2[0] to TI2[15] input selection These bits select the TI2[0] to TI2[15]
 * input source. Others: Reserved
 */
typedef enum TIM2_ti2sel_e {
    /// TIM2_CH2 input
    TIM2_ti2sel_b_0x0 = 0x00,
    /// COMP2 output
    TIM2_ti2sel_b_0x1 = 0x01,
} TIM2_ti2sel_t;

/**
 * TIM alternate function option register 1
 */
typedef union TIM2_tisel_u {
    struct {
        /// TI1[0] to TI1[15] input selection These bits select the TI1[0] to
        /// TI1[15] input source. Others: Reserved
        TIM2_ti1sel_t  ti1sel : 4;
        uint32_t const reserved_04 : 4;
        /// TI2[0] to TI2[15] input selection These bits select the TI2[0] to
        /// TI2[15] input source. Others: Reserved
        TIM2_ti2sel_t ti2sel : 4;
    };
    uint32_t bits;
} TIM2_tisel_t;
STATIC_ASSERT_TYPE_SIZE(TIM2_tisel_t, sizeof(uint32_t));

/**
 * General-purpose-timers
 */
typedef struct TIM2_peripheral_registers_s {
    /// control register 1
    TIM2_cr1_t cr1;
    /// control register 2
    TIM2_cr2_t cr2;
    /// slave mode control register
    TIM2_smcr_t smcr;
    /// DMA/Interrupt enable register
    TIM2_dier_t dier;
    /// status register
    TIM2_sr_t sr;
    /// event generation register
    TIM2_egr_t egr;
    union {
        /// capture/compare mode register 1 (input mode)
        TIM2_ccmr1_input_t ccmr1_input;
        /// capture/compare mode register 1 (output mode)
        TIM2_ccmr1_output_t ccmr1_output;
    };
    union {
        /// capture/compare mode register 2 (input mode)
        TIM2_ccmr2_input_t ccmr2_input;
        /// capture/compare mode register 2 (output mode)
        TIM2_ccmr2_output_t ccmr2_output;
    };
    /// capture/compare enable register
    TIM2_ccer_t ccer;
    union {
        /// counter
        TIM2_cnt_t cnt;
        /// counter
        TIM2_cnt_alternate5_t cnt_alternate5;
    };
    /// prescaler
    TIM2_psc_t psc;
    /// auto-reload register
    TIM2_arr_t    arr;
    uint8_t const reserved_0x30[4];
    /// capture/compare register 1
    TIM2_ccr1_t ccr1;
    /// capture/compare register 2
    TIM2_ccr2_t ccr2;
    /// capture/compare register 3
    TIM2_ccr3_t ccr3;
    /// capture/compare register 4
    TIM2_ccr4_t   ccr4;
    uint8_t const reserved_0x44[4];
    /// DMA control register
    TIM2_dcr_t dcr;
    /// DMA address for full transfer
    TIM2_dmar_t dmar;
    /// TIM option register
    TIM2_or1_t    or1;
    uint8_t const reserved_0x54[12];
    /// TIM alternate function option register 1
    TIM2_af1_t    af1;
    uint8_t const reserved_0x64[4];
    /// TIM alternate function option register 1
    TIM2_tisel_t tisel;
} TIM2_peripheral_registers_t;
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, cr1, 0x00);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, cr2, 0x04);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, smcr, 0x08);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, dier, 0x0C);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, sr, 0x10);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, egr, 0x14);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, ccmr1_output, 0x18);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, ccmr1_input, 0x18);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, ccmr2_output, 0x1C);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, ccmr2_input, 0x1C);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, ccer, 0x20);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, cnt, 0x24);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, cnt_alternate5, 0x24);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, psc, 0x28);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, arr, 0x2C);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, ccr1, 0x34);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, ccr2, 0x38);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, ccr3, 0x3C);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, ccr4, 0x40);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, dcr, 0x48);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, dmar, 0x4C);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, or1, 0x50);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, af1, 0x60);
STATIC_ASSERT_MEMBER_OFFSET(TIM2_peripheral_registers_t, tisel, 0x68);

#ifdef __cplusplus
}
#endif
#endif // TIM2_H_

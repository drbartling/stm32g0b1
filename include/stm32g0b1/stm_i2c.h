/**
 * @file
 * @version 1.6
 *
 * Inter-integrated circuit
 *
 * @note This file is autogenerated using register-code-gen
 */

#ifndef I2C1_H_
#define I2C1_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "static_assert.h"

#include <stdint.h>

/**
 * Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released.
 * Internal state machines and status bits are put back to their reset value.
 * When cleared, PE must be kept low for at least 3 APB clock cycles.
 */
typedef enum I2C1_pe_e {
    /// Peripheral disable
    I2C1_pe_b_0x0 = 0x0,
    /// Peripheral enable
    I2C1_pe_b_0x1 = 0x1,
} I2C1_pe_t;

/**
 * TX Interrupt enable
 */
typedef enum I2C1_txie_e {
    /// Transmit (TXIS) interrupt disabled
    I2C1_txie_b_0x0 = 0x0,
    /// Transmit (TXIS) interrupt enabled
    I2C1_txie_b_0x1 = 0x1,
} I2C1_txie_t;

/**
 * RX Interrupt enable
 */
typedef enum I2C1_rxie_e {
    /// Receive (RXNE) interrupt disabled
    I2C1_rxie_b_0x0 = 0x0,
    /// Receive (RXNE) interrupt enabled
    I2C1_rxie_b_0x1 = 0x1,
} I2C1_rxie_t;

/**
 * Address match Interrupt enable (slave only)
 */
typedef enum I2C1_addrie_e {
    /// Address match (ADDR) interrupts disabled
    I2C1_addrie_b_0x0 = 0x0,
    /// Address match (ADDR) interrupts enabled
    I2C1_addrie_b_0x1 = 0x1,
} I2C1_addrie_t;

/**
 * Not acknowledge received Interrupt enable
 */
typedef enum I2C1_nackie_e {
    /// Not acknowledge (NACKF) received interrupts disabled
    I2C1_nackie_b_0x0 = 0x0,
    /// Not acknowledge (NACKF) received interrupts enabled
    I2C1_nackie_b_0x1 = 0x1,
} I2C1_nackie_t;

/**
 * Stop detection Interrupt enable
 */
typedef enum I2C1_stopie_e {
    /// Stop detection (STOPF) interrupt disabled
    I2C1_stopie_b_0x0 = 0x0,
    /// Stop detection (STOPF) interrupt enabled
    I2C1_stopie_b_0x1 = 0x1,
} I2C1_stopie_t;

/**
 * Transfer Complete interrupt enable Note: Any of these events generate an
 * interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
 */
typedef enum I2C1_tcie_e {
    /// Transfer Complete interrupt disabled
    I2C1_tcie_b_0x0 = 0x0,
    /// Transfer Complete interrupt enabled
    I2C1_tcie_b_0x1 = 0x1,
} I2C1_tcie_t;

/**
 * Error interrupts enable Note: Any of these errors generate an interrupt:
 * Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR)
 * Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event
 * detection (ALERT)
 */
typedef enum I2C1_errie_e {
    /// Error detection interrupts disabled
    I2C1_errie_b_0x0 = 0x0,
    /// Error detection interrupts enabled
    I2C1_errie_b_0x1 = 0x1,
} I2C1_errie_t;

/**
 * Digital noise filter These bits are used to configure the digital noise
 * filter on SDA and SCL input. The digital filter, filters spikes with a length
 * of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled,
 * the digital filter is added to the analog filter. This filter can only be
 * programmed when the I2C is disabled (PE = 0).
 */
typedef enum I2C1_dnf_e {
    /// Digital filter disabled
    I2C1_dnf_b_0x0 = 0x00,
    /// Digital filter enabled and filtering capability up to 1 tI2CCLK
    I2C1_dnf_b_0x1 = 0x01,
    /// digital filter enabled and filtering capability up to15 tI2CCLK
    I2C1_dnf_b_0xf = 0x0F,
} I2C1_dnf_t;

/**
 * Analog noise filter OFF Note: This bit can only be programmed when the I2C is
 * disabled (PE = 0).
 */
typedef enum I2C1_anfoff_e {
    /// Analog noise filter enabled
    I2C1_anfoff_b_0x0 = 0x0,
    /// Analog noise filter disabled
    I2C1_anfoff_b_0x1 = 0x1,
} I2C1_anfoff_t;

/**
 * DMA transmission requests enable
 */
typedef enum I2C1_txdmaen_e {
    /// DMA mode disabled for transmission
    I2C1_txdmaen_b_0x0 = 0x0,
    /// DMA mode enabled for transmission
    I2C1_txdmaen_b_0x1 = 0x1,
} I2C1_txdmaen_t;

/**
 * DMA reception requests enable
 */
typedef enum I2C1_rxdmaen_e {
    /// DMA mode disabled for reception
    I2C1_rxdmaen_b_0x0 = 0x0,
    /// DMA mode enabled for reception
    I2C1_rxdmaen_b_0x1 = 0x1,
} I2C1_rxdmaen_t;

/**
 * Slave byte control This bit is used to enable hardware byte control in slave
 * mode.
 */
typedef enum I2C1_sbc_e {
    /// Slave byte control disabled
    I2C1_sbc_b_0x0 = 0x0,
    /// Slave byte control enabled
    I2C1_sbc_b_0x1 = 0x1,
} I2C1_sbc_t;

/**
 * Clock stretching disable This bit is used to disable clock stretching in
 * slave mode. It must be kept cleared in master mode. Note: This bit can only
 * be programmed when the I2C is disabled (PE = 0).
 */
typedef enum I2C1_nostretch_e {
    /// Clock stretching enabled
    I2C1_nostretch_b_0x0 = 0x0,
    /// Clock stretching disabled
    I2C1_nostretch_b_0x1 = 0x1,
} I2C1_nostretch_t;

/**
 * Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is
 * not supported, this bit is reserved and forced by hardware to '0â. Refer
 * to . Note: WUPEN can be set only when DNF = '0000â
 */
typedef enum I2C1_wupen_e {
    /// Wakeup from Stop mode disable.
    I2C1_wupen_b_0x0 = 0x0,
    /// Wakeup from Stop mode enable.
    I2C1_wupen_b_0x1 = 0x1,
} I2C1_wupen_t;

/**
 * General call enable
 */
typedef enum I2C1_gcen_e {
    /// General call disabled. Address 0b00000000 is NACKed.
    I2C1_gcen_b_0x0 = 0x0,
    /// General call enabled. Address 0b00000000 is ACKed.
    I2C1_gcen_b_0x1 = 0x1,
} I2C1_gcen_t;

/**
 * SMBus Host Address enable Note: If the SMBus feature is not supported, this
 * bit is reserved and forced by hardware to '0â. Refer to .
 */
typedef enum I2C1_smbhen_e {
    /// Host Address disabled. Address 0b0001000x is NACKed.
    I2C1_smbhen_b_0x0 = 0x0,
    /// Host Address enabled. Address 0b0001000x is ACKed.
    I2C1_smbhen_b_0x1 = 0x1,
} I2C1_smbhen_t;

/**
 * SMBus Device Default Address enable Note: If the SMBus feature is not
 * supported, this bit is reserved and forced by hardware to '0â. Refer to
 * .
 */
typedef enum I2C1_smbden_e {
    /// Device Default Address disabled. Address 0b1100001x is NACKed.
    I2C1_smbden_b_0x0 = 0x0,
    /// Device Default Address enabled. Address 0b1100001x is ACKed.
    I2C1_smbden_b_0x1 = 0x1,
} I2C1_smbden_t;

/**
 * SMBus alert enable Note: When ALERTEN=0, the SMBA pin can be used as a
 * standard GPIO. If the SMBus feature is not supported, this bit is reserved
 * and forced by hardware to '0â. Refer to .
 */
typedef enum I2C1_alerten_e {
    /// The SMBus alert pin (SMBA) is not supported in host mode (SMBHEN=1). In
    /// device mode (SMBHEN=0), the SMBA pin is released and the Alert Response
    /// Address header is disabled (0001100x followed by NACK).
    I2C1_alerten_b_0x0 = 0x0,
    /// The SMBus alert pin is supported in host mode (SMBHEN=1). In device mode
    /// (SMBHEN=0), the SMBA pin is driven low and the Alert Response Address
    /// header is enabled (0001100x followed by ACK).
    I2C1_alerten_b_0x1 = 0x1,
} I2C1_alerten_t;

/**
 * PEC enable Note: If the SMBus feature is not supported, this bit is reserved
 * and forced by hardware to '0â. Refer to .
 */
typedef enum I2C1_pecen_e {
    /// PEC calculation disabled
    I2C1_pecen_b_0x0 = 0x0,
    /// PEC calculation enabled
    I2C1_pecen_b_0x1 = 0x1,
} I2C1_pecen_t;

/**
 * Control register 1
 */
typedef union I2C1_i2c_cr1_u {
    struct {
        /// Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are
        /// released. Internal state machines and status bits are put back to
        /// their reset value. When cleared, PE must be kept low for at least 3
        /// APB clock cycles.
        I2C1_pe_t pe : 1;
        /// TX Interrupt enable
        I2C1_txie_t txie : 1;
        /// RX Interrupt enable
        I2C1_rxie_t rxie : 1;
        /// Address match Interrupt enable (slave only)
        I2C1_addrie_t addrie : 1;
        /// Not acknowledge received Interrupt enable
        I2C1_nackie_t nackie : 1;
        /// Stop detection Interrupt enable
        I2C1_stopie_t stopie : 1;
        /// Transfer Complete interrupt enable Note: Any of these events
        /// generate an interrupt: Transfer Complete (TC) Transfer Complete
        /// Reload (TCR)
        I2C1_tcie_t tcie : 1;
        /// Error interrupts enable Note: Any of these errors generate an
        /// interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR)
        /// Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error
        /// detection (PECERR) Alert pin event detection (ALERT)
        I2C1_errie_t errie : 1;
        /// Digital noise filter These bits are used to configure the digital
        /// noise filter on SDA and SCL input. The digital filter, filters
        /// spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the
        /// analog filter is also enabled, the digital filter is added to the
        /// analog filter. This filter can only be programmed when the I2C is
        /// disabled (PE = 0).
        I2C1_dnf_t dnf : 4;
        /// Analog noise filter OFF Note: This bit can only be programmed when
        /// the I2C is disabled (PE = 0).
        I2C1_anfoff_t  anfoff : 1;
        uint32_t const reserved_13 : 1;
        /// DMA transmission requests enable
        I2C1_txdmaen_t txdmaen : 1;
        /// DMA reception requests enable
        I2C1_rxdmaen_t rxdmaen : 1;
        /// Slave byte control This bit is used to enable hardware byte control
        /// in slave mode.
        I2C1_sbc_t sbc : 1;
        /// Clock stretching disable This bit is used to disable clock
        /// stretching in slave mode. It must be kept cleared in master mode.
        /// Note: This bit can only be programmed when the I2C is disabled (PE =
        /// 0).
        I2C1_nostretch_t nostretch : 1;
        /// Wakeup from Stop mode enable Note: If the Wakeup from Stop mode
        /// feature is not supported, this bit is reserved and forced by
        /// hardware to '0â. Refer to . Note: WUPEN can be set only when
        /// DNF = '0000â
        I2C1_wupen_t wupen : 1;
        /// General call enable
        I2C1_gcen_t gcen : 1;
        /// SMBus Host Address enable Note: If the SMBus feature is not
        /// supported, this bit is reserved and forced by hardware to '0â.
        /// Refer to .
        I2C1_smbhen_t smbhen : 1;
        /// SMBus Device Default Address enable Note: If the SMBus feature is
        /// not supported, this bit is reserved and forced by hardware to
        /// '0â. Refer to .
        I2C1_smbden_t smbden : 1;
        /// SMBus alert enable Note: When ALERTEN=0, the SMBA pin can be used as
        /// a standard GPIO. If the SMBus feature is not supported, this bit is
        /// reserved and forced by hardware to '0â. Refer to .
        I2C1_alerten_t alerten : 1;
        /// PEC enable Note: If the SMBus feature is not supported, this bit is
        /// reserved and forced by hardware to '0â. Refer to .
        I2C1_pecen_t pecen : 1;
    };
    uint32_t bits;
} I2C1_i2c_cr1_t;
STATIC_ASSERT_TYPE_SIZE(I2C1_i2c_cr1_t, sizeof(uint32_t));

/**
 * Transfer direction (master mode) Note: Changing this bit when the START bit
 * is set is not allowed.
 */
typedef enum I2C1_rd_wrn_e {
    /// Master requests a write transfer.
    I2C1_rd_wrn_b_0x0 = 0x0,
    /// Master requests a read transfer.
    I2C1_rd_wrn_b_0x1 = 0x1,
} I2C1_rd_wrn_t;

/**
 * 10-bit addressing mode (master mode) Note: Changing this bit when the START
 * bit is set is not allowed.
 */
typedef enum I2C1_add10_e {
    /// The master operates in 7-bit addressing mode,
    I2C1_add10_b_0x0 = 0x0,
    /// The master operates in 10-bit addressing mode
    I2C1_add10_b_0x1 = 0x1,
} I2C1_add10_t;

/**
 * 10-bit address header only read direction (master receiver mode) Note:
 * Changing this bit when the START bit is set is not allowed.
 */
typedef enum I2C1_head10r_e {
    /// The master sends the complete 10 bit slave address read sequence: Start
    /// + 2 bytes 10bit address in write direction + Restart + 1st 7 bits of the
    /// 10 bit address in read direction.
    I2C1_head10r_b_0x0 = 0x0,
    /// The master only sends the 1st 7 bits of the 10 bit address, followed by
    /// Read direction.
    I2C1_head10r_b_0x1 = 0x1,
} I2C1_head10r_t;

/**
 * Start generation This bit is set by software, and cleared by hardware after
 * the Start followed by the address sequence is sent, by an arbitration loss,
 * by a timeout error detection, or when PE = 0. It can also be cleared by
 * software by writing '1â to the ADDRCF bit in the I2C_ICR register. If
 * the I2C is already in master mode with AUTOEND = 0, setting this bit
 * generates a Repeated Start condition when RELOAD=0, after the end of the
 * NBYTES transfer. Otherwise setting this bit generates a START condition once
 * the bus is free. Note: Writing '0â to this bit has no effect. The START
 * bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has
 * no effect when RELOAD is set.
 */
typedef enum I2C1_start_e {
    /// No Start generation.
    I2C1_start_b_0x0 = 0x0,
    /// Restart/Start generation:
    I2C1_start_b_0x1 = 0x1,
} I2C1_start_t;

/**
 * Stop generation (master mode) The bit is set by software, cleared by hardware
 * when a STOP condition is detected, or when PE = 0. In Master Mode: Note:
 * Writing '0â to this bit has no effect.
 */
typedef enum I2C1_stop_e {
    /// No Stop generation.
    I2C1_stop_b_0x0 = 0x0,
    /// Stop generation after current byte transfer.
    I2C1_stop_b_0x1 = 0x1,
} I2C1_stop_t;

/**
 * NACK generation (slave mode) The bit is set by software, cleared by hardware
 * when the NACK is sent, or when a STOP condition or an Address matched is
 * received, or when PE=0. Note: Writing '0â to this bit has no effect.
 * This bit is used in slave mode only: in master receiver mode, NACK is
 * automatically generated after last byte preceding STOP or RESTART condition,
 * whatever the NACK bit value. When an overrun occurs in slave receiver
 * NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit
 * value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge
 * value does not depend on the NACK value.
 */
typedef enum I2C1_nack_e {
    /// an ACK is sent after current received byte.
    I2C1_nack_b_0x0 = 0x0,
    /// a NACK is sent after current received byte.
    I2C1_nack_b_0x1 = 0x1,
} I2C1_nack_t;

/**
 * NBYTES reload mode This bit is set and cleared by software.
 */
typedef enum I2C1_reload_e {
    /// The transfer is completed after the NBYTES data transfer (STOP or
    /// RESTART follows).
    I2C1_reload_b_0x0 = 0x0,
    /// The transfer is not completed after the NBYTES data transfer (NBYTES is
    /// reloaded). TCR flag is set when NBYTES data are transferred, stretching
    /// SCL low.
    I2C1_reload_b_0x1 = 0x1,
} I2C1_reload_t;

/**
 * Automatic end mode (master mode) This bit is set and cleared by software.
 * Note: This bit has no effect in slave mode or when the RELOAD bit is set.
 */
typedef enum I2C1_autoend_e {
    /// software end mode: TC flag is set when NBYTES data are transferred,
    /// stretching SCL low.
    I2C1_autoend_b_0x0 = 0x0,
    /// Automatic end mode: a STOP condition is automatically sent when NBYTES
    /// data are transferred.
    I2C1_autoend_b_0x1 = 0x1,
} I2C1_autoend_t;

/**
 * Packet error checking byte This bit is set by software, and cleared by
 * hardware when the PEC is transferred, or when a STOP condition or an Address
 * matched is received, also when PE=0. Note: Writing '0â to this bit has
 * no effect. This bit has no effect when RELOAD is set. This bit has no effect
 * is slave mode when SBC=0. If the SMBus feature is not supported, this bit is
 * reserved and forced by hardware to '0â. Refer to .
 */
typedef enum I2C1_pecbyte_e {
    /// No PEC transfer.
    I2C1_pecbyte_b_0x0 = 0x0,
    /// PEC transmission/reception is requested
    I2C1_pecbyte_b_0x1 = 0x1,
} I2C1_pecbyte_t;

/**
 * Control register 2
 */
typedef union I2C1_i2c_cr2_u {
    struct {
        /// Slave address (master mode) In 7-bit addressing mode (ADD10 = 0):
        /// SADD[7:1] should be written with the 7-bit slave address to be sent.
        /// The bits SADD[9], SADD[8] and SADD[0] are don't care. In 10-bit
        /// addressing mode (ADD10 = 1): SADD[9:0] should be written with the
        /// 10-bit slave address to be sent. Note: Changing these bits when the
        /// START bit is set is not allowed.
        uint32_t sadd : 10;
        /// Transfer direction (master mode) Note: Changing this bit when the
        /// START bit is set is not allowed.
        I2C1_rd_wrn_t rd_wrn : 1;
        /// 10-bit addressing mode (master mode) Note: Changing this bit when
        /// the START bit is set is not allowed.
        I2C1_add10_t add10 : 1;
        /// 10-bit address header only read direction (master receiver mode)
        /// Note: Changing this bit when the START bit is set is not allowed.
        I2C1_head10r_t head10r : 1;
        /// Start generation This bit is set by software, and cleared by
        /// hardware after the Start followed by the address sequence is sent,
        /// by an arbitration loss, by a timeout error detection, or when PE =
        /// 0. It can also be cleared by software by writing '1â to the
        /// ADDRCF bit in the I2C_ICR register. If the I2C is already in master
        /// mode with AUTOEND = 0, setting this bit generates a Repeated Start
        /// condition when RELOAD=0, after the end of the NBYTES transfer.
        /// Otherwise setting this bit generates a START condition once the bus
        /// is free. Note: Writing '0â to this bit has no effect. The START
        /// bit can be set even if the bus is BUSY or I2C is in slave mode. This
        /// bit has no effect when RELOAD is set.
        I2C1_start_t start : 1;
        /// Stop generation (master mode) The bit is set by software, cleared by
        /// hardware when a STOP condition is detected, or when PE = 0. In
        /// Master Mode: Note: Writing '0â to this bit has no effect.
        I2C1_stop_t stop : 1;
        /// NACK generation (slave mode) The bit is set by software, cleared by
        /// hardware when the NACK is sent, or when a STOP condition or an
        /// Address matched is received, or when PE=0. Note: Writing '0â to
        /// this bit has no effect. This bit is used in slave mode only: in
        /// master receiver mode, NACK is automatically generated after last
        /// byte preceding STOP or RESTART condition, whatever the NACK bit
        /// value. When an overrun occurs in slave receiver NOSTRETCH mode, a
        /// NACK is automatically generated whatever the NACK bit value. When
        /// hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge
        /// value does not depend on the NACK value.
        I2C1_nack_t nack : 1;
        /// Number of bytes The number of bytes to be transmitted/received is
        /// programmed there. This field is donât care in slave mode with
        /// SBC=0. Note: Changing these bits when the START bit is set is not
        /// allowed.
        uint32_t nbytes : 8;
        /// NBYTES reload mode This bit is set and cleared by software.
        I2C1_reload_t reload : 1;
        /// Automatic end mode (master mode) This bit is set and cleared by
        /// software. Note: This bit has no effect in slave mode or when the
        /// RELOAD bit is set.
        I2C1_autoend_t autoend : 1;
        /// Packet error checking byte This bit is set by software, and cleared
        /// by hardware when the PEC is transferred, or when a STOP condition or
        /// an Address matched is received, also when PE=0. Note: Writing
        /// '0â to this bit has no effect. This bit has no effect when
        /// RELOAD is set. This bit has no effect is slave mode when SBC=0. If
        /// the SMBus feature is not supported, this bit is reserved and forced
        /// by hardware to '0â. Refer to .
        I2C1_pecbyte_t pecbyte : 1;
    };
    uint32_t bits;
} I2C1_i2c_cr2_t;
STATIC_ASSERT_TYPE_SIZE(I2C1_i2c_cr2_t, sizeof(uint32_t));

/**
 * Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
 */
typedef enum I2C1_oa1mode_e {
    /// Own address 1 is a 7-bit address.
    I2C1_oa1mode_b_0x0 = 0x0,
    /// Own address 1 is a 10-bit address.
    I2C1_oa1mode_b_0x1 = 0x1,
} I2C1_oa1mode_t;

/**
 * Own Address 1 enable
 */
typedef enum I2C1_oa1en_e {
    /// Own address 1 disabled. The received slave address OA1 is NACKed.
    I2C1_oa1en_b_0x0 = 0x0,
    /// Own address 1 enabled. The received slave address OA1 is ACKed.
    I2C1_oa1en_b_0x1 = 0x1,
} I2C1_oa1en_t;

/**
 * Own address register 1
 */
typedef union I2C1_i2c_oar1_u {
    struct {
        /// Interface own slave address 7-bit addressing mode: OA1[7:1] contains
        /// the 7-bit own slave address. The bits OA1[9], OA1[8] and OA1[0] are
        /// don't care. 10-bit addressing mode: OA1[9:0] contains the 10-bit own
        /// slave address. Note: These bits can be written only when OA1EN=0.
        uint32_t oa1 : 10;
        /// Own Address 1 10-bit mode Note: This bit can be written only when
        /// OA1EN=0.
        I2C1_oa1mode_t oa1mode : 1;
        uint32_t const reserved_11 : 4;
        /// Own Address 1 enable
        I2C1_oa1en_t oa1en : 1;
    };
    uint32_t bits;
} I2C1_i2c_oar1_t;
STATIC_ASSERT_TYPE_SIZE(I2C1_i2c_oar1_t, sizeof(uint32_t));

/**
 * Own Address 2 masks Note: These bits can be written only when OA2EN=0. As
 * soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and
 * 0b1111xxx) are not acknowledged even if the comparison matches.
 */
typedef enum I2C1_oa2msk_e {
    /// No mask
    I2C1_oa2msk_b_0x0 = 0x0,
    /// OA2[1] is masked and donât care. Only OA2[7:2] are compared.
    I2C1_oa2msk_b_0x1 = 0x1,
    /// OA2[2:1] are masked and donât care. Only OA2[7:3] are compared.
    I2C1_oa2msk_b_0x2 = 0x2,
    /// OA2[3:1] are masked and donât care. Only OA2[7:4] are compared.
    I2C1_oa2msk_b_0x3 = 0x3,
    /// OA2[4:1] are masked and donât care. Only OA2[7:5] are compared.
    I2C1_oa2msk_b_0x4 = 0x4,
    /// OA2[5:1] are masked and donât care. Only OA2[7:6] are compared.
    I2C1_oa2msk_b_0x5 = 0x5,
    /// OA2[6:1] are masked and donât care. Only OA2[7] is compared.
    I2C1_oa2msk_b_0x6 = 0x6,
    /// OA2[7:1] are masked and donât care. No comparison is done, and all
    /// (except reserved) 7-bit received addresses are acknowledged.
    I2C1_oa2msk_b_0x7 = 0x7,
} I2C1_oa2msk_t;

/**
 * Own Address 2 enable
 */
typedef enum I2C1_oa2en_e {
    /// Own address 2 disabled. The received slave address OA2 is NACKed.
    I2C1_oa2en_b_0x0 = 0x0,
    /// Own address 2 enabled. The received slave address OA2 is ACKed.
    I2C1_oa2en_b_0x1 = 0x1,
} I2C1_oa2en_t;

/**
 * Own address register 2
 */
typedef union I2C1_i2c_oar2_u {
    struct {
        uint32_t const reserved_00 : 1;
        /// Interface address 7-bit addressing mode: 7-bit address Note: These
        /// bits can be written only when OA2EN=0.
        uint32_t oa2 : 7;
        /// Own Address 2 masks Note: These bits can be written only when
        /// OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C
        /// addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the
        /// comparison matches.
        I2C1_oa2msk_t  oa2msk : 3;
        uint32_t const reserved_11 : 4;
        /// Own Address 2 enable
        I2C1_oa2en_t oa2en : 1;
    };
    uint32_t bits;
} I2C1_i2c_oar2_t;
STATIC_ASSERT_TYPE_SIZE(I2C1_i2c_oar2_t, sizeof(uint32_t));

/**
 * Timing register
 */
typedef union I2C1_i2c_timingr_u {
    struct {
        /// SCL low period (master mode)
        uint32_t scll : 8;
        /// SCL high period (master mode)
        uint32_t sclh : 8;
        /// Data hold time
        uint32_t sdadel : 4;
        /// Data setup time
        uint32_t       scldel : 4;
        uint32_t const reserved_24 : 4;
        /// Timing prescaler
        uint32_t presc : 4;
    };
    uint32_t bits;
} I2C1_i2c_timingr_t;
STATIC_ASSERT_TYPE_SIZE(I2C1_i2c_timingr_t, sizeof(uint32_t));

/**
 * Idle clock timeout detection Note: This bit can be written only when
 * TIMOUTEN=0.
 */
typedef enum I2C1_tidle_e {
    /// TIMEOUTA is used to detect SCL low timeout
    I2C1_tidle_b_0x0 = 0x0,
    /// TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle
    /// condition)
    I2C1_tidle_b_0x1 = 0x1,
} I2C1_tidle_t;

/**
 * Clock timeout enable
 */
typedef enum I2C1_timouten_e {
    /// SCL timeout detection is disabled
    I2C1_timouten_b_0x0 = 0x0,
    /// SCL timeout detection is enabled: when SCL is low for more than tTIMEOUT
    /// (TIDLE=0) or high for more than tIDLE (TIDLE=1), a timeout error is
    /// detected (TIMEOUT=1).
    I2C1_timouten_b_0x1 = 0x1,
} I2C1_timouten_t;

/**
 * Extended clock timeout enable
 */
typedef enum I2C1_texten_e {
    /// Extended clock timeout detection is disabled
    I2C1_texten_b_0x0 = 0x0,
    /// Extended clock timeout detection is enabled. When a cumulative SCL
    /// stretch for more than tLOW:EXT is done by the I2C interface, a timeout
    /// error is detected (TIMEOUT=1).
    I2C1_texten_b_0x1 = 0x1,
} I2C1_texten_t;

/**
 * Status register 1
 */
typedef union I2C1_i2c_timeoutr_u {
    struct {
        /// Bus Timeout A This field is used to configure: The SCL low timeout
        /// condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x
        /// tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1
        /// tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written
        /// only when TIMOUTEN=0.
        uint32_t timeouta : 12;
        /// Idle clock timeout detection Note: This bit can be written only when
        /// TIMOUTEN=0.
        I2C1_tidle_t   tidle : 1;
        uint32_t const reserved_13 : 2;
        /// Clock timeout enable
        I2C1_timouten_t timouten : 1;
        /// Bus timeout B This field is used to configure the cumulative clock
        /// extension timeout: In master mode, the master cumulative clock low
        /// extend time (tLOW:MEXT) is detected In slave mode, the slave
        /// cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT=
        /// (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only
        /// when TEXTEN=0.
        uint32_t       timeoutb : 12;
        uint32_t const reserved_28 : 3;
        /// Extended clock timeout enable
        I2C1_texten_t texten : 1;
    };
    uint32_t bits;
} I2C1_i2c_timeoutr_t;
STATIC_ASSERT_TYPE_SIZE(I2C1_i2c_timeoutr_t, sizeof(uint32_t));

/**
 * Transfer direction (Slave mode) This flag is updated when an address match
 * event occurs (ADDR=1).
 */
typedef enum I2C1_dir_e {
    /// Write transfer, slave enters receiver mode.
    I2C1_dir_b_0x0 = 0x0,
    /// Read transfer, slave enters transmitter mode.
    I2C1_dir_b_0x1 = 0x1,
} I2C1_dir_t;

/**
 * Interrupt and Status register
 */
typedef union I2C1_i2c_isr_u {
    struct {
        /// Transmit data register empty (transmitters)
        uint32_t txe : 1;
        /// Transmit interrupt status (transmitters)
        uint32_t txis : 1;
        /// Receive data register not empty (receivers)
        uint32_t const rxne : 1;
        /// Address matched (slave mode)
        uint32_t const addr : 1;
        /// Not acknowledge received flag
        uint32_t const nackf : 1;
        /// Stop detection flag
        uint32_t const stopf : 1;
        /// Transfer Complete (master mode)
        uint32_t const tc : 1;
        /// Transfer Complete Reload
        uint32_t const tcr : 1;
        /// Bus error
        uint32_t const berr : 1;
        /// Arbitration lost
        uint32_t const arlo : 1;
        /// Overrun/Underrun (slave mode)
        uint32_t const ovr : 1;
        /// PEC Error in reception
        uint32_t const pecerr : 1;
        /// Timeout or t_low detection flag
        uint32_t const timeout : 1;
        /// SMBus alert
        uint32_t const alert : 1;
        uint32_t const reserved_14 : 1;
        /// Bus busy
        uint32_t const busy : 1;
        /// Transfer direction (Slave mode) This flag is updated when an address
        /// match event occurs (ADDR=1).
        I2C1_dir_t const dir : 1;
        /// Address match code (Slave mode)
        uint32_t const addcode : 7;
    };
    uint32_t bits;
} I2C1_i2c_isr_t;
STATIC_ASSERT_TYPE_SIZE(I2C1_i2c_isr_t, sizeof(uint32_t));

/**
 * Interrupt clear register
 */
typedef union I2C1_i2c_icr_u {
    struct {
        uint32_t const reserved_00 : 3;
        /// Address Matched flag clear
        uint32_t addrcf : 1;
        /// Not Acknowledge flag clear
        uint32_t nackcf : 1;
        /// Stop detection flag clear
        uint32_t       stopcf : 1;
        uint32_t const reserved_06 : 2;
        /// Bus error flag clear
        uint32_t berrcf : 1;
        /// Arbitration lost flag clear
        uint32_t arlocf : 1;
        /// Overrun/Underrun flag clear
        uint32_t ovrcf : 1;
        /// PEC Error flag clear
        uint32_t peccf : 1;
        /// Timeout detection flag clear
        uint32_t timoutcf : 1;
        /// Alert flag clear
        uint32_t alertcf : 1;
    };
    uint32_t bits;
} I2C1_i2c_icr_t;
STATIC_ASSERT_TYPE_SIZE(I2C1_i2c_icr_t, sizeof(uint32_t));

/**
 * PEC register
 */
typedef union I2C1_i2c_pecr_u {
    struct {
        /// Packet error checking register
        uint32_t const pec : 8;
    };
    uint32_t bits;
} I2C1_i2c_pecr_t;
STATIC_ASSERT_TYPE_SIZE(I2C1_i2c_pecr_t, sizeof(uint32_t));

/**
 * Receive data register
 */
typedef union I2C1_i2c_rxdr_u {
    struct {
        /// 8-bit receive data
        uint32_t const rxdata : 8;
    };
    uint32_t bits;
} I2C1_i2c_rxdr_t;
STATIC_ASSERT_TYPE_SIZE(I2C1_i2c_rxdr_t, sizeof(uint32_t));

/**
 * Transmit data register
 */
typedef union I2C1_i2c_txdr_u {
    struct {
        /// 8-bit transmit data
        uint32_t txdata : 8;
    };
    uint32_t bits;
} I2C1_i2c_txdr_t;
STATIC_ASSERT_TYPE_SIZE(I2C1_i2c_txdr_t, sizeof(uint32_t));

/**
 * Inter-integrated circuit
 */
typedef struct I2C1_peripheral_registers_s {
    /// Control register 1
    I2C1_i2c_cr1_t i2c_cr1;
    /// Control register 2
    I2C1_i2c_cr2_t i2c_cr2;
    /// Own address register 1
    I2C1_i2c_oar1_t i2c_oar1;
    /// Own address register 2
    I2C1_i2c_oar2_t i2c_oar2;
    /// Timing register
    I2C1_i2c_timingr_t i2c_timingr;
    /// Status register 1
    I2C1_i2c_timeoutr_t i2c_timeoutr;
    /// Interrupt and Status register
    I2C1_i2c_isr_t i2c_isr;
    /// Interrupt clear register
    I2C1_i2c_icr_t i2c_icr;
    /// PEC register
    I2C1_i2c_pecr_t i2c_pecr;
    /// Receive data register
    I2C1_i2c_rxdr_t i2c_rxdr;
    /// Transmit data register
    I2C1_i2c_txdr_t i2c_txdr;
} I2C1_peripheral_registers_t;
STATIC_ASSERT_MEMBER_OFFSET(I2C1_peripheral_registers_t, i2c_cr1, 0x00);
STATIC_ASSERT_MEMBER_OFFSET(I2C1_peripheral_registers_t, i2c_cr2, 0x04);
STATIC_ASSERT_MEMBER_OFFSET(I2C1_peripheral_registers_t, i2c_oar1, 0x08);
STATIC_ASSERT_MEMBER_OFFSET(I2C1_peripheral_registers_t, i2c_oar2, 0x0C);
STATIC_ASSERT_MEMBER_OFFSET(I2C1_peripheral_registers_t, i2c_timingr, 0x10);
STATIC_ASSERT_MEMBER_OFFSET(I2C1_peripheral_registers_t, i2c_timeoutr, 0x14);
STATIC_ASSERT_MEMBER_OFFSET(I2C1_peripheral_registers_t, i2c_isr, 0x18);
STATIC_ASSERT_MEMBER_OFFSET(I2C1_peripheral_registers_t, i2c_icr, 0x1C);
STATIC_ASSERT_MEMBER_OFFSET(I2C1_peripheral_registers_t, i2c_pecr, 0x20);
STATIC_ASSERT_MEMBER_OFFSET(I2C1_peripheral_registers_t, i2c_rxdr, 0x24);
STATIC_ASSERT_MEMBER_OFFSET(I2C1_peripheral_registers_t, i2c_txdr, 0x28);

#ifdef __cplusplus
}
#endif
#endif // I2C1_H_

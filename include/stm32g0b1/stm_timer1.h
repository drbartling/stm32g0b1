/**
 * @file
 * @version 1.6
 * @brief Register access structs for STM TIM1
 *
 * Advanced-timers
 *
 * @note This file is autogenerated using register-code-gen
 */

#ifndef TIM1_H_
#define TIM1_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "static_assert.h"

#include <stdint.h>

/**
 * Counter enable Note: External clock, gated mode and encoder mode can work
 * only if the CEN bit has been previously set by software. However trigger mode
 * can set the CEN bit automatically by hardware.
 */
typedef enum TIM1_cen_e {
    /// Counter disabled
    TIM1_cen_b_0x0 = 0x0,
    /// Counter enabled
    TIM1_cen_b_0x1 = 0x1,
} TIM1_cen_t;

/**
 * Update disable This bit is set and cleared by software to enable/disable UEV
 * event generation. Counter overflow/underflow Setting the UG bit Update
 * generation through the slave mode controller Buffered registers are then
 * loaded with their preload values.
 */
typedef enum TIM1_udis_e {
    /// UEV enabled. The Update (UEV) event is generated by one of the following
    /// events:
    TIM1_udis_b_0x0 = 0x0,
    /// UEV disabled. The Update event is not generated, shadow registers keep
    /// their value (ARR, PSC, CCRx). However the counter and the prescaler are
    /// reinitialized if the UG bit is set or if a hardware reset is received
    /// from the slave mode controller.
    TIM1_udis_b_0x1 = 0x1,
} TIM1_udis_t;

/**
 * Update request source This bit is set and cleared by software to select the
 * UEV event sources. Counter overflow/underflow Setting the UG bit Update
 * generation through the slave mode controller
 */
typedef enum TIM1_urs_e {
    /// Any of the following events generate an update interrupt or DMA request
    /// if enabled. These events can be:
    TIM1_urs_b_0x0 = 0x0,
    /// Only counter overflow/underflow generates an update interrupt or DMA
    /// request if enabled.
    TIM1_urs_b_0x1 = 0x1,
} TIM1_urs_t;

/**
 * One pulse mode
 */
typedef enum TIM1_opm_e {
    /// Counter is not stopped at update event
    TIM1_opm_b_0x0 = 0x0,
    /// Counter stops counting at the next update event (clearing the bit CEN)
    TIM1_opm_b_0x1 = 0x1,
} TIM1_opm_t;

/**
 * Direction Note: This bit is read only when the timer is configured in
 * Center-aligned mode or Encoder mode.
 */
typedef enum TIM1_dir_e {
    /// Counter used as upcounter
    TIM1_dir_b_0x0 = 0x0,
    /// Counter used as downcounter
    TIM1_dir_b_0x1 = 0x1,
} TIM1_dir_t;

/**
 * Center-aligned mode selection Note: Switch from edge-aligned mode to
 * center-aligned mode as long as the counter is enabled (CEN=1) is not allowed
 */
typedef enum TIM1_cms_e {
    /// Edge-aligned mode. The counter counts up or down depending on the
    /// direction bit (DIR).
    TIM1_cms_b_0x0 = 0x0,
    /// Center-aligned mode 1. The counter counts up and down alternatively.
    /// Output compare interrupt flags of channels configured in output (CCxS=00
    /// in TIMx_CCMRx register) are set only when the counter is counting down.
    TIM1_cms_b_0x1 = 0x1,
    /// Center-aligned mode 2. The counter counts up and down alternatively.
    /// Output compare interrupt flags of channels configured in output (CCxS=00
    /// in TIMx_CCMRx register) are set only when the counter is counting up.
    TIM1_cms_b_0x2 = 0x2,
    /// Center-aligned mode 3. The counter counts up and down alternatively.
    /// Output compare interrupt flags of channels configured in output (CCxS=00
    /// in TIMx_CCMRx register) are set both when the counter is counting up or
    /// down.
    TIM1_cms_b_0x3 = 0x3,
} TIM1_cms_t;

/**
 * Auto-reload preload enable
 */
typedef enum TIM1_arpe_e {
    /// TIMx_ARR register is not buffered
    TIM1_arpe_b_0x0 = 0x0,
    /// TIMx_ARR register is buffered
    TIM1_arpe_b_0x1 = 0x1,
} TIM1_arpe_t;

/**
 * Clock division This bit-field indicates the division ratio between the timer
 * clock (CK_INT) frequency and the dead-time and sampling clock (tDTS)used by
 * the dead-time generators and the digital filters (ETR, TIx): Note: tDTS =
 * 1/fDTS, tCK_INT = 1/fCK_INT.
 */
typedef enum TIM1_ckd_e {
    /// tDTS=tCK_INT
    TIM1_ckd_b_0x0 = 0x0,
    /// tDTS=2*tCK_INT
    TIM1_ckd_b_0x1 = 0x1,
    /// tDTS=4*tCK_INT
    TIM1_ckd_b_0x2 = 0x2,
    /// Reserved, do not program this value
    TIM1_ckd_b_0x3 = 0x3,
} TIM1_ckd_t;

/**
 * UIF status bit remapping
 */
typedef enum TIM1_uifremap_e {
    /// No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.
    TIM1_uifremap_b_0x0 = 0x0,
    /// Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.
    TIM1_uifremap_b_0x1 = 0x1,
} TIM1_uifremap_t;

/**
 * control register 1
 */
typedef union TIM1_cr1_u {
    struct {
        /// Counter enable Note: External clock, gated mode and encoder mode can
        /// work only if the CEN bit has been previously set by software.
        /// However trigger mode can set the CEN bit automatically by hardware.
        TIM1_cen_t cen : 1;
        /// Update disable This bit is set and cleared by software to
        /// enable/disable UEV event generation. Counter overflow/underflow
        /// Setting the UG bit Update generation through the slave mode
        /// controller Buffered registers are then loaded with their preload
        /// values.
        TIM1_udis_t udis : 1;
        /// Update request source This bit is set and cleared by software to
        /// select the UEV event sources. Counter overflow/underflow Setting the
        /// UG bit Update generation through the slave mode controller
        TIM1_urs_t urs : 1;
        /// One pulse mode
        TIM1_opm_t opm : 1;
        /// Direction Note: This bit is read only when the timer is configured
        /// in Center-aligned mode or Encoder mode.
        TIM1_dir_t dir : 1;
        /// Center-aligned mode selection Note: Switch from edge-aligned mode to
        /// center-aligned mode as long as the counter is enabled (CEN=1) is not
        /// allowed
        TIM1_cms_t cms : 2;
        /// Auto-reload preload enable
        TIM1_arpe_t arpe : 1;
        /// Clock division This bit-field indicates the division ratio between
        /// the timer clock (CK_INT) frequency and the dead-time and sampling
        /// clock (tDTS)used by the dead-time generators and the digital filters
        /// (ETR, TIx): Note: tDTS = 1/fDTS, tCK_INT = 1/fCK_INT.
        TIM1_ckd_t     ckd : 2;
        uint32_t const reserved_10 : 1;
        /// UIF status bit remapping
        TIM1_uifremap_t uifremap : 1;
    };
    uint32_t bits;
} TIM1_cr1_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_cr1_t, sizeof(uint32_t));

/**
 * Capture/compare preloaded control Note: This bit acts only on channels that
 * have a complementary output.
 */
typedef enum TIM1_ccpc_e {
    /// CCxE, CCxNE and OCxM bits are not preloaded
    TIM1_ccpc_b_0x0 = 0x0,
    /// CCxE, CCxNE and OCxM bits are preloaded, after having been written, they
    /// are updated only when a commutation event (COM) occurs (COMG bit set or
    /// rising edge detected on TRGI, depending on the CCUS bit).
    TIM1_ccpc_b_0x1 = 0x1,
} TIM1_ccpc_t;

/**
 * Capture/compare control update selection Note: This bit acts only on channels
 * that have a complementary output.
 */
typedef enum TIM1_ccus_e {
    /// When capture/compare control bits are preloaded (CCPC=1), they are
    /// updated by setting the COMG bit only
    TIM1_ccus_b_0x0 = 0x0,
    /// When capture/compare control bits are preloaded (CCPC=1), they are
    /// updated by setting the COMG bit or when an rising edge occurs on TRGI
    TIM1_ccus_b_0x1 = 0x1,
} TIM1_ccus_t;

/**
 * Capture/compare DMA selection
 */
typedef enum TIM1_ccds_e {
    /// CCx DMA request sent when CCx event occurs
    TIM1_ccds_b_0x0 = 0x0,
    /// CCx DMA requests sent when update event occurs
    TIM1_ccds_b_0x1 = 0x1,
} TIM1_ccds_t;

/**
 * Master mode selection These bits allow selected information to be sent in
 * master mode to slave timers for synchronization (TRGO). The combination is as
 * follows: Note: The clock of the slave timer or ADC must be enabled prior to
 * receive events from the master timer, and must not be changed on-the-fly
 * while triggers are received from the master timer.
 */
typedef enum TIM1_mms_e {
    /// Reset - the UG bit from the TIMx_EGR register is used as trigger output
    /// (TRGO). If the reset is generated by the trigger input (slave mode
    /// controller configured in reset mode) then the signal on TRGO is delayed
    /// compared to the actual reset.
    TIM1_mms_b_0x0 = 0x0,
    /// Enable - the Counter Enable signal CNT_EN is used as trigger output
    /// (TRGO). It is useful to start several timers at the same time or to
    /// control a window in which a slave timer is enable. The Counter Enable
    /// signal is generated by a logic AND between CEN control bit and the
    /// trigger input when configured in gated mode. When the Counter Enable
    /// signal is controlled by the trigger input, there is a delay on TRGO,
    /// except if the master/slave mode is selected (see the MSM bit description
    /// in TIMx_SMCR register).
    TIM1_mms_b_0x1 = 0x1,
    /// Update - The update event is selected as trigger output (TRGO). For
    /// instance a master timer can then be used as a prescaler for a slave
    /// timer.
    TIM1_mms_b_0x2 = 0x2,
    /// Compare Pulse - The trigger output send a positive pulse when the CC1IF
    /// flag is to be set (even if it was already high), as soon as a capture or
    /// a compare match occurred. (TRGO).
    TIM1_mms_b_0x3 = 0x3,
    /// Compare - OC1REFC signal is used as trigger output (TRGO)
    TIM1_mms_b_0x4 = 0x4,
    /// Compare - OC2REFC signal is used as trigger output (TRGO)
    TIM1_mms_b_0x5 = 0x5,
    /// Compare - OC3REFC signal is used as trigger output (TRGO)
    TIM1_mms_b_0x6 = 0x6,
    /// Compare - OC4REFC signal is used as trigger output (TRGO)
    TIM1_mms_b_0x7 = 0x7,
} TIM1_mms_t;

/**
 * TI1 selection
 */
typedef enum TIM1_ti1s_e {
    /// The TIMx_CH1 pin is connected to TI1 input
    TIM1_ti1s_b_0x0 = 0x0,
    /// The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR
    /// combination)
    TIM1_ti1s_b_0x1 = 0x1,
} TIM1_ti1s_t;

/**
 * Output Idle state 1 (OC1 output) Note: This bit can not be modified as long
 * as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR
 * register).
 */
typedef enum TIM1_ois1_e {
    /// OC1=0 (after a dead-time if OC1N is implemented) when MOE=0
    TIM1_ois1_b_0x0 = 0x0,
    /// OC1=1 (after a dead-time if OC1N is implemented) when MOE=0
    TIM1_ois1_b_0x1 = 0x1,
} TIM1_ois1_t;

/**
 * Output Idle state 1 (OC1N output) Note: This bit can not be modified as long
 * as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR
 * register).
 */
typedef enum TIM1_ois1n_e {
    /// OC1N=0 after a dead-time when MOE=0
    TIM1_ois1n_b_0x0 = 0x0,
    /// OC1N=1 after a dead-time when MOE=0
    TIM1_ois1n_b_0x1 = 0x1,
} TIM1_ois1n_t;

/**
 * Master mode selection 2 These bits allow the information to be sent to ADC
 * for synchronization (TRGO2) to be selected. The combination is as follows:
 * Note: The clock of the slave timer or ADC must be enabled prior to receive
 * events from the master timer, and must not be changed on-the-fly while
 * triggers are received from the master timer.
 */
typedef enum TIM1_mms2_e {
    /// Reset - the UG bit from the TIMx_EGR register is used as trigger output
    /// (TRGO2). If the reset is generated by the trigger input (slave mode
    /// controller configured in reset mode), the signal on TRGO2 is delayed
    /// compared to the actual reset.
    TIM1_mms2_b_0x0 = 0x00,
    /// Enable - the Counter Enable signal CNT_EN is used as trigger output
    /// (TRGO2). It is useful to start several timers at the same time or to
    /// control a window in which a slave timer is enabled. The Counter Enable
    /// signal is generated by a logic AND between the CEN control bit and the
    /// trigger input when configured in Gated mode. When the Counter Enable
    /// signal is controlled by the trigger input, there is a delay on TRGO2,
    /// except if the Master/Slave mode is selected (see the MSM bit description
    /// in TIMx_SMCR register).
    TIM1_mms2_b_0x1 = 0x01,
    /// Update - the update event is selected as trigger output (TRGO2). For
    /// instance, a master timer can then be used as a prescaler for a slave
    /// timer.
    TIM1_mms2_b_0x2 = 0x02,
    /// Compare pulse - the trigger output sends a positive pulse when the CC1IF
    /// flag is to be set (even if it was already high), as soon as a capture or
    /// compare match occurs (TRGO2).
    TIM1_mms2_b_0x3 = 0x03,
    /// Compare - OC1REFC signal is used as trigger output (TRGO2)
    TIM1_mms2_b_0x4 = 0x04,
    /// Compare - OC2REFC signal is used as trigger output (TRGO2)
    TIM1_mms2_b_0x5 = 0x05,
    /// Compare - OC3REFC signal is used as trigger output (TRGO2)
    TIM1_mms2_b_0x6 = 0x06,
    /// Compare - OC4REFC signal is used as trigger output (TRGO2)
    TIM1_mms2_b_0x7 = 0x07,
    /// Compare - OC5REFC signal is used as trigger output (TRGO2)
    TIM1_mms2_b_0x8 = 0x08,
    /// Compare - OC6REFC signal is used as trigger output (TRGO2)
    TIM1_mms2_b_0x9 = 0x09,
    /// Compare Pulse - OC4REFC rising or falling edges generate pulses on TRGO2
    TIM1_mms2_b_0xa = 0x0A,
    /// Compare Pulse - OC6REFC rising or falling edges generate pulses on TRGO2
    TIM1_mms2_b_0xb = 0x0B,
    /// Compare Pulse - OC4REFC or OC6REFC rising edges generate pulses on TRGO2
    TIM1_mms2_b_0xc = 0x0C,
    /// Compare Pulse - OC4REFC rising or OC6REFC falling edges generate pulses
    /// on TRGO2
    TIM1_mms2_b_0xd = 0x0D,
    /// Compare Pulse - OC5REFC or OC6REFC rising edges generate pulses on TRGO2
    TIM1_mms2_b_0xe = 0x0E,
    /// Compare Pulse - OC5REFC rising or OC6REFC falling edges generate pulses
    /// on TRGO2
    TIM1_mms2_b_0xf = 0x0F,
} TIM1_mms2_t;

/**
 * control register 2
 */
typedef union TIM1_cr2_u {
    struct {
        /// Capture/compare preloaded control Note: This bit acts only on
        /// channels that have a complementary output.
        TIM1_ccpc_t    ccpc : 1;
        uint32_t const reserved_01 : 1;
        /// Capture/compare control update selection Note: This bit acts only on
        /// channels that have a complementary output.
        TIM1_ccus_t ccus : 1;
        /// Capture/compare DMA selection
        TIM1_ccds_t ccds : 1;
        /// Master mode selection These bits allow selected information to be
        /// sent in master mode to slave timers for synchronization (TRGO). The
        /// combination is as follows: Note: The clock of the slave timer or ADC
        /// must be enabled prior to receive events from the master timer, and
        /// must not be changed on-the-fly while triggers are received from the
        /// master timer.
        TIM1_mms_t mms : 3;
        /// TI1 selection
        TIM1_ti1s_t ti1s : 1;
        /// Output Idle state 1 (OC1 output) Note: This bit can not be modified
        /// as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in
        /// TIMx_BDTR register).
        TIM1_ois1_t ois1 : 1;
        /// Output Idle state 1 (OC1N output) Note: This bit can not be modified
        /// as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in
        /// TIMx_BDTR register).
        TIM1_ois1n_t ois1n : 1;
        /// Output Idle state 2 (OC2 output) Refer to OIS1 bit
        uint32_t ois2 : 1;
        /// Output Idle state 2 (OC2N output) Refer to OIS1N bit
        uint32_t ois2n : 1;
        /// Output Idle state 3 (OC3 output) Refer to OIS1 bit
        uint32_t ois3 : 1;
        /// Output Idle state 3 (OC3N output) Refer to OIS1N bit
        uint32_t ois3n : 1;
        /// Output Idle state 4 (OC4 output) Refer to OIS1 bit
        uint32_t       ois4 : 1;
        uint32_t const reserved_15 : 1;
        /// Output Idle state 5 (OC5 output) Refer to OIS1 bit
        uint32_t       ois5 : 1;
        uint32_t const reserved_17 : 1;
        /// Output Idle state 6 (OC6 output) Refer to OIS1 bit
        uint32_t       ois6 : 1;
        uint32_t const reserved_19 : 1;
        /// Master mode selection 2 These bits allow the information to be sent
        /// to ADC for synchronization (TRGO2) to be selected. The combination
        /// is as follows: Note: The clock of the slave timer or ADC must be
        /// enabled prior to receive events from the master timer, and must not
        /// be changed on-the-fly while triggers are received from the master
        /// timer.
        TIM1_mms2_t mms2 : 4;
    };
    uint32_t bits;
} TIM1_cr2_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_cr2_t, sizeof(uint32_t));

/**
 * Slave mode selection When external signals are selected the active edge of
 * the trigger signal (TRGI) is linked to the polarity selected on the external
 * input (see Input Control register and Control Register description. Note: The
 * gated mode must not be used if TI1F_ED is selected as the trigger input
 * (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F,
 * whereas the gated mode checks the level of the trigger signal. Note: The
 * clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the
 * TRGO2 signals must be enabled prior to receive events from the master timer,
 * and the clock frequency (prescaler) must not be changed on-the-fly while
 * triggers are received from the master timer.
 */
typedef enum TIM1_sms1_e {
    /// Slave mode disabled - if CEN = '1â then the prescaler is clocked
    /// directly by the internal clock.
    TIM1_sms1_b_0x0 = 0x0,
    /// Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on
    /// TI2FP2 level.
    TIM1_sms1_b_0x1 = 0x1,
    /// Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on
    /// TI1FP1 level.
    TIM1_sms1_b_0x2 = 0x2,
    /// Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges
    /// depending on the level of the other input.
    TIM1_sms1_b_0x3 = 0x3,
    /// Reset Mode - Rising edge of the selected trigger input (TRGI)
    /// reinitializes the counter and generates an update of the registers.
    TIM1_sms1_b_0x4 = 0x4,
    /// Gated Mode - The counter clock is enabled when the trigger input (TRGI)
    /// is high. The counter stops (but is not reset) as soon as the trigger
    /// becomes low. Both start and stop of the counter are controlled.
    TIM1_sms1_b_0x5 = 0x5,
    /// Trigger Mode - The counter starts at a rising edge of the trigger TRGI
    /// (but it is not reset). Only the start of the counter is controlled.
    TIM1_sms1_b_0x6 = 0x6,
    /// External Clock Mode 1 - Rising edges of the selected trigger (TRGI)
    /// clock the counter.
    TIM1_sms1_b_0x7 = 0x7,
    /// Combined reset + trigger mode - Rising edge of the selected trigger
    /// input (TRGI) reinitializes the counter, generates an update of the
    /// registers and starts the counter.Codes above 1000: Reserved.
    TIM1_sms1_b_0x8 = 0x8,
} TIM1_sms1_t;

/**
 * OCREF clear selection This bit is used to select the OCREF clear source.
 */
typedef enum TIM1_occs_e {
    /// OCREF_CLR_INT is connected to COMP1 or COMP2 output depending on
    /// TIM1_OR1.OCREF_CLR
    TIM1_occs_b_0x0 = 0x0,
    /// OCREF_CLR_INT is connected to ETRF
    TIM1_occs_b_0x1 = 0x1,
} TIM1_occs_t;

/**
 * Trigger selection This bit-field selects the trigger input to be used to
 * synchronize the counter. Others: Reserved See for more details on ITRx
 * meaning for each Timer. Note: These bits must be changed only when they are
 * not used (e.g. when SMS=000) to avoid wrong edge detections at the
 * transition.
 */
typedef enum TIM1_ts1_e {
    /// Internal Trigger 0 (ITR0)
    TIM1_ts1_b_0x0 = 0x0,
    /// Internal Trigger 1 (ITR1)
    TIM1_ts1_b_0x1 = 0x1,
    /// Internal Trigger 2 (ITR2)
    TIM1_ts1_b_0x2 = 0x2,
    /// Internal Trigger 3 (ITR3)
    TIM1_ts1_b_0x3 = 0x3,
    /// TI1 Edge Detector (TI1F_ED)
    TIM1_ts1_b_0x4 = 0x4,
    /// Filtered Timer Input 1 (TI1FP1)
    TIM1_ts1_b_0x5 = 0x5,
    /// Filtered Timer Input 2 (TI2FP2)
    TIM1_ts1_b_0x6 = 0x6,
    /// External Trigger input (ETRF)
    TIM1_ts1_b_0x7 = 0x7,
} TIM1_ts1_t;

/**
 * Master/slave mode
 */
typedef enum TIM1_msm_e {
    /// No action
    TIM1_msm_b_0x0 = 0x0,
    /// The effect of an event on the trigger input (TRGI) is delayed to allow a
    /// perfect synchronization between the current timer and its slaves
    /// (through TRGO). It is useful if we want to synchronize several timers on
    /// a single external event.
    TIM1_msm_b_0x1 = 0x1,
} TIM1_msm_t;

/**
 * External trigger filter This bit-field then defines the frequency used to
 * sample ETRP signal and the length of the digital filter applied to ETRP. The
 * digital filter is made of an event counter in which N consecutive events are
 * needed to validate a transition on the output:
 */
typedef enum TIM1_etf_e {
    /// No filter, sampling is done at fDTS
    TIM1_etf_b_0x0 = 0x00,
    /// fSAMPLING=fCK_INT, N=2
    TIM1_etf_b_0x1 = 0x01,
    /// fSAMPLING=fCK_INT, N=4
    TIM1_etf_b_0x2 = 0x02,
    /// fSAMPLING=fCK_INT, N=8
    TIM1_etf_b_0x3 = 0x03,
    /// fSAMPLING=fDTS/2, N=6
    TIM1_etf_b_0x4 = 0x04,
    /// fSAMPLING=fDTS/2, N=8
    TIM1_etf_b_0x5 = 0x05,
    /// fSAMPLING=fDTS/4, N=6
    TIM1_etf_b_0x6 = 0x06,
    /// fSAMPLING=fDTS/4, N=8
    TIM1_etf_b_0x7 = 0x07,
    /// fSAMPLING=fDTS/8, N=6
    TIM1_etf_b_0x8 = 0x08,
    /// fSAMPLING=fDTS/8, N=8
    TIM1_etf_b_0x9 = 0x09,
    /// fSAMPLING=fDTS/16, N=5
    TIM1_etf_b_0xa = 0x0A,
    /// fSAMPLING=fDTS/16, N=6
    TIM1_etf_b_0xb = 0x0B,
    /// fSAMPLING=fDTS/16, N=8
    TIM1_etf_b_0xc = 0x0C,
    /// fSAMPLING=fDTS/32, N=5
    TIM1_etf_b_0xd = 0x0D,
    /// fSAMPLING=fDTS/32, N=6
    TIM1_etf_b_0xe = 0x0E,
    /// fSAMPLING=fDTS/32, N=8
    TIM1_etf_b_0xf = 0x0F,
} TIM1_etf_t;

/**
 * External trigger prescaler External trigger signal ETRP frequency must be at
 * most 1/4 of fCK_INT frequency. A prescaler can be enabled to reduce ETRP
 * frequency. It is useful when inputting fast external clocks.
 */
typedef enum TIM1_etps_e {
    /// Prescaler OFF
    TIM1_etps_b_0x0 = 0x0,
    /// ETRP frequency divided by 2
    TIM1_etps_b_0x1 = 0x1,
    /// ETRP frequency divided by 4
    TIM1_etps_b_0x2 = 0x2,
    /// ETRP frequency divided by 8
    TIM1_etps_b_0x3 = 0x3,
} TIM1_etps_t;

/**
 * External clock enable This bit enables External clock mode 2. Note: Setting
 * the ECE bit has the same effect as selecting external clock mode 1 with TRGI
 * connected to ETRF (SMS=111 and TS=00111). It is possible to simultaneously
 * use external clock mode 2 with the following slave modes: reset mode, gated
 * mode and trigger mode. Nevertheless, TRGI must not be connected to ETRF in
 * this case (TS bits must not be 00111). If external clock mode 1 and external
 * clock mode 2 are enabled at the same time, the external clock input is ETRF.
 */
typedef enum TIM1_ece_e {
    /// External clock mode 2 disabled
    TIM1_ece_b_0x0 = 0x0,
    /// External clock mode 2 enabled. The counter is clocked by any active edge
    /// on the ETRF signal.
    TIM1_ece_b_0x1 = 0x1,
} TIM1_ece_t;

/**
 * External trigger polarity This bit selects whether ETR or ETR is used for
 * trigger operations
 */
typedef enum TIM1_etp_e {
    /// ETR is non-inverted, active at high level or rising edge.
    TIM1_etp_b_0x0 = 0x0,
    /// ETR is inverted, active at low level or falling edge.
    TIM1_etp_b_0x1 = 0x1,
} TIM1_etp_t;

/**
 * Slave mode selection When external signals are selected the active edge of
 * the trigger signal (TRGI) is linked to the polarity selected on the external
 * input (see Input Control register and Control Register description. Note: The
 * gated mode must not be used if TI1F_ED is selected as the trigger input
 * (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F,
 * whereas the gated mode checks the level of the trigger signal. Note: The
 * clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the
 * TRGO2 signals must be enabled prior to receive events from the master timer,
 * and the clock frequency (prescaler) must not be changed on-the-fly while
 * triggers are received from the master timer.
 */
typedef enum TIM1_sms2_e {
    /// Slave mode disabled - if CEN = '1â then the prescaler is clocked
    /// directly by the internal clock.
    TIM1_sms2_b_0x0 = 0x0,
    /// Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on
    /// TI2FP2 level.
    TIM1_sms2_b_0x1 = 0x1,
    /// Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on
    /// TI1FP1 level.
    TIM1_sms2_b_0x2 = 0x2,
    /// Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges
    /// depending on the level of the other input.
    TIM1_sms2_b_0x3 = 0x3,
    /// Reset Mode - Rising edge of the selected trigger input (TRGI)
    /// reinitializes the counter and generates an update of the registers.
    TIM1_sms2_b_0x4 = 0x4,
    /// Gated Mode - The counter clock is enabled when the trigger input (TRGI)
    /// is high. The counter stops (but is not reset) as soon as the trigger
    /// becomes low. Both start and stop of the counter are controlled.
    TIM1_sms2_b_0x5 = 0x5,
    /// Trigger Mode - The counter starts at a rising edge of the trigger TRGI
    /// (but it is not reset). Only the start of the counter is controlled.
    TIM1_sms2_b_0x6 = 0x6,
    /// External Clock Mode 1 - Rising edges of the selected trigger (TRGI)
    /// clock the counter.
    TIM1_sms2_b_0x7 = 0x7,
    /// Combined reset + trigger mode - Rising edge of the selected trigger
    /// input (TRGI) reinitializes the counter, generates an update of the
    /// registers and starts the counter.Codes above 1000: Reserved.
    TIM1_sms2_b_0x8 = 0x8,
} TIM1_sms2_t;

/**
 * Trigger selection This bit-field selects the trigger input to be used to
 * synchronize the counter. Others: Reserved See for more details on ITRx
 * meaning for each Timer. Note: These bits must be changed only when they are
 * not used (e.g. when SMS=000) to avoid wrong edge detections at the
 * transition.
 */
typedef enum TIM1_ts2_e {
    /// Internal Trigger 0 (ITR0)
    TIM1_ts2_b_0x0 = 0x0,
    /// Internal Trigger 1 (ITR1)
    TIM1_ts2_b_0x1 = 0x1,
    /// Internal Trigger 2 (ITR2)
    TIM1_ts2_b_0x2 = 0x2,
    /// Internal Trigger 3 (ITR3)
    TIM1_ts2_b_0x3 = 0x3,
    /// TI1 Edge Detector (TI1F_ED)
    TIM1_ts2_b_0x4 = 0x4,
    /// Filtered Timer Input 1 (TI1FP1)
    TIM1_ts2_b_0x5 = 0x5,
    /// Filtered Timer Input 2 (TI2FP2)
    TIM1_ts2_b_0x6 = 0x6,
    /// External Trigger input (ETRF)
    TIM1_ts2_b_0x7 = 0x7,
} TIM1_ts2_t;

/**
 * slave mode control register
 */
typedef union TIM1_smcr_u {
    struct {
        /// Slave mode selection When external signals are selected the active
        /// edge of the trigger signal (TRGI) is linked to the polarity selected
        /// on the external input (see Input Control register and Control
        /// Register description. Note: The gated mode must not be used if
        /// TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED
        /// outputs 1 pulse for each transition on TI1F, whereas the gated mode
        /// checks the level of the trigger signal. Note: The clock of the slave
        /// peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2
        /// signals must be enabled prior to receive events from the master
        /// timer, and the clock frequency (prescaler) must not be changed
        /// on-the-fly while triggers are received from the master timer.
        TIM1_sms1_t sms1 : 3;
        /// OCREF clear selection This bit is used to select the OCREF clear
        /// source.
        TIM1_occs_t occs : 1;
        /// Trigger selection This bit-field selects the trigger input to be
        /// used to synchronize the counter. Others: Reserved See for more
        /// details on ITRx meaning for each Timer. Note: These bits must be
        /// changed only when they are not used (e.g. when SMS=000) to avoid
        /// wrong edge detections at the transition.
        TIM1_ts1_t ts1 : 3;
        /// Master/slave mode
        TIM1_msm_t msm : 1;
        /// External trigger filter This bit-field then defines the frequency
        /// used to sample ETRP signal and the length of the digital filter
        /// applied to ETRP. The digital filter is made of an event counter in
        /// which N consecutive events are needed to validate a transition on
        /// the output:
        TIM1_etf_t etf : 4;
        /// External trigger prescaler External trigger signal ETRP frequency
        /// must be at most 1/4 of fCK_INT frequency. A prescaler can be enabled
        /// to reduce ETRP frequency. It is useful when inputting fast external
        /// clocks.
        TIM1_etps_t etps : 2;
        /// External clock enable This bit enables External clock mode 2. Note:
        /// Setting the ECE bit has the same effect as selecting external clock
        /// mode 1 with TRGI connected to ETRF (SMS=111 and TS=00111). It is
        /// possible to simultaneously use external clock mode 2 with the
        /// following slave modes: reset mode, gated mode and trigger mode.
        /// Nevertheless, TRGI must not be connected to ETRF in this case (TS
        /// bits must not be 00111). If external clock mode 1 and external clock
        /// mode 2 are enabled at the same time, the external clock input is
        /// ETRF.
        TIM1_ece_t ece : 1;
        /// External trigger polarity This bit selects whether ETR or ETR is
        /// used for trigger operations
        TIM1_etp_t etp : 1;
        /// Slave mode selection When external signals are selected the active
        /// edge of the trigger signal (TRGI) is linked to the polarity selected
        /// on the external input (see Input Control register and Control
        /// Register description. Note: The gated mode must not be used if
        /// TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED
        /// outputs 1 pulse for each transition on TI1F, whereas the gated mode
        /// checks the level of the trigger signal. Note: The clock of the slave
        /// peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2
        /// signals must be enabled prior to receive events from the master
        /// timer, and the clock frequency (prescaler) must not be changed
        /// on-the-fly while triggers are received from the master timer.
        TIM1_sms2_t    sms2 : 1;
        uint32_t const reserved_17 : 3;
        /// Trigger selection This bit-field selects the trigger input to be
        /// used to synchronize the counter. Others: Reserved See for more
        /// details on ITRx meaning for each Timer. Note: These bits must be
        /// changed only when they are not used (e.g. when SMS=000) to avoid
        /// wrong edge detections at the transition.
        TIM1_ts2_t ts2 : 2;
    };
    uint32_t bits;
} TIM1_smcr_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_smcr_t, sizeof(uint32_t));

/**
 * Update interrupt enable
 */
typedef enum TIM1_uie_e {
    /// Update interrupt disabled
    TIM1_uie_b_0x0 = 0x0,
    /// Update interrupt enabled
    TIM1_uie_b_0x1 = 0x1,
} TIM1_uie_t;

/**
 * Capture/Compare 1 interrupt enable
 */
typedef enum TIM1_cc1ie_e {
    /// CC1 interrupt disabled
    TIM1_cc1ie_b_0x0 = 0x0,
    /// CC1 interrupt enabled
    TIM1_cc1ie_b_0x1 = 0x1,
} TIM1_cc1ie_t;

/**
 * Capture/Compare 2 interrupt enable
 */
typedef enum TIM1_cc2ie_e {
    /// CC2 interrupt disabled
    TIM1_cc2ie_b_0x0 = 0x0,
    /// CC2 interrupt enabled
    TIM1_cc2ie_b_0x1 = 0x1,
} TIM1_cc2ie_t;

/**
 * Capture/Compare 3 interrupt enable
 */
typedef enum TIM1_cc3ie_e {
    /// CC3 interrupt disabled
    TIM1_cc3ie_b_0x0 = 0x0,
    /// CC3 interrupt enabled
    TIM1_cc3ie_b_0x1 = 0x1,
} TIM1_cc3ie_t;

/**
 * Capture/Compare 4 interrupt enable
 */
typedef enum TIM1_cc4ie_e {
    /// CC4 interrupt disabled
    TIM1_cc4ie_b_0x0 = 0x0,
    /// CC4 interrupt enabled
    TIM1_cc4ie_b_0x1 = 0x1,
} TIM1_cc4ie_t;

/**
 * COM interrupt enable
 */
typedef enum TIM1_comie_e {
    /// COM interrupt disabled
    TIM1_comie_b_0x0 = 0x0,
    /// COM interrupt enabled
    TIM1_comie_b_0x1 = 0x1,
} TIM1_comie_t;

/**
 * Trigger interrupt enable
 */
typedef enum TIM1_tie_e {
    /// Trigger interrupt disabled
    TIM1_tie_b_0x0 = 0x0,
    /// Trigger interrupt enabled
    TIM1_tie_b_0x1 = 0x1,
} TIM1_tie_t;

/**
 * Break interrupt enable
 */
typedef enum TIM1_bie_e {
    /// Break interrupt disabled
    TIM1_bie_b_0x0 = 0x0,
    /// Break interrupt enabled
    TIM1_bie_b_0x1 = 0x1,
} TIM1_bie_t;

/**
 * Update DMA request enable
 */
typedef enum TIM1_ude_e {
    /// Update DMA request disabled
    TIM1_ude_b_0x0 = 0x0,
    /// Update DMA request enabled
    TIM1_ude_b_0x1 = 0x1,
} TIM1_ude_t;

/**
 * Capture/Compare 1 DMA request enable
 */
typedef enum TIM1_cc1de_e {
    /// CC1 DMA request disabled
    TIM1_cc1de_b_0x0 = 0x0,
    /// CC1 DMA request enabled
    TIM1_cc1de_b_0x1 = 0x1,
} TIM1_cc1de_t;

/**
 * Capture/Compare 2 DMA request enable
 */
typedef enum TIM1_cc2de_e {
    /// CC2 DMA request disabled
    TIM1_cc2de_b_0x0 = 0x0,
    /// CC2 DMA request enabled
    TIM1_cc2de_b_0x1 = 0x1,
} TIM1_cc2de_t;

/**
 * Capture/Compare 3 DMA request enable
 */
typedef enum TIM1_cc3de_e {
    /// CC3 DMA request disabled
    TIM1_cc3de_b_0x0 = 0x0,
    /// CC3 DMA request enabled
    TIM1_cc3de_b_0x1 = 0x1,
} TIM1_cc3de_t;

/**
 * Capture/Compare 4 DMA request enable
 */
typedef enum TIM1_cc4de_e {
    /// CC4 DMA request disabled
    TIM1_cc4de_b_0x0 = 0x0,
    /// CC4 DMA request enabled
    TIM1_cc4de_b_0x1 = 0x1,
} TIM1_cc4de_t;

/**
 * COM DMA request enable
 */
typedef enum TIM1_comde_e {
    /// COM DMA request disabled
    TIM1_comde_b_0x0 = 0x0,
    /// COM DMA request enabled
    TIM1_comde_b_0x1 = 0x1,
} TIM1_comde_t;

/**
 * Trigger DMA request enable
 */
typedef enum TIM1_tde_e {
    /// Trigger DMA request disabled
    TIM1_tde_b_0x0 = 0x0,
    /// Trigger DMA request enabled
    TIM1_tde_b_0x1 = 0x1,
} TIM1_tde_t;

/**
 * DMA/Interrupt enable register
 */
typedef union TIM1_dier_u {
    struct {
        /// Update interrupt enable
        TIM1_uie_t uie : 1;
        /// Capture/Compare 1 interrupt enable
        TIM1_cc1ie_t cc1ie : 1;
        /// Capture/Compare 2 interrupt enable
        TIM1_cc2ie_t cc2ie : 1;
        /// Capture/Compare 3 interrupt enable
        TIM1_cc3ie_t cc3ie : 1;
        /// Capture/Compare 4 interrupt enable
        TIM1_cc4ie_t cc4ie : 1;
        /// COM interrupt enable
        TIM1_comie_t comie : 1;
        /// Trigger interrupt enable
        TIM1_tie_t tie : 1;
        /// Break interrupt enable
        TIM1_bie_t bie : 1;
        /// Update DMA request enable
        TIM1_ude_t ude : 1;
        /// Capture/Compare 1 DMA request enable
        TIM1_cc1de_t cc1de : 1;
        /// Capture/Compare 2 DMA request enable
        TIM1_cc2de_t cc2de : 1;
        /// Capture/Compare 3 DMA request enable
        TIM1_cc3de_t cc3de : 1;
        /// Capture/Compare 4 DMA request enable
        TIM1_cc4de_t cc4de : 1;
        /// COM DMA request enable
        TIM1_comde_t comde : 1;
        /// Trigger DMA request enable
        TIM1_tde_t tde : 1;
    };
    uint32_t bits;
} TIM1_dier_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_dier_t, sizeof(uint32_t));

/**
 * Update interrupt flag This bit is set by hardware on an update event. It is
 * cleared by software. At overflow or underflow regarding the repetition
 * counter value (update if repetition counter = 0) and if the UDIS=0 in the
 * TIMx_CR1 register. When CNT is reinitialized by software using the UG bit in
 * TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register. When CNT is
 * reinitialized by a trigger event (refer to control register
 * (TIM1_SMCRTIMx_SMCR)N/A), if URS=0 and UDIS=0 in the TIMx_CR1 register.
 */
typedef enum TIM1_uif_e {
    /// No update occurred.
    TIM1_uif_b_0x0 = 0x0,
    /// Update interrupt pending. This bit is set by hardware when the registers
    /// are updated:
    TIM1_uif_b_0x1 = 0x1,
} TIM1_uif_t;

/**
 * Capture/Compare 1 interrupt flag This flag is set by hardware. It is cleared
 * by software (input capture or output compare mode) or by reading the
 * TIMx_CCR1 register (input capture mode only). If channel CC1 is configured as
 * output: this flag is set when he content of the counter TIMx_CNT matches the
 * content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater
 * than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow
 * (in up-counting and up/down-counting modes) or underflow (in down-counting
 * mode). There are 3 possible options for flag setting in center-aligned mode,
 * refer to the CMS bits in the TIMx_CR1 register for the full description. If
 * channel CC1 is configured as input: this bit is set when counter value has
 * been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per
 * the edge sensitivity defined with the CC1P and CC1NP bits setting, in
 * TIMx_CCER).
 */
typedef enum TIM1_cc1if_e {
    /// No compare match / No input capture occurred
    TIM1_cc1if_b_0x0 = 0x0,
    /// A compare match or an input capture occurred.
    TIM1_cc1if_b_0x1 = 0x1,
} TIM1_cc1if_t;

/**
 * COM interrupt flag This flag is set by hardware on COM event (when
 * Capture/compare Control bits - CCxE, CCxNE, OCxM - have been updated). It is
 * cleared by software.
 */
typedef enum TIM1_comif_e {
    /// No COM event occurred.
    TIM1_comif_b_0x0 = 0x0,
    /// COM interrupt pending.
    TIM1_comif_b_0x1 = 0x1,
} TIM1_comif_t;

/**
 * Trigger interrupt flag This flag is set by hardware on the TRG trigger event
 * (active edge detected on TRGI input when the slave mode controller is enabled
 * in all modes but gated mode. It is set when the counter starts or stops when
 * gated mode is selected. It is cleared by software.
 */
typedef enum TIM1_tif_e {
    /// No trigger event occurred.
    TIM1_tif_b_0x0 = 0x0,
    /// Trigger interrupt pending.
    TIM1_tif_b_0x1 = 0x1,
} TIM1_tif_t;

/**
 * Break interrupt flag This flag is set by hardware as soon as the break input
 * goes active. It can be cleared by software if the break input is not active.
 */
typedef enum TIM1_bif_e {
    /// No break event occurred.
    TIM1_bif_b_0x0 = 0x0,
    /// An active level has been detected on the break input. An interrupt is
    /// generated if BIE=1 in the TIMx_DIER register.
    TIM1_bif_b_0x1 = 0x1,
} TIM1_bif_t;

/**
 * Break 2 interrupt flag This flag is set by hardware as soon as the break 2
 * input goes active. It can be cleared by software if the break 2 input is not
 * active.
 */
typedef enum TIM1_b2if_e {
    /// No break event occurred.
    TIM1_b2if_b_0x0 = 0x0,
    /// An active level has been detected on the break 2 input. An interrupt is
    /// generated if BIE=1 in the TIMx_DIER register.
    TIM1_b2if_b_0x1 = 0x1,
} TIM1_b2if_t;

/**
 * Capture/Compare 1 overcapture flag This flag is set by hardware only when the
 * corresponding channel is configured in input capture mode. It is cleared by
 * software by writing it to '0â.
 */
typedef enum TIM1_cc1of_e {
    /// No overcapture has been detected.
    TIM1_cc1of_b_0x0 = 0x0,
    /// The counter value has been captured in TIMx_CCR1 register while CC1IF
    /// flag was already set
    TIM1_cc1of_b_0x1 = 0x1,
} TIM1_cc1of_t;

/**
 * System Break interrupt flag This flag is set by hardware as soon as the
 * system break input goes active. It can be cleared by software if the system
 * break input is not active. This flag must be reset to re-start PWM operation.
 */
typedef enum TIM1_sbif_e {
    /// No break event occurred.
    TIM1_sbif_b_0x0 = 0x0,
    /// An active level has been detected on the system break input. An
    /// interrupt is generated if BIE=1 in the TIMx_DIER register.
    TIM1_sbif_b_0x1 = 0x1,
} TIM1_sbif_t;

/**
 * status register
 */
typedef union TIM1_sr_u {
    struct {
        /// Update interrupt flag This bit is set by hardware on an update
        /// event. It is cleared by software. At overflow or underflow regarding
        /// the repetition counter value (update if repetition counter = 0) and
        /// if the UDIS=0 in the TIMx_CR1 register. When CNT is reinitialized by
        /// software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0
        /// in the TIMx_CR1 register. When CNT is reinitialized by a trigger
        /// event (refer to control register (TIM1_SMCRTIMx_SMCR)N/A), if URS=0
        /// and UDIS=0 in the TIMx_CR1 register.
        TIM1_uif_t uif : 1;
        /// Capture/Compare 1 interrupt flag This flag is set by hardware. It is
        /// cleared by software (input capture or output compare mode) or by
        /// reading the TIMx_CCR1 register (input capture mode only). If channel
        /// CC1 is configured as output: this flag is set when he content of the
        /// counter TIMx_CNT matches the content of the TIMx_CCR1 register. When
        /// the content of TIMx_CCR1 is greater than the content of TIMx_ARR,
        /// the CC1IF bit goes high on the counter overflow (in up-counting and
        /// up/down-counting modes) or underflow (in down-counting mode). There
        /// are 3 possible options for flag setting in center-aligned mode,
        /// refer to the CMS bits in the TIMx_CR1 register for the full
        /// description. If channel CC1 is configured as input: this bit is set
        /// when counter value has been captured in TIMx_CCR1 register (an edge
        /// has been detected on IC1, as per the edge sensitivity defined with
        /// the CC1P and CC1NP bits setting, in TIMx_CCER).
        TIM1_cc1if_t cc1if : 1;
        /// Capture/Compare 2 interrupt flag Refer to CC1IF description
        uint32_t cc2if : 1;
        /// Capture/Compare 3 interrupt flag Refer to CC1IF description
        uint32_t cc3if : 1;
        /// Capture/Compare 4 interrupt flag Refer to CC1IF description
        uint32_t cc4if : 1;
        /// COM interrupt flag This flag is set by hardware on COM event (when
        /// Capture/compare Control bits - CCxE, CCxNE, OCxM - have been
        /// updated). It is cleared by software.
        TIM1_comif_t comif : 1;
        /// Trigger interrupt flag This flag is set by hardware on the TRG
        /// trigger event (active edge detected on TRGI input when the slave
        /// mode controller is enabled in all modes but gated mode. It is set
        /// when the counter starts or stops when gated mode is selected. It is
        /// cleared by software.
        TIM1_tif_t tif : 1;
        /// Break interrupt flag This flag is set by hardware as soon as the
        /// break input goes active. It can be cleared by software if the break
        /// input is not active.
        TIM1_bif_t bif : 1;
        /// Break 2 interrupt flag This flag is set by hardware as soon as the
        /// break 2 input goes active. It can be cleared by software if the
        /// break 2 input is not active.
        TIM1_b2if_t b2if : 1;
        /// Capture/Compare 1 overcapture flag This flag is set by hardware only
        /// when the corresponding channel is configured in input capture mode.
        /// It is cleared by software by writing it to '0â.
        TIM1_cc1of_t cc1of : 1;
        /// Capture/Compare 2 overcapture flag Refer to CC1OF description
        uint32_t cc2of : 1;
        /// Capture/Compare 3 overcapture flag Refer to CC1OF description
        uint32_t cc3of : 1;
        /// Capture/Compare 4 overcapture flag Refer to CC1OF description
        uint32_t cc4of : 1;
        /// System Break interrupt flag This flag is set by hardware as soon as
        /// the system break input goes active. It can be cleared by software if
        /// the system break input is not active. This flag must be reset to
        /// re-start PWM operation.
        TIM1_sbif_t    sbif : 1;
        uint32_t const reserved_14 : 2;
        /// Compare 5 interrupt flag Refer to CC1IF description (Note: Channel 5
        /// can only be configured as output)
        uint32_t cc5if : 1;
        /// Compare 6 interrupt flag Refer to CC1IF description (Note: Channel 6
        /// can only be configured as output)
        uint32_t cc6if : 1;
    };
    uint32_t bits;
} TIM1_sr_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_sr_t, sizeof(uint32_t));

/**
 * Update generation This bit can be set by software, it is automatically
 * cleared by hardware.
 */
typedef enum TIM1_ug_e {
    /// No action
    TIM1_ug_b_0x0 = 0x0,
    /// Reinitialize the counter and generates an update of the registers. The
    /// prescaler internal counter is also cleared (the prescaler ratio is not
    /// affected). The counter is cleared if the center-aligned mode is selected
    /// or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR)
    /// if DIR=1 (downcounting).
    TIM1_ug_b_0x1 = 0x1,
} TIM1_ug_t;

/**
 * Capture/Compare 1 generation This bit is set by software in order to generate
 * an event, it is automatically cleared by hardware. If channel CC1 is
 * configured as output: CC1IF flag is set, Corresponding interrupt or DMA
 * request is sent if enabled. If channel CC1 is configured as input: The
 * current value of the counter is captured in TIMx_CCR1 register. The CC1IF
 * flag is set, the corresponding interrupt or DMA request is sent if enabled.
 * The CC1OF flag is set if the CC1IF flag was already high.
 */
typedef enum TIM1_cc1g_e {
    /// No action
    TIM1_cc1g_b_0x0 = 0x0,
    /// A capture/compare event is generated on channel 1:
    TIM1_cc1g_b_0x1 = 0x1,
} TIM1_cc1g_t;

/**
 * Capture/Compare control update generation This bit can be set by software, it
 * is automatically cleared by hardware Note: This bit acts only on channels
 * having a complementary output.
 */
typedef enum TIM1_comg_e {
    /// No action
    TIM1_comg_b_0x0 = 0x0,
    /// When CCPC bit is set, it allows CCxE, CCxNE and OCxM bits to be updated.
    TIM1_comg_b_0x1 = 0x1,
} TIM1_comg_t;

/**
 * Trigger generation This bit is set by software in order to generate an event,
 * it is automatically cleared by hardware.
 */
typedef enum TIM1_tg_e {
    /// No action
    TIM1_tg_b_0x0 = 0x0,
    /// The TIF flag is set in TIMx_SR register. Related interrupt or DMA
    /// transfer can occur if enabled.
    TIM1_tg_b_0x1 = 0x1,
} TIM1_tg_t;

/**
 * Break generation This bit is set by software in order to generate an event,
 * it is automatically cleared by hardware.
 */
typedef enum TIM1_bg_e {
    /// No action
    TIM1_bg_b_0x0 = 0x0,
    /// A break event is generated. MOE bit is cleared and BIF flag is set.
    /// Related interrupt or DMA transfer can occur if enabled.
    TIM1_bg_b_0x1 = 0x1,
} TIM1_bg_t;

/**
 * Break 2 generation This bit is set by software in order to generate an event,
 * it is automatically cleared by hardware.
 */
typedef enum TIM1_b2g_e {
    /// No action
    TIM1_b2g_b_0x0 = 0x0,
    /// A break 2 event is generated. MOE bit is cleared and B2IF flag is set.
    /// Related interrupt can occur if enabled.
    TIM1_b2g_b_0x1 = 0x1,
} TIM1_b2g_t;

/**
 * event generation register
 */
typedef union TIM1_egr_u {
    struct {
        /// Update generation This bit can be set by software, it is
        /// automatically cleared by hardware.
        TIM1_ug_t ug : 1;
        /// Capture/Compare 1 generation This bit is set by software in order to
        /// generate an event, it is automatically cleared by hardware. If
        /// channel CC1 is configured as output: CC1IF flag is set,
        /// Corresponding interrupt or DMA request is sent if enabled. If
        /// channel CC1 is configured as input: The current value of the counter
        /// is captured in TIMx_CCR1 register. The CC1IF flag is set, the
        /// corresponding interrupt or DMA request is sent if enabled. The CC1OF
        /// flag is set if the CC1IF flag was already high.
        TIM1_cc1g_t cc1g : 1;
        /// Capture/Compare 2 generation Refer to CC1G description
        uint32_t cc2g : 1;
        /// Capture/Compare 3 generation Refer to CC1G description
        uint32_t cc3g : 1;
        /// Capture/Compare 4 generation Refer to CC1G description
        uint32_t cc4g : 1;
        /// Capture/Compare control update generation This bit can be set by
        /// software, it is automatically cleared by hardware Note: This bit
        /// acts only on channels having a complementary output.
        TIM1_comg_t comg : 1;
        /// Trigger generation This bit is set by software in order to generate
        /// an event, it is automatically cleared by hardware.
        TIM1_tg_t tg : 1;
        /// Break generation This bit is set by software in order to generate an
        /// event, it is automatically cleared by hardware.
        TIM1_bg_t bg : 1;
        /// Break 2 generation This bit is set by software in order to generate
        /// an event, it is automatically cleared by hardware.
        TIM1_b2g_t b2g : 1;
    };
    uint32_t bits;
} TIM1_egr_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_egr_t, sizeof(uint32_t));

/**
 * Capture/Compare 1 selection This bit-field defines the direction of the
 * channel (input/output) as well as the used input. Note: CC1S bits are
 * writable only when the channel is OFF (CC1E = '0â in TIMx_CCER).
 */
typedef enum TIM1_cc1s_e {
    /// CC1 channel is configured as output
    TIM1_cc1s_b_0x0 = 0x0,
    /// CC1 channel is configured as input, IC1 is mapped on TI1
    TIM1_cc1s_b_0x1 = 0x1,
    /// CC1 channel is configured as input, IC1 is mapped on TI2
    TIM1_cc1s_b_0x2 = 0x2,
    /// CC1 channel is configured as input, IC1 is mapped on TRC. This mode is
    /// working only if an internal trigger input is selected through TS bit
    /// (TIMx_SMCR register)
    TIM1_cc1s_b_0x3 = 0x3,
} TIM1_cc1s_t;

/**
 * Output Compare 1 fast enable This bit decreases the latency between a trigger
 * event and a transition on the timer output. It must be used in one-pulse mode
 * (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon
 * as possible after the starting trigger.
 */
typedef enum TIM1_oc1fe_e {
    /// CC1 behaves normally depending on counter and CCR1 values even when the
    /// trigger is ON. The minimum delay to activate CC1 output when an edge
    /// occurs on the trigger input is 5 clock cycles.
    TIM1_oc1fe_b_0x0 = 0x0,
    /// An active edge on the trigger input acts like a compare match on CC1
    /// output. Then, OC is set to the compare level independently from the
    /// result of the comparison. Delay to sample the trigger input and to
    /// activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the
    /// channel is configured in PWM1 or PWM2 mode.
    TIM1_oc1fe_b_0x1 = 0x1,
} TIM1_oc1fe_t;

/**
 * Output Compare 1 preload enable Note: These bits can not be modified as long
 * as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and
 * CC1S=â00â (the channel is configured in output). The PWM mode can
 * be used without validating the preload register only in one pulse mode (OPM
 * bit set in TIMx_CR1 register). Else the behavior is not guaranteed.
 */
typedef enum TIM1_oc1pe_e {
    /// Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at
    /// anytime, the new value is taken in account immediately.
    TIM1_oc1pe_b_0x0 = 0x0,
    /// Preload register on TIMx_CCR1 enabled. Read/Write operations access the
    /// preload register. TIMx_CCR1 preload value is loaded in the active
    /// register at each update event.
    TIM1_oc1pe_b_0x1 = 0x1,
} TIM1_oc1pe_t;

/**
 * Output Compare 1 mode These bits define the behavior of the output reference
 * signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high
 * whereas OC1 and OC1N active level depends on CC1P and CC1NP bits. Note: These
 * bits can not be modified as long as LOCK level 3 has been programmed (LOCK
 * bits in TIMx_BDTR register) and CC1S=â00â (the channel is
 * configured in output). Note: In PWM mode, the OCREF level changes only when
 * the result of the comparison changes or when the output compare mode switches
 * from
 * âfrozenâ mode to âPWMâ mode. Note: On channels having a
 * complementary output, this bit field is preloaded. If the CCPC bit is set in
 * the TIMx_CR2 register then the OC1M active bits take the new value from the
 * preloaded bits only when a COM event is generated. Note: The OC1M[3] bit is
 * not contiguous, located in bit 16.
 */
typedef enum TIM1_oc1m1_e {
    /// Frozen - The comparison between the output compare register TIMx_CCR1
    /// and the counter TIMx_CNT has no effect on the outputs.(this mode is used
    /// to generate a timing base).
    TIM1_oc1m1_b_0x0 = 0x0,
    /// Set channel 1 to active level on match. OC1REF signal is forced high
    /// when the counter TIMx_CNT matches the capture/compare register 1
    /// (TIMx_CCR1).
    TIM1_oc1m1_b_0x1 = 0x1,
    /// Set channel 1 to inactive level on match. OC1REF signal is forced low
    /// when the counter TIMx_CNT matches the capture/compare register 1
    /// (TIMx_CCR1).
    TIM1_oc1m1_b_0x2 = 0x2,
    /// Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.
    TIM1_oc1m1_b_0x3 = 0x3,
    /// Force inactive level - OC1REF is forced low.
    TIM1_oc1m1_b_0x4 = 0x4,
    /// Force active level - OC1REF is forced high.
    TIM1_oc1m1_b_0x5 = 0x5,
    /// PWM mode 1 - In upcounting, channel 1 is active as long as
    /// TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive
    /// (OC1REF='0â) as long as TIMx_CNT>TIMx_CCR1 else active
    /// (OC1REF=â1â).
    TIM1_oc1m1_b_0x6 = 0x6,
    /// PWM mode 2 - In upcounting, channel 1 is inactive as long as
    /// TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as
    /// long as TIMx_CNT>TIMx_CCR1 else inactive.
    TIM1_oc1m1_b_0x7 = 0x7,
    /// Retrigerrable OPM mode 1 - In up-counting mode, the channel is active
    /// until a trigger event is detected (on TRGI signal). Then, a comparison
    /// is performed as in PWM mode 1 and the channels becomes active again at
    /// the next update. In down-counting mode, the channel is inactive until a
    /// trigger event is detected (on TRGI signal). Then, a comparison is
    /// performed as in PWM mode 1 and the channels becomes inactive again at
    /// the next update.
    TIM1_oc1m1_b_0x8 = 0x8,
    /// Retrigerrable OPM mode 2 - In up-counting mode, the channel is inactive
    /// until a trigger event is detected (on TRGI signal). Then, a comparison
    /// is performed as in PWM mode 2 and the channels becomes inactive again at
    /// the next update. In down-counting mode, the channel is active until a
    /// trigger event is detected (on TRGI signal). Then, a comparison is
    /// performed as in PWM mode 1 and the channels becomes active again at the
    /// next update.
    TIM1_oc1m1_b_0x9 = 0x9,
    /// Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1.
    /// OC1REFC is the logical OR between OC1REF and OC2REF.
    TIM1_oc1m1_b_0xc = 0xC,
    /// Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2.
    /// OC1REFC is the logical AND between OC1REF and OC2REF.
    TIM1_oc1m1_b_0xd = 0xD,
    /// Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1.
    /// OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it
    /// is counting down.
    TIM1_oc1m1_b_0xe = 0xE,
    /// Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2.
    /// OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it
    /// is counting down.
    TIM1_oc1m1_b_0xf = 0xF,
} TIM1_oc1m1_t;

/**
 * Output Compare 1 clear enable
 */
typedef enum TIM1_oc1ce_e {
    /// OC1Ref is not affected by the ocref_clr_int signal
    TIM1_oc1ce_b_0x0 = 0x0,
    /// OC1Ref is cleared as soon as a High level is detected on ocref_clr_int
    /// signal (OCREF_CLR input or ETRF input)
    TIM1_oc1ce_b_0x1 = 0x1,
} TIM1_oc1ce_t;

/**
 * Capture/Compare 2 selection This bit-field defines the direction of the
 * channel (input/output) as well as the used input. Note: CC2S bits are
 * writable only when the channel is OFF (CC2E = '0â in TIMx_CCER).
 */
typedef enum TIM1_cc2s_e {
    /// CC2 channel is configured as output
    TIM1_cc2s_b_0x0 = 0x0,
    /// CC2 channel is configured as input, IC2 is mapped on TI2
    TIM1_cc2s_b_0x1 = 0x1,
    /// CC2 channel is configured as input, IC2 is mapped on TI1
    TIM1_cc2s_b_0x2 = 0x2,
    /// CC2 channel is configured as input, IC2 is mapped on TRC. This mode is
    /// working only if an internal trigger input is selected through the TS bit
    /// (TIMx_SMCR register)
    TIM1_cc2s_b_0x3 = 0x3,
} TIM1_cc2s_t;

/**
 * Output Compare 1 mode These bits define the behavior of the output reference
 * signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high
 * whereas OC1 and OC1N active level depends on CC1P and CC1NP bits. Note: These
 * bits can not be modified as long as LOCK level 3 has been programmed (LOCK
 * bits in TIMx_BDTR register) and CC1S=â00â (the channel is
 * configured in output). Note: In PWM mode, the OCREF level changes only when
 * the result of the comparison changes or when the output compare mode switches
 * from
 * âfrozenâ mode to âPWMâ mode. Note: On channels having a
 * complementary output, this bit field is preloaded. If the CCPC bit is set in
 * the TIMx_CR2 register then the OC1M active bits take the new value from the
 * preloaded bits only when a COM event is generated. Note: The OC1M[3] bit is
 * not contiguous, located in bit 16.
 */
typedef enum TIM1_oc1m2_e {
    /// Frozen - The comparison between the output compare register TIMx_CCR1
    /// and the counter TIMx_CNT has no effect on the outputs.(this mode is used
    /// to generate a timing base).
    TIM1_oc1m2_b_0x0 = 0x0,
    /// Set channel 1 to active level on match. OC1REF signal is forced high
    /// when the counter TIMx_CNT matches the capture/compare register 1
    /// (TIMx_CCR1).
    TIM1_oc1m2_b_0x1 = 0x1,
    /// Set channel 1 to inactive level on match. OC1REF signal is forced low
    /// when the counter TIMx_CNT matches the capture/compare register 1
    /// (TIMx_CCR1).
    TIM1_oc1m2_b_0x2 = 0x2,
    /// Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.
    TIM1_oc1m2_b_0x3 = 0x3,
    /// Force inactive level - OC1REF is forced low.
    TIM1_oc1m2_b_0x4 = 0x4,
    /// Force active level - OC1REF is forced high.
    TIM1_oc1m2_b_0x5 = 0x5,
    /// PWM mode 1 - In upcounting, channel 1 is active as long as
    /// TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive
    /// (OC1REF='0â) as long as TIMx_CNT>TIMx_CCR1 else active
    /// (OC1REF=â1â).
    TIM1_oc1m2_b_0x6 = 0x6,
    /// PWM mode 2 - In upcounting, channel 1 is inactive as long as
    /// TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as
    /// long as TIMx_CNT>TIMx_CCR1 else inactive.
    TIM1_oc1m2_b_0x7 = 0x7,
    /// Retrigerrable OPM mode 1 - In up-counting mode, the channel is active
    /// until a trigger event is detected (on TRGI signal). Then, a comparison
    /// is performed as in PWM mode 1 and the channels becomes active again at
    /// the next update. In down-counting mode, the channel is inactive until a
    /// trigger event is detected (on TRGI signal). Then, a comparison is
    /// performed as in PWM mode 1 and the channels becomes inactive again at
    /// the next update.
    TIM1_oc1m2_b_0x8 = 0x8,
    /// Retrigerrable OPM mode 2 - In up-counting mode, the channel is inactive
    /// until a trigger event is detected (on TRGI signal). Then, a comparison
    /// is performed as in PWM mode 2 and the channels becomes inactive again at
    /// the next update. In down-counting mode, the channel is active until a
    /// trigger event is detected (on TRGI signal). Then, a comparison is
    /// performed as in PWM mode 1 and the channels becomes active again at the
    /// next update.
    TIM1_oc1m2_b_0x9 = 0x9,
    /// Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1.
    /// OC1REFC is the logical OR between OC1REF and OC2REF.
    TIM1_oc1m2_b_0xc = 0xC,
    /// Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2.
    /// OC1REFC is the logical AND between OC1REF and OC2REF.
    TIM1_oc1m2_b_0xd = 0xD,
    /// Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1.
    /// OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it
    /// is counting down.
    TIM1_oc1m2_b_0xe = 0xE,
    /// Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2.
    /// OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it
    /// is counting down.
    TIM1_oc1m2_b_0xf = 0xF,
} TIM1_oc1m2_t;

/**
 * capture/compare mode register 1 (output mode)
 */
typedef union TIM1_ccmr1_output_u {
    struct {
        /// Capture/Compare 1 selection This bit-field defines the direction of
        /// the channel (input/output) as well as the used input. Note: CC1S
        /// bits are writable only when the channel is OFF (CC1E = '0â in
        /// TIMx_CCER).
        TIM1_cc1s_t cc1s : 2;
        /// Output Compare 1 fast enable This bit decreases the latency between
        /// a trigger event and a transition on the timer output. It must be
        /// used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have
        /// the output pulse starting as soon as possible after the starting
        /// trigger.
        TIM1_oc1fe_t oc1fe : 1;
        /// Output Compare 1 preload enable Note: These bits can not be modified
        /// as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR
        /// register) and CC1S=â00â (the channel is configured in
        /// output). The PWM mode can be used without validating the preload
        /// register only in one pulse mode (OPM bit set in TIMx_CR1 register).
        /// Else the behavior is not guaranteed.
        TIM1_oc1pe_t oc1pe : 1;
        /// Output Compare 1 mode These bits define the behavior of the output
        /// reference signal OC1REF from which OC1 and OC1N are derived. OC1REF
        /// is active high whereas OC1 and OC1N active level depends on CC1P and
        /// CC1NP bits. Note: These bits can not be modified as long as LOCK
        /// level 3 has been programmed (LOCK bits in TIMx_BDTR register) and
        /// CC1S=â00â (the channel is configured in output). Note: In
        /// PWM mode, the OCREF level changes only when the result of the
        /// comparison changes or when the output compare mode switches from
        /// âfrozenâ mode to âPWMâ mode. Note: On channels
        /// having a complementary output, this bit field is preloaded. If the
        /// CCPC bit is set in the TIMx_CR2 register then the OC1M active bits
        /// take the new value from the preloaded bits only when a COM event is
        /// generated. Note: The OC1M[3] bit is not contiguous, located in
        /// bit 16.
        TIM1_oc1m1_t oc1m1 : 3;
        /// Output Compare 1 clear enable
        TIM1_oc1ce_t oc1ce : 1;
        /// Capture/Compare 2 selection This bit-field defines the direction of
        /// the channel (input/output) as well as the used input. Note: CC2S
        /// bits are writable only when the channel is OFF (CC2E = '0â in
        /// TIMx_CCER).
        TIM1_cc2s_t cc2s : 2;
        /// Output Compare 2 fast enable Refer to OC1FE description.
        uint32_t oc2fe : 1;
        /// Output Compare 2 preload enable Refer to OC1PE description.
        uint32_t oc2pe : 1;
        /// Output Compare 2 mode Refer to OC1M[3:0] description.
        uint32_t oc2m1 : 3;
        /// Output Compare 2 clear enable Refer to OC1CE description.
        uint32_t oc2ce : 1;
        /// Output Compare 1 mode These bits define the behavior of the output
        /// reference signal OC1REF from which OC1 and OC1N are derived. OC1REF
        /// is active high whereas OC1 and OC1N active level depends on CC1P and
        /// CC1NP bits. Note: These bits can not be modified as long as LOCK
        /// level 3 has been programmed (LOCK bits in TIMx_BDTR register) and
        /// CC1S=â00â (the channel is configured in output). Note: In
        /// PWM mode, the OCREF level changes only when the result of the
        /// comparison changes or when the output compare mode switches from
        /// âfrozenâ mode to âPWMâ mode. Note: On channels
        /// having a complementary output, this bit field is preloaded. If the
        /// CCPC bit is set in the TIMx_CR2 register then the OC1M active bits
        /// take the new value from the preloaded bits only when a COM event is
        /// generated. Note: The OC1M[3] bit is not contiguous, located in
        /// bit 16.
        TIM1_oc1m2_t   oc1m2 : 1;
        uint32_t const reserved_17 : 7;
        /// Output Compare 2 mode Refer to OC1M[3:0] description.
        uint32_t oc2m2 : 1;
    };
    uint32_t bits;
} TIM1_ccmr1_output_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_ccmr1_output_t, sizeof(uint32_t));

/**
 * Input capture 1 prescaler This bit-field defines the ratio of the prescaler
 * acting on CC1 input (IC1). The prescaler is reset as soon as
 * CC1E=â0â (TIMx_CCER register).
 */
typedef enum TIM1_ic1psc_e {
    /// no prescaler, capture is done each time an edge is detected on the
    /// capture input
    TIM1_ic1psc_b_0x0 = 0x0,
    /// capture is done once every 2 events
    TIM1_ic1psc_b_0x1 = 0x1,
    /// capture is done once every 4 events
    TIM1_ic1psc_b_0x2 = 0x2,
    /// capture is done once every 8 events
    TIM1_ic1psc_b_0x3 = 0x3,
} TIM1_ic1psc_t;

/**
 * Input capture 1 filter This bit-field defines the frequency used to sample
 * TI1 input and the length of the digital filter applied to TI1. The digital
 * filter is made of an event counter in which N consecutive events are needed
 * to validate a transition on the output:
 */
typedef enum TIM1_ic1f_e {
    /// No filter, sampling is done at fDTS
    TIM1_ic1f_b_0x0 = 0x00,
    /// fSAMPLING=fCK_INT, N=2
    TIM1_ic1f_b_0x1 = 0x01,
    /// fSAMPLING=fCK_INT, N=4
    TIM1_ic1f_b_0x2 = 0x02,
    /// fSAMPLING=fCK_INT, N=8
    TIM1_ic1f_b_0x3 = 0x03,
    /// fSAMPLING=fDTS/2, N=6
    TIM1_ic1f_b_0x4 = 0x04,
    /// fSAMPLING=fDTS/2, N=8
    TIM1_ic1f_b_0x5 = 0x05,
    /// fSAMPLING=fDTS/4, N=6
    TIM1_ic1f_b_0x6 = 0x06,
    /// fSAMPLING=fDTS/4, N=8
    TIM1_ic1f_b_0x7 = 0x07,
    /// fSAMPLING=fDTS/8, N=6
    TIM1_ic1f_b_0x8 = 0x08,
    /// fSAMPLING=fDTS/8, N=8
    TIM1_ic1f_b_0x9 = 0x09,
    /// fSAMPLING=fDTS/16, N=5
    TIM1_ic1f_b_0xa = 0x0A,
    /// fSAMPLING=fDTS/16, N=6
    TIM1_ic1f_b_0xb = 0x0B,
    /// fSAMPLING=fDTS/16, N=8
    TIM1_ic1f_b_0xc = 0x0C,
    /// fSAMPLING=fDTS/32, N=5
    TIM1_ic1f_b_0xd = 0x0D,
    /// fSAMPLING=fDTS/32, N=6
    TIM1_ic1f_b_0xe = 0x0E,
    /// fSAMPLING=fDTS/32, N=8
    TIM1_ic1f_b_0xf = 0x0F,
} TIM1_ic1f_t;

/**
 * capture/compare mode register 1 (output mode)
 */
typedef union TIM1_ccmr1_input_u {
    struct {
        /// Capture/Compare 1 Selection This bit-field defines the direction of
        /// the channel (input/output) as well as the used input. Note: CC1S
        /// bits are writable only when the channel is OFF (CC1E = '0â in
        /// TIMx_CCER).
        TIM1_cc1s_t cc1s : 2;
        /// Input capture 1 prescaler This bit-field defines the ratio of the
        /// prescaler acting on CC1 input (IC1). The prescaler is reset as soon
        /// as CC1E=â0â (TIMx_CCER register).
        TIM1_ic1psc_t ic1psc : 2;
        /// Input capture 1 filter This bit-field defines the frequency used to
        /// sample TI1 input and the length of the digital filter applied to
        /// TI1. The digital filter is made of an event counter in which N
        /// consecutive events are needed to validate a transition on the
        /// output:
        TIM1_ic1f_t ic1f : 4;
        /// Capture/Compare 2 selection This bit-field defines the direction of
        /// the channel (input/output) as well as the used input. Note: CC2S
        /// bits are writable only when the channel is OFF (CC2E = '0â in
        /// TIMx_CCER).
        TIM1_cc2s_t cc2s : 2;
        /// Input capture 2 prescaler Refer to IC1PSC[1:0] description.
        uint32_t ic2psc : 2;
        /// Input capture 2 filter Refer to IC1F[3:0] description.
        uint32_t ic2f : 4;
    };
    uint32_t bits;
} TIM1_ccmr1_input_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_ccmr1_input_t, sizeof(uint32_t));

/**
 * Capture/Compare 3 selection This bit-field defines the direction of the
 * channel (input/output) as well as the used input. Note: CC3S bits are
 * writable only when the channel is OFF (CC3E = '0â in TIMx_CCER).
 */
typedef enum TIM1_cc3s_e {
    /// CC3 channel is configured as output
    TIM1_cc3s_b_0x0 = 0x0,
    /// CC3 channel is configured as input, IC3 is mapped on TI3
    TIM1_cc3s_b_0x1 = 0x1,
    /// CC3 channel is configured as input, IC3 is mapped on TI4
    TIM1_cc3s_b_0x2 = 0x2,
    /// CC3 channel is configured as input, IC3 is mapped on TRC. This mode is
    /// working only if an internal trigger input is selected through TS bit
    /// (TIMx_SMCR register)
    TIM1_cc3s_b_0x3 = 0x3,
} TIM1_cc3s_t;

/**
 * Capture/Compare 4 selection This bit-field defines the direction of the
 * channel (input/output) as well as the used input. Note: CC4S bits are
 * writable only when the channel is OFF (CC4E = '0â in TIMx_CCER).
 */
typedef enum TIM1_cc4s_e {
    /// CC4 channel is configured as output
    TIM1_cc4s_b_0x0 = 0x0,
    /// CC4 channel is configured as input, IC4 is mapped on TI4
    TIM1_cc4s_b_0x1 = 0x1,
    /// CC4 channel is configured as input, IC4 is mapped on TI3
    TIM1_cc4s_b_0x2 = 0x2,
    /// CC4 channel is configured as input, IC4 is mapped on TRC. This mode is
    /// working only if an internal trigger input is selected through TS bit
    /// (TIMx_SMCR register)
    TIM1_cc4s_b_0x3 = 0x3,
} TIM1_cc4s_t;

/**
 * capture/compare mode register 2 (output mode)
 */
typedef union TIM1_ccmr2_output_u {
    struct {
        /// Capture/Compare 3 selection This bit-field defines the direction of
        /// the channel (input/output) as well as the used input. Note: CC3S
        /// bits are writable only when the channel is OFF (CC3E = '0â in
        /// TIMx_CCER).
        TIM1_cc3s_t cc3s : 2;
        /// Output compare 3 fast enable Refer to OC1FE description.
        uint32_t oc3fe : 1;
        /// Output compare 3 preload enable Refer to OC1PE description.
        uint32_t oc3pe : 1;
        /// Output compare 3 mode Refer to OC1M[3:0] description.
        uint32_t oc3m1 : 3;
        /// Output compare 3 clear enable Refer to OC1CE description.
        uint32_t oc3ce : 1;
        /// Capture/Compare 4 selection This bit-field defines the direction of
        /// the channel (input/output) as well as the used input. Note: CC4S
        /// bits are writable only when the channel is OFF (CC4E = '0â in
        /// TIMx_CCER).
        TIM1_cc4s_t cc4s : 2;
        /// Output compare 4 fast enable Refer to OC1FE description.
        uint32_t oc4fe : 1;
        /// Output compare 4 preload enable Refer to OC1PE description.
        uint32_t oc4pe : 1;
        /// Output compare 4 mode Refer to OC3M[3:0] description.
        uint32_t oc4m1 : 3;
        /// Output compare 4 clear enable Refer to OC1CE description.
        uint32_t oc4ce : 1;
        /// Output compare 3 mode Refer to OC1M[3:0] description.
        uint32_t       oc3m2 : 1;
        uint32_t const reserved_17 : 7;
        /// Output compare 4 mode Refer to OC3M[3:0] description.
        uint32_t oc4m2 : 1;
    };
    uint32_t bits;
} TIM1_ccmr2_output_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_ccmr2_output_t, sizeof(uint32_t));

/**
 * capture/compare mode register 2 (output mode)
 */
typedef union TIM1_ccmr2_input_u {
    struct {
        /// Capture/compare 3 selection This bit-field defines the direction of
        /// the channel (input/output) as well as the used input. Note: CC3S
        /// bits are writable only when the channel is OFF (CC3E = '0â in
        /// TIMx_CCER).
        TIM1_cc3s_t cc3s : 2;
        /// Input capture 3 prescaler Refer to IC1PSC[1:0] description.
        uint32_t ic3psc : 2;
        /// Input capture 3 filter Refer to IC1F[3:0] description.
        uint32_t ic3f : 4;
        /// Capture/Compare 4 selection This bit-field defines the direction of
        /// the channel (input/output) as well as the used input. Note: CC4S
        /// bits are writable only when the channel is OFF (CC4E = '0â in
        /// TIMx_CCER).
        TIM1_cc4s_t cc4s : 2;
        /// Input capture 4 prescaler Refer to IC1PSC[1:0] description.
        uint32_t ic4psc : 2;
        /// Input capture 4 filter Refer to IC1F[3:0] description.
        uint32_t ic4f : 4;
    };
    uint32_t bits;
} TIM1_ccmr2_input_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_ccmr2_input_t, sizeof(uint32_t));

/**
 * Capture/Compare 1 output enable When CC1 channel is configured as output, the
 * OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless
 * of the CC1E bits state. Refer to for details. Note: On channels having a
 * complementary output, this bit is preloaded. If the CCPC bit is set in the
 * TIMx_CR2 register then the CC1E active bit takes the new value from the
 * preloaded bit only when a Commutation event is generated.
 */
typedef enum TIM1_cc1e_e {
    /// Capture mode disabled / OC1 is not active (see below)
    TIM1_cc1e_b_0x0 = 0x0,
    /// Capture mode enabled / OC1 signal is output on the corresponding output
    /// pin
    TIM1_cc1e_b_0x1 = 0x1,
} TIM1_cc1e_t;

/**
 * Capture/Compare 1 output polarity When CC1 channel is configured as input,
 * both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for
 * trigger or capture operations. CC1NP=0, CC1P=0: non-inverted/rising edge. The
 * circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in
 * reset, external clock or trigger mode), TIxFP1 is not inverted (trigger
 * operation in gated mode or encoder mode). CC1NP=0, CC1P=1: inverted/falling
 * edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger
 * operations in reset, external clock or trigger mode), TIxFP1 is inverted
 * (trigger operation in gated mode or encoder mode). CC1NP=1, CC1P=1:
 * non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and
 * falling edges (capture or trigger operations in reset, external clock or
 * trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This
 * configuration must not be used in encoder mode. CC1NP=1, CC1P=0: The
 * configuration is reserved, it must not be used. Note: This bit is not
 * writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in
 * TIMx_BDTR register). On channels having a complementary output, this bit is
 * preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P
 * active bit takes the new value from the preloaded bit only when a Commutation
 * event is generated.
 */
typedef enum TIM1_cc1p_e {
    /// OC1 active high (output mode) / Edge sensitivity selection (input mode,
    /// see below)
    TIM1_cc1p_b_0x0 = 0x0,
    /// OC1 active low (output mode) / Edge sensitivity selection (input mode,
    /// see below)
    TIM1_cc1p_b_0x1 = 0x1,
} TIM1_cc1p_t;

/**
 * Capture/Compare 1 complementary output enable On channels having a
 * complementary output, this bit is preloaded. If the CCPC bit is set in the
 * TIMx_CR2 register then the CC1NE active bit takes the new value from the
 * preloaded bit only when a Commutation event is generated.
 */
typedef enum TIM1_cc1ne_e {
    /// Off - OC1N is not active. OC1N level is then function of MOE, OSSI,
    /// OSSR, OIS1, OIS1N and CC1E bits.
    TIM1_cc1ne_b_0x0 = 0x0,
    /// On - OC1N signal is output on the corresponding output pin depending on
    /// MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
    TIM1_cc1ne_b_0x1 = 0x1,
} TIM1_cc1ne_t;

/**
 * Capture/Compare 1 complementary output polarity CC1 channel configured as
 * output: CC1 channel configured as input: This bit is used in conjunction with
 * CC1P to define the polarity of TI1FP1 and TI2FP1. Refer to CC1P description.
 * Note: This bit is not writable as soon as LOCK level 2 or 3 has been
 * programmed (LOCK bits in TIMx_BDTR register) and CC1S=â00â (channel
 * configured as output). On channels having a complementary output, this bit is
 * preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP
 * active bit takes the new value from the preloaded bit only when a Commutation
 * event is generated.
 */
typedef enum TIM1_cc1np_e {
    /// OC1N active high.
    TIM1_cc1np_b_0x0 = 0x0,
    /// OC1N active low.
    TIM1_cc1np_b_0x1 = 0x1,
} TIM1_cc1np_t;

/**
 * capture/compare enable register
 */
typedef union TIM1_ccer_u {
    struct {
        /// Capture/Compare 1 output enable When CC1 channel is configured as
        /// output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and
        /// CC1NE bits, regardless of the CC1E bits state. Refer to for details.
        /// Note: On channels having a complementary output, this bit is
        /// preloaded. If the CCPC bit is set in the TIMx_CR2 register then the
        /// CC1E active bit takes the new value from the preloaded bit only when
        /// a Commutation event is generated.
        TIM1_cc1e_t cc1e : 1;
        /// Capture/Compare 1 output polarity When CC1 channel is configured as
        /// input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and
        /// TI2FP1 for trigger or capture operations. CC1NP=0, CC1P=0:
        /// non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising
        /// edge (capture or trigger operations in reset, external clock or
        /// trigger mode), TIxFP1 is not inverted (trigger operation in gated
        /// mode or encoder mode). CC1NP=0, CC1P=1: inverted/falling edge. The
        /// circuit is sensitive to TIxFP1 falling edge (capture or trigger
        /// operations in reset, external clock or trigger mode), TIxFP1 is
        /// inverted (trigger operation in gated mode or encoder mode). CC1NP=1,
        /// CC1P=1: non-inverted/both edges/ The circuit is sensitive to both
        /// TIxFP1 rising and falling edges (capture or trigger operations in
        /// reset, external clock or trigger mode), TIxFP1is not inverted
        /// (trigger operation in gated mode). This configuration must not be
        /// used in encoder mode. CC1NP=1, CC1P=0: The configuration is
        /// reserved, it must not be used. Note: This bit is not writable as
        /// soon as LOCK level 2 or 3 has been programmed (LOCK bits in
        /// TIMx_BDTR register). On channels having a complementary output, this
        /// bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register
        /// then the CC1P active bit takes the new value from the preloaded bit
        /// only when a Commutation event is generated.
        TIM1_cc1p_t cc1p : 1;
        /// Capture/Compare 1 complementary output enable On channels having a
        /// complementary output, this bit is preloaded. If the CCPC bit is set
        /// in the TIMx_CR2 register then the CC1NE active bit takes the new
        /// value from the preloaded bit only when a Commutation event is
        /// generated.
        TIM1_cc1ne_t cc1ne : 1;
        /// Capture/Compare 1 complementary output polarity CC1 channel
        /// configured as output: CC1 channel configured as input: This bit is
        /// used in conjunction with CC1P to define the polarity of TI1FP1 and
        /// TI2FP1. Refer to CC1P description. Note: This bit is not writable as
        /// soon as LOCK level 2 or 3 has been programmed (LOCK bits in
        /// TIMx_BDTR register) and CC1S=â00â (channel configured as
        /// output). On channels having a complementary output, this bit is
        /// preloaded. If the CCPC bit is set in the TIMx_CR2 register then the
        /// CC1NP active bit takes the new value from the preloaded bit only
        /// when a Commutation event is generated.
        TIM1_cc1np_t cc1np : 1;
        /// Capture/Compare 2 output enable Refer to CC1E description
        uint32_t cc2e : 1;
        /// Capture/Compare 2 output polarity Refer to CC1P description
        uint32_t cc2p : 1;
        /// Capture/Compare 2 complementary output enable Refer to CC1NE
        /// description
        uint32_t cc2ne : 1;
        /// Capture/Compare 2 complementary output polarity Refer to CC1NP
        /// description
        uint32_t cc2np : 1;
        /// Capture/Compare 3 output enable Refer to CC1E description
        uint32_t cc3e : 1;
        /// Capture/Compare 3 output polarity Refer to CC1P description
        uint32_t cc3p : 1;
        /// Capture/Compare 3 complementary output enable Refer to CC1NE
        /// description
        uint32_t cc3ne : 1;
        /// Capture/Compare 3 complementary output polarity Refer to CC1NP
        /// description
        uint32_t cc3np : 1;
        /// Capture/Compare 4 output enable Refer to CC1E description
        uint32_t cc4e : 1;
        /// Capture/Compare 4 output polarity Refer to CC1P description
        uint32_t       cc4p : 1;
        uint32_t const reserved_14 : 1;
        /// Capture/Compare 4 complementary output polarity Refer to CC1NP
        /// description
        uint32_t cc4np : 1;
        /// Capture/Compare 5 output enable Refer to CC1E description
        uint32_t cc5e : 1;
        /// Capture/Compare 5 output polarity Refer to CC1P description
        uint32_t       cc5p : 1;
        uint32_t const reserved_18 : 2;
        /// Capture/Compare 6 output enable Refer to CC1E description
        uint32_t cc6e : 1;
        /// Capture/Compare 6 output polarity Refer to CC1P description
        uint32_t cc6p : 1;
    };
    uint32_t bits;
} TIM1_ccer_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_ccer_t, sizeof(uint32_t));

/**
 * counter
 */
typedef union TIM1_cnt_u {
    struct {
        /// Counter value
        uint32_t       cnt : 16;
        uint32_t const reserved_16 : 15;
        /// UIF copy This bit is a read-only copy of the UIF bit of the TIMx_ISR
        /// register. If the UIFREMAP bit in the TIMxCR1 is reset, bit 31 is
        /// reserved and read at 0.
        uint32_t const uifcpy : 1;
    };
    uint32_t bits;
} TIM1_cnt_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_cnt_t, sizeof(uint32_t));

/**
 * prescaler
 */
typedef union TIM1_psc_u {
    struct {
        /// Prescaler value The counter clock frequency (CK_CNT) is equal to
        /// fCK_PSC / (PSC[15:0] + 1). PSC contains the value to be loaded in
        /// the active prescaler register at each update event (including when
        /// the counter is cleared through UG bit of TIMx_EGR register or
        /// through trigger controller when configured in âreset
        /// modeâ).
        uint32_t psc : 16;
    };
    uint32_t bits;
} TIM1_psc_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_psc_t, sizeof(uint32_t));

/**
 * auto-reload register
 */
typedef union TIM1_arr_u {
    struct {
        /// Auto-reload value ARR is the value to be loaded in the actual
        /// auto-reload register. Refer to the for more details about ARR update
        /// and behavior. The counter is blocked while the auto-reload value is
        /// null.
        uint32_t arr : 16;
    };
    uint32_t bits;
} TIM1_arr_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_arr_t, sizeof(uint32_t));

/**
 * repetition counter register
 */
typedef union TIM1_rcr_u {
    struct {
        /// Repetition counter value
        uint32_t rep : 16;
    };
    uint32_t bits;
} TIM1_rcr_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_rcr_t, sizeof(uint32_t));

/**
 * capture/compare register 1
 */
typedef union TIM1_ccr1_u {
    struct {
        /// Capture/Compare 1 value
        uint32_t ccr1 : 16;
    };
    uint32_t bits;
} TIM1_ccr1_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_ccr1_t, sizeof(uint32_t));

/**
 * capture/compare register 2
 */
typedef union TIM1_ccr2_u {
    struct {
        /// Capture/Compare 2 value
        uint32_t ccr2 : 16;
    };
    uint32_t bits;
} TIM1_ccr2_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_ccr2_t, sizeof(uint32_t));

/**
 * capture/compare register 3
 */
typedef union TIM1_ccr3_u {
    struct {
        /// Capture/Compare value
        uint32_t ccr3 : 16;
    };
    uint32_t bits;
} TIM1_ccr3_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_ccr3_t, sizeof(uint32_t));

/**
 * capture/compare register 4
 */
typedef union TIM1_ccr4_u {
    struct {
        /// Capture/Compare value
        uint32_t ccr4 : 16;
    };
    uint32_t bits;
} TIM1_ccr4_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_ccr4_t, sizeof(uint32_t));

/**
 * Lock configuration These bits offer a write protection against software
 * errors. Note: The LOCK bits can be written only once after the reset. Once
 * the TIMx_BDTR register has been written, their content is frozen until the
 * next reset.
 */
typedef enum TIM1_lock_e {
    /// LOCK OFF - No bit is write protected.
    TIM1_lock_b_0x0 = 0x0,
    /// LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in
    /// TIMx_CR2 register and BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E,
    /// BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] bits in
    /// TIMx_BDTR register can no longer be written.
    TIM1_lock_b_0x1 = 0x1,
    /// LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in
    /// TIMx_CCER register, as long as the related channel is configured in
    /// output through the CCxS bits) as well as OSSR and OSSI bits can no
    /// longer be written.
    TIM1_lock_b_0x2 = 0x2,
    /// LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in
    /// TIMx_CCMRx registers, as long as the related channel is configured in
    /// output through the CCxS bits) can no longer be written.
    TIM1_lock_b_0x3 = 0x3,
} TIM1_lock_t;

/**
 * Off-state selection for Idle mode This bit is used when MOE=0 due to a break
 * event or by a software write, on channels configured as outputs. See OC/OCN
 * enable description for more details (enable register
 * (TIM1_CCERTIMx_CCER)N/A). Note: This bit can not be modified as soon as the
 * LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).
 */
typedef enum TIM1_ossi_e {
    /// When inactive, OC/OCN outputs are disabled (the timer releases the
    /// output control which is taken over by the GPIO logic and which imposes a
    /// Hi-Z state).
    TIM1_ossi_b_0x0 = 0x0,
    /// When inactive, OC/OCN outputs are first forced with their inactive level
    /// then forced to their idle level after the deadtime. The timer maintains
    /// its control over the output.
    TIM1_ossi_b_0x1 = 0x1,
} TIM1_ossi_t;

/**
 * Off-state selection for Run mode This bit is used when MOE=1 on channels
 * having a complementary output which are configured as outputs. OSSR is not
 * implemented if no complementary output is implemented in the timer. See
 * OC/OCN enable description for more details (enable register
 * (TIM1_CCERTIMx_CCER)N/A). Note: This bit can not be modified as soon as the
 * LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).
 */
typedef enum TIM1_ossr_e {
    /// When inactive, OC/OCN outputs are disabled (the timer releases the
    /// output control which is taken over by the GPIO logic, which forces a
    /// Hi-Z state).
    TIM1_ossr_b_0x0 = 0x0,
    /// When inactive, OC/OCN outputs are enabled with their inactive level as
    /// soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer).
    TIM1_ossr_b_0x1 = 0x1,
} TIM1_ossr_t;

/**
 * Break enable This bit enables the complete break protection (including all
 * sources connected to bk_acth and BKIN sources, as per ). Note: This bit
 * cannot be modified when LOCK level 1 has been programmed (LOCK bits in
 * TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1
 * APB clock cycle to become effective.
 */
typedef enum TIM1_bke_e {
    /// Break function disabled
    TIM1_bke_b_0x0 = 0x0,
    /// Break function enabled
    TIM1_bke_b_0x1 = 0x1,
} TIM1_bke_t;

/**
 * Break polarity Note: This bit can not be modified as long as LOCK level 1 has
 * been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation
 * to this bit takes a delay of 1 APB clock cycle to become effective.
 */
typedef enum TIM1_bkp_e {
    /// Break input BRK is active low
    TIM1_bkp_b_0x0 = 0x0,
    /// Break input BRK is active high
    TIM1_bkp_b_0x1 = 0x1,
} TIM1_bkp_t;

/**
 * Automatic output enable Note: This bit can not be modified as long as LOCK
 * level 1 has been programmed (LOCK bits in TIMx_BDTR register).
 */
typedef enum TIM1_aoe_e {
    /// MOE can be set only by software
    TIM1_aoe_b_0x0 = 0x0,
    /// MOE can be set by software or automatically at the next update event (if
    /// none of the break inputs BRK and BRK2 is active)
    TIM1_aoe_b_0x1 = 0x1,
} TIM1_aoe_t;

/**
 * Main output enable This bit is cleared asynchronously by hardware as soon as
 * one of the break inputs is active (BRK or BRK2). It is set by software or
 * automatically depending on the AOE bit. It is acting only on the channels
 * which are configured in output. In response to a break event or if MOE is
 * written to 0: OC and OCN outputs are disabled or forced to idle state
 * depending on the OSSI bit. See OC/OCN enable description for more details
 * (enable register (TIM1_CCERTIMx_CCER)N/A).
 */
typedef enum TIM1_moe_e {
    /// In response to a break 2 event. OC and OCN outputs are disabled
    TIM1_moe_b_0x0 = 0x0,
    /// OC and OCN outputs are enabled if their respective enable bits are set
    /// (CCxE, CCxNE in TIMx_CCER register).
    TIM1_moe_b_0x1 = 0x1,
} TIM1_moe_t;

/**
 * Break filter This bit-field defines the frequency used to sample BRK input
 * and the length of the digital filter applied to BRK. The digital filter is
 * made of an event counter in which N consecutive events are needed to validate
 * a transition on the output: Note: This bit cannot be modified when LOCK level
 * 1 has been programmed (LOCK bits in TIMx_BDTR register).
 */
typedef enum TIM1_bkf_e {
    /// No filter, BRK acts asynchronously
    TIM1_bkf_b_0x0 = 0x00,
    /// fSAMPLING=fCK_INT, N=2
    TIM1_bkf_b_0x1 = 0x01,
    /// fSAMPLING=fCK_INT, N=4
    TIM1_bkf_b_0x2 = 0x02,
    /// fSAMPLING=fCK_INT, N=8
    TIM1_bkf_b_0x3 = 0x03,
    /// fSAMPLING=fDTS/2, N=6
    TIM1_bkf_b_0x4 = 0x04,
    /// fSAMPLING=fDTS/2, N=8
    TIM1_bkf_b_0x5 = 0x05,
    /// fSAMPLING=fDTS/4, N=6
    TIM1_bkf_b_0x6 = 0x06,
    /// fSAMPLING=fDTS/4, N=8
    TIM1_bkf_b_0x7 = 0x07,
    /// fSAMPLING=fDTS/8, N=6
    TIM1_bkf_b_0x8 = 0x08,
    /// fSAMPLING=fDTS/8, N=8
    TIM1_bkf_b_0x9 = 0x09,
    /// fSAMPLING=fDTS/16, N=5
    TIM1_bkf_b_0xa = 0x0A,
    /// fSAMPLING=fDTS/16, N=6
    TIM1_bkf_b_0xb = 0x0B,
    /// fSAMPLING=fDTS/16, N=8
    TIM1_bkf_b_0xc = 0x0C,
    /// fSAMPLING=fDTS/32, N=5
    TIM1_bkf_b_0xd = 0x0D,
    /// fSAMPLING=fDTS/32, N=6
    TIM1_bkf_b_0xe = 0x0E,
    /// fSAMPLING=fDTS/32, N=8
    TIM1_bkf_b_0xf = 0x0F,
} TIM1_bkf_t;

/**
 * Break 2 filter This bit-field defines the frequency used to sample BRK2 input
 * and the length of the digital filter applied to BRK2. The digital filter is
 * made of an event counter in which N consecutive events are needed to validate
 * a transition on the output: Note: This bit cannot be modified when LOCK level
 * 1 has been programmed (LOCK bits in TIMx_BDTR register).
 */
typedef enum TIM1_bk2f_e {
    /// No filter, BRK2 acts asynchronously
    TIM1_bk2f_b_0x0 = 0x00,
    /// fSAMPLING=fCK_INT, N=2
    TIM1_bk2f_b_0x1 = 0x01,
    /// fSAMPLING=fCK_INT, N=4
    TIM1_bk2f_b_0x2 = 0x02,
    /// fSAMPLING=fCK_INT, N=8
    TIM1_bk2f_b_0x3 = 0x03,
    /// fSAMPLING=fDTS/2, N=6
    TIM1_bk2f_b_0x4 = 0x04,
    /// fSAMPLING=fDTS/2, N=8
    TIM1_bk2f_b_0x5 = 0x05,
    /// fSAMPLING=fDTS/4, N=6
    TIM1_bk2f_b_0x6 = 0x06,
    /// fSAMPLING=fDTS/4, N=8
    TIM1_bk2f_b_0x7 = 0x07,
    /// fSAMPLING=fDTS/8, N=6
    TIM1_bk2f_b_0x8 = 0x08,
    /// fSAMPLING=fDTS/8, N=8
    TIM1_bk2f_b_0x9 = 0x09,
    /// fSAMPLING=fDTS/16, N=5
    TIM1_bk2f_b_0xa = 0x0A,
    /// fSAMPLING=fDTS/16, N=6
    TIM1_bk2f_b_0xb = 0x0B,
    /// fSAMPLING=fDTS/16, N=8
    TIM1_bk2f_b_0xc = 0x0C,
    /// fSAMPLING=fDTS/32, N=5
    TIM1_bk2f_b_0xd = 0x0D,
    /// fSAMPLING=fDTS/32, N=6
    TIM1_bk2f_b_0xe = 0x0E,
    /// fSAMPLING=fDTS/32, N=8
    TIM1_bk2f_b_0xf = 0x0F,
} TIM1_bk2f_t;

/**
 * Break 2 enable Note: The BRK2 must only be used with OSSR = OSSI = 1. Note:
 * This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits
 * in TIMx_BDTR register). Note: Any write operation to this bit takes a delay
 * of 1 APB clock cycle to become effective.
 */
typedef enum TIM1_bk2e_e {
    /// Break input BRK2 disabled
    TIM1_bk2e_b_0x0 = 0x0,
    /// Break input BRK2 enabled
    TIM1_bk2e_b_0x1 = 0x1,
} TIM1_bk2e_t;

/**
 * Break 2 polarity Note: This bit cannot be modified as long as LOCK level 1
 * has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write
 * operation to this bit takes a delay of 1 APB clock cycle to become effective.
 */
typedef enum TIM1_bk2p_e {
    /// Break input BRK2 is active low
    TIM1_bk2p_b_0x0 = 0x0,
    /// Break input BRK2 is active high
    TIM1_bk2p_b_0x1 = 0x1,
} TIM1_bk2p_t;

/**
 * Break Disarm This bit is cleared by hardware when no break source is active.
 * The BKDSRM bit must be set by software to release the bidirectional output
 * control (open-drain output in Hi-Z state) and then be polled it until it is
 * reset by hardware, indicating that the fault condition has disappeared. Note:
 * Any write operation to this bit takes a delay of 1 APB clock cycle to become
 * effective.
 */
typedef enum TIM1_bkdsrm_e {
    /// Break input BRK is armed
    TIM1_bkdsrm_b_0x0 = 0x0,
    /// Break input BRK is disarmed
    TIM1_bkdsrm_b_0x1 = 0x1,
} TIM1_bkdsrm_t;

/**
 * Break Bidirectional In the bidirectional mode (BKBID bit set to 1), the break
 * input is configured both in input mode and in open drain output mode. Any
 * active break event asserts a low logic level on the Break input to indicate
 * an internal break event to external devices. Note: This bit cannot be
 * modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR
 * register). Note: Any write operation to this bit takes a delay of 1 APB clock
 * cycle to become effective.
 */
typedef enum TIM1_bkbid_e {
    /// Break input BRK in input mode
    TIM1_bkbid_b_0x0 = 0x0,
    /// Break input BRK in bidirectional mode
    TIM1_bkbid_b_0x1 = 0x1,
} TIM1_bkbid_t;

/**
 * break and dead-time register
 */
typedef union TIM1_bdtr_u {
    struct {
        /// Dead-time generator setup This bit-field defines the duration of the
        /// dead-time inserted between the complementary outputs. DT correspond
        /// to this duration. DTG[7:5]=0xx => DT=DTG[7:0]x tDTG with tDTG=tDTS.
        /// DTG[7:5]=10x => DT=(64+DTG[5:0])xtDTG with tDTG=2xtDTS. DTG[7:5]=110
        /// => DT=(32+DTG[4:0])xtDTG with tDTG=8xtDTS. DTG[7:5]=111 =>
        /// DT=(32+DTG[4:0])xtDTG with tDTG=16xtDTS. Example if tDTS=125Â ns (8Â
        /// MHz), dead-time possible values are: 0 to 15875Â ns by 125Â ns
        /// steps, 16Â Î¼s to 31750Â nsÂ by 250Â ns steps, 32Â Î¼s to 63Â Î¼s by
        /// 1Â Î¼s steps, 64Â Î¼s to 126Â Î¼s by 2Â Î¼s steps Note: This
        /// bit-field can not be modified as long as LOCK level 1, 2 or 3 has
        /// been programmed (LOCK bits in TIMx_BDTR register).
        uint32_t dtg : 8;
        /// Lock configuration These bits offer a write protection against
        /// software errors. Note: The LOCK bits can be written only once after
        /// the reset. Once the TIMx_BDTR register has been written, their
        /// content is frozen until the next reset.
        TIM1_lock_t lock : 2;
        /// Off-state selection for Idle mode This bit is used when MOE=0 due to
        /// a break event or by a software write, on channels configured as
        /// outputs. See OC/OCN enable description for more details (enable
        /// register (TIM1_CCERTIMx_CCER)N/A). Note: This bit can not be
        /// modified as soon as the LOCK level 2 has been programmed (LOCK bits
        /// in TIMx_BDTR register).
        TIM1_ossi_t ossi : 1;
        /// Off-state selection for Run mode This bit is used when MOE=1 on
        /// channels having a complementary output which are configured as
        /// outputs. OSSR is not implemented if no complementary output is
        /// implemented in the timer. See OC/OCN enable description for more
        /// details (enable register (TIM1_CCERTIMx_CCER)N/A). Note: This bit
        /// can not be modified as soon as the LOCK level 2 has been programmed
        /// (LOCK bits in TIMx_BDTR register).
        TIM1_ossr_t ossr : 1;
        /// Break enable This bit enables the complete break protection
        /// (including all sources connected to bk_acth and BKIN sources, as per
        /// ). Note: This bit cannot be modified when LOCK level 1 has been
        /// programmed (LOCK bits in TIMx_BDTR register). Note: Any write
        /// operation to this bit takes a delay of 1 APB clock cycle to become
        /// effective.
        TIM1_bke_t bke : 1;
        /// Break polarity Note: This bit can not be modified as long as LOCK
        /// level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note:
        /// Any write operation to this bit takes a delay of 1 APB clock cycle
        /// to become effective.
        TIM1_bkp_t bkp : 1;
        /// Automatic output enable Note: This bit can not be modified as long
        /// as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR
        /// register).
        TIM1_aoe_t aoe : 1;
        /// Main output enable This bit is cleared asynchronously by hardware as
        /// soon as one of the break inputs is active (BRK or BRK2). It is set
        /// by software or automatically depending on the AOE bit. It is acting
        /// only on the channels which are configured in output. In response to
        /// a break event or if MOE is written to 0: OC and OCN outputs are
        /// disabled or forced to idle state depending on the OSSI bit. See
        /// OC/OCN enable description for more details (enable register
        /// (TIM1_CCERTIMx_CCER)N/A).
        TIM1_moe_t moe : 1;
        /// Break filter This bit-field defines the frequency used to sample BRK
        /// input and the length of the digital filter applied to BRK. The
        /// digital filter is made of an event counter in which N consecutive
        /// events are needed to validate a transition on the output: Note: This
        /// bit cannot be modified when LOCK level 1 has been programmed (LOCK
        /// bits in TIMx_BDTR register).
        TIM1_bkf_t bkf : 4;
        /// Break 2 filter This bit-field defines the frequency used to sample
        /// BRK2 input and the length of the digital filter applied to BRK2. The
        /// digital filter is made of an event counter in which N consecutive
        /// events are needed to validate a transition on the output: Note: This
        /// bit cannot be modified when LOCK level 1 has been programmed (LOCK
        /// bits in TIMx_BDTR register).
        TIM1_bk2f_t bk2f : 4;
        /// Break 2 enable Note: The BRK2 must only be used with OSSR = OSSI
        /// = 1. Note: This bit cannot be modified when LOCK level 1 has been
        /// programmed (LOCK bits in TIMx_BDTR register). Note: Any write
        /// operation to this bit takes a delay of 1 APB clock cycle to become
        /// effective.
        TIM1_bk2e_t bk2e : 1;
        /// Break 2 polarity Note: This bit cannot be modified as long as LOCK
        /// level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note:
        /// Any write operation to this bit takes a delay of 1 APB clock cycle
        /// to become effective.
        TIM1_bk2p_t bk2p : 1;
        /// Break Disarm This bit is cleared by hardware when no break source is
        /// active. The BKDSRM bit must be set by software to release the
        /// bidirectional output control (open-drain output in Hi-Z state) and
        /// then be polled it until it is reset by hardware, indicating that the
        /// fault condition has disappeared. Note: Any write operation to this
        /// bit takes a delay of 1 APB clock cycle to become effective.
        TIM1_bkdsrm_t bkdsrm : 1;
        /// Break2 Disarm Refer to BKDSRM description
        uint32_t bk2dsrm : 1;
        /// Break Bidirectional In the bidirectional mode (BKBID bit set to 1),
        /// the break input is configured both in input mode and in open drain
        /// output mode. Any active break event asserts a low logic level on the
        /// Break input to indicate an internal break event to external devices.
        /// Note: This bit cannot be modified as long as LOCK level 1 has been
        /// programmed (LOCK bits in TIMx_BDTR register). Note: Any write
        /// operation to this bit takes a delay of 1 APB clock cycle to become
        /// effective.
        TIM1_bkbid_t bkbid : 1;
        /// Break2 bidirectional Refer to BKBID description
        uint32_t bk2bid : 1;
    };
    uint32_t bits;
} TIM1_bdtr_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_bdtr_t, sizeof(uint32_t));

/**
 * DMA base address This 5-bits vector defines the base-address for DMA
 * transfers (when read/write access are done through the TIMx_DMAR address).
 * DBA is defined as an offset starting from the address of the TIMx_CR1
 * register. Example: ...
 */
typedef enum TIM1_dba_e {
    /// TIMx_CR1,
    TIM1_dba_b_0x0 = 0x00,
    /// TIMx_CR2,
    TIM1_dba_b_0x1 = 0x01,
    /// TIMx_SMCR,
    TIM1_dba_b_0x2 = 0x02,
} TIM1_dba_t;

/**
 * DMA burst length This 5-bit vector defines the length of DMA transfers (the
 * timer recognizes a burst transfer when a read or a write access is done to
 * the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in
 * half-words or in bytes (see example below). ... Example: Let us consider the
 * following transfer: DBL = 7 bytes & DBA = TIMx_CR1. If DBL = 7 bytes and DBA
 * = TIMx_CR1 represents the address of the byte to be transferred, the address
 * of the transfer should be given by the following equation: (TIMx_CR1 address)
 * + DBA + (DMA index), where DMA index = DBL In this example, 7 bytes are added
 * to (TIMx_CR1 address) + DBA, which gives us the address from/to which the
 * data is copied. In this case, the transfer is done to 7 registers starting
 * from the following address: (TIMx_CR1 address) + DBA According to the
 * configuration of the DMA Data Size, several cases may occur: If the DMA Data
 * Size is configured in half-words, 16-bit data is transferred to each of the 7
 * registers. If the DMA Data Size is configured in bytes, the data is also
 * transferred to 7 registers: the first register contains the first MSB byte,
 * the second register, the first LSB byte and so on. So with the transfer
 * Timer, one also has to specify the size of data transferred by DMA.
 */
typedef enum TIM1_dbl_e {
    /// 1 transfer
    TIM1_dbl_b_0x0 = 0x00,
    /// 2 transfers
    TIM1_dbl_b_0x1 = 0x01,
    /// 3 transfers
    TIM1_dbl_b_0x2 = 0x02,
    /// 18 transfers
    TIM1_dbl_b_0x11 = 0x11,
} TIM1_dbl_t;

/**
 * DMA control register
 */
typedef union TIM1_dcr_u {
    struct {
        /// DMA base address This 5-bits vector defines the base-address for DMA
        /// transfers (when read/write access are done through the TIMx_DMAR
        /// address). DBA is defined as an offset starting from the address of
        /// the TIMx_CR1 register. Example: ...
        TIM1_dba_t     dba : 5;
        uint32_t const reserved_05 : 3;
        /// DMA burst length This 5-bit vector defines the length of DMA
        /// transfers (the timer recognizes a burst transfer when a read or a
        /// write access is done to the TIMx_DMAR address), i.e. the number of
        /// transfers. Transfers can be in half-words or in bytes (see example
        /// below). ... Example: Let us consider the following transfer: DBL = 7
        /// bytes & DBA = TIMx_CR1. If DBL = 7 bytes and DBA = TIMx_CR1
        /// represents the address of the byte to be transferred, the address of
        /// the transfer should be given by the following equation: (TIMx_CR1
        /// address) + DBA + (DMA index), where DMA index = DBL In this example,
        /// 7 bytes are added to (TIMx_CR1 address) + DBA, which gives us the
        /// address from/to which the data is copied. In this case, the transfer
        /// is done to 7 registers starting from the following address:
        /// (TIMx_CR1 address) + DBA According to the configuration of the DMA
        /// Data Size, several cases may occur: If the DMA Data Size is
        /// configured in half-words, 16-bit data is transferred to each of the
        /// 7 registers. If the DMA Data Size is configured in bytes, the data
        /// is also transferred to 7 registers: the first register contains the
        /// first MSB byte, the second register, the first LSB byte and so on.
        /// So with the transfer Timer, one also has to specify the size of data
        /// transferred by DMA.
        TIM1_dbl_t dbl : 5;
    };
    uint32_t bits;
} TIM1_dcr_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_dcr_t, sizeof(uint32_t));

/**
 * DMA address for full transfer
 */
typedef union TIM1_dmar_u {
    struct {
        /// DMA register for burst accesses A read or write operation to the
        /// DMAR register accesses the register located at the address (TIMx_CR1
        /// address) + (DBA + DMA index) x 4 where TIMx_CR1 address is the
        /// address of the control register 1, DBA is the DMA base address
        /// configured in TIMx_DCR register, DMA index is automatically
        /// controlled by the DMA transfer, and ranges from 0 to DBL (DBL
        /// configured in TIMx_DCR).
        uint32_t dmab : 32;
    };
    uint32_t bits;
} TIM1_dmar_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_dmar_t, sizeof(uint32_t));

/**
 * Ocref_clr source selection This bit selects the ocref_clr input source.
 */
typedef enum TIM1_ocref_clr_e {
    /// COMP1 output is connected to the OCREF_CLR input
    TIM1_ocref_clr_b_0x0 = 0x0,
    /// COMP2 output is connected to the OCREF_CLR input
    TIM1_ocref_clr_b_0x1 = 0x1,
} TIM1_ocref_clr_t;

/**
 * option register 1
 */
typedef union TIM1_or1_u {
    struct {
        /// Ocref_clr source selection This bit selects the ocref_clr input
        /// source.
        TIM1_ocref_clr_t ocref_clr : 1;
    };
    uint32_t bits;
} TIM1_or1_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_or1_t, sizeof(uint32_t));

/**
 * capture/compare mode register 2 (output mode)
 */
typedef union TIM1_ccmr3_output_u {
    struct {
        uint32_t const reserved_00 : 2;
        /// Output compare 5 fast enable
        uint32_t oc5fe : 1;
        /// Output compare 5 preload enable
        uint32_t oc5pe : 1;
        /// Output compare 5 mode
        uint32_t oc5m : 3;
        /// Output compare 5 clear enable
        uint32_t       oc5ce : 1;
        uint32_t const reserved_08 : 2;
        /// Output compare 6 fast enable
        uint32_t oc6fe : 1;
        /// Output compare 6 preload enable
        uint32_t oc6pe : 1;
        /// Output compare 6 mode
        uint32_t oc6m : 3;
        /// Output compare 6 clear enable
        uint32_t oc6ce : 1;
        /// Output Compare 5 mode bit 3
        uint32_t       oc5m_bit3 : 1;
        uint32_t const reserved_17 : 7;
        /// Output Compare 6 mode bit 3
        uint32_t oc6m_bit3 : 1;
    };
    uint32_t bits;
} TIM1_ccmr3_output_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_ccmr3_output_t, sizeof(uint32_t));

/**
 * Group Channel 5 and Channel 1 Distortion on Channel 1 output: This bit can
 * either have immediate effect or be preloaded and taken into account after an
 * update event (if preload feature is selected in TIMxCCMR1). Note: it is also
 * possible to apply this distortion on combined PWM signals.
 */
typedef enum TIM1_gc5c1_e {
    /// No effect of OC5REF on OC1REFC5
    TIM1_gc5c1_b_0x0 = 0x0,
    /// OC1REFC is the logical AND of OC1REFC and OC5REF
    TIM1_gc5c1_b_0x1 = 0x1,
} TIM1_gc5c1_t;

/**
 * Group Channel 5 and Channel 2 Distortion on Channel 2 output: This bit can
 * either have immediate effect or be preloaded and taken into account after an
 * update event (if preload feature is selected in TIMxCCMR1). Note: it is also
 * possible to apply this distortion on combined PWM signals.
 */
typedef enum TIM1_gc5c2_e {
    /// No effect of OC5REF on OC2REFC
    TIM1_gc5c2_b_0x0 = 0x0,
    /// OC2REFC is the logical AND of OC2REFC and OC5REF
    TIM1_gc5c2_b_0x1 = 0x1,
} TIM1_gc5c2_t;

/**
 * Group Channel 5 and Channel 3 Distortion on Channel 3 output: This bit can
 * either have immediate effect or be preloaded and taken into account after an
 * update event (if preload feature is selected in TIMxCCMR2). Note: it is also
 * possible to apply this distortion on combined PWM signals.
 */
typedef enum TIM1_gc5c3_e {
    /// No effect of OC5REF on OC3REFC
    TIM1_gc5c3_b_0x0 = 0x0,
    /// OC3REFC is the logical AND of OC3REFC and OC5REF
    TIM1_gc5c3_b_0x1 = 0x1,
} TIM1_gc5c3_t;

/**
 * capture/compare register 4
 */
typedef union TIM1_ccr5_u {
    struct {
        /// Capture/Compare 5 value CCR5 is the value to be loaded in the actual
        /// capture/compare 5 register (preload value). It is loaded permanently
        /// if the preload feature is not selected in the TIMx_CCMR3 register
        /// (bit OC5PE). Else the preload value is copied in the active
        /// capture/compare 5 register when an update event occurs. The active
        /// capture/compare register contains the value to be compared to the
        /// counter TIMx_CNT and signaled on OC5 output.
        uint32_t       ccr5 : 16;
        uint32_t const reserved_16 : 13;
        /// Group Channel 5 and Channel 1 Distortion on Channel 1 output: This
        /// bit can either have immediate effect or be preloaded and taken into
        /// account after an update event (if preload feature is selected in
        /// TIMxCCMR1). Note: it is also possible to apply this distortion on
        /// combined PWM signals.
        TIM1_gc5c1_t gc5c1 : 1;
        /// Group Channel 5 and Channel 2 Distortion on Channel 2 output: This
        /// bit can either have immediate effect or be preloaded and taken into
        /// account after an update event (if preload feature is selected in
        /// TIMxCCMR1). Note: it is also possible to apply this distortion on
        /// combined PWM signals.
        TIM1_gc5c2_t gc5c2 : 1;
        /// Group Channel 5 and Channel 3 Distortion on Channel 3 output: This
        /// bit can either have immediate effect or be preloaded and taken into
        /// account after an update event (if preload feature is selected in
        /// TIMxCCMR2). Note: it is also possible to apply this distortion on
        /// combined PWM signals.
        TIM1_gc5c3_t gc5c3 : 1;
    };
    uint32_t bits;
} TIM1_ccr5_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_ccr5_t, sizeof(uint32_t));

/**
 * capture/compare register 4
 */
typedef union TIM1_ccr6_u {
    struct {
        /// Capture/Compare value
        uint32_t ccr6 : 16;
    };
    uint32_t bits;
} TIM1_ccr6_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_ccr6_t, sizeof(uint32_t));

/**
 * BRK BKIN input enable This bit enables the BKIN alternate function input for
 * the timerâs BRK input. BKIN input is 'ORedâ with the other BRK
 * sources. Note: This bit can not be modified as long as LOCK level 1 has been
 * programmed (LOCK bits in TIMx_BDTR register).
 */
typedef enum TIM1_bkine_e {
    /// BKIN input disabled
    TIM1_bkine_b_0x0 = 0x0,
    /// BKIN input enabled
    TIM1_bkine_b_0x1 = 0x1,
} TIM1_bkine_t;

/**
 * BRK COMP1 enable This bit enables the COMP1 for the timerâs BRK input.
 * COMP1 output is 'ORedâ with the other BRK sources. Note: This bit can
 * not be modified as long as LOCK level 1 has been programmed (LOCK bits in
 * TIMx_BDTR register).
 */
typedef enum TIM1_bkcmp1e_e {
    /// COMP1 input disabled
    TIM1_bkcmp1e_b_0x0 = 0x0,
    /// COMP1 input enabled
    TIM1_bkcmp1e_b_0x1 = 0x1,
} TIM1_bkcmp1e_t;

/**
 * BRK COMP2 enable This bit enables the COMP2 for the timerâs BRK input.
 * COMP2 output is 'ORedâ with the other BRK sources. Note: This bit can
 * not be modified as long as LOCK level 1 has been programmed (LOCK bits in
 * TIMx_BDTR register).
 */
typedef enum TIM1_bkcmp2e_e {
    /// COMP2 input disabled
    TIM1_bkcmp2e_b_0x0 = 0x0,
    /// COMP2 input enabled
    TIM1_bkcmp2e_b_0x1 = 0x1,
} TIM1_bkcmp2e_t;

/**
 * BRK BKIN input polarity This bit selects the BKIN alternate function input
 * sensitivity. It must be programmed together with the BKP polarity bit. Note:
 * This bit can not be modified as long as LOCK level 1 has been programmed
 * (LOCK bits in TIMx_BDTR register).
 */
typedef enum TIM1_bkinp_e {
    /// BKIN input polarity is not inverted (active low if BKP=0, active high if
    /// BKP=1)
    TIM1_bkinp_b_0x0 = 0x0,
    /// BKIN input polarity is inverted (active high if BKP=0, active low if
    /// BKP=1)
    TIM1_bkinp_b_0x1 = 0x1,
} TIM1_bkinp_t;

/**
 * BRK COMP1 input polarity This bit selects the COMP1 input sensitivity. It
 * must be programmed together with the BKP polarity bit. Note: This bit can not
 * be modified as long as LOCK level 1 has been programmed (LOCK bits in
 * TIMx_BDTR register).
 */
typedef enum TIM1_bkcmp1p_e {
    /// COMP1 input polarity is not inverted (active low if BKP=0, active high
    /// if BKP=1)
    TIM1_bkcmp1p_b_0x0 = 0x0,
    /// COMP1 input polarity is inverted (active high if BKP=0, active low if
    /// BKP=1)
    TIM1_bkcmp1p_b_0x1 = 0x1,
} TIM1_bkcmp1p_t;

/**
 * BRK COMP2 input polarity This bit selects the COMP2 input sensitivity. It
 * must be programmed together with the BKP polarity bit. Note: This bit can not
 * be modified as long as LOCK level 1 has been programmed (LOCK bits in
 * TIMx_BDTR register).
 */
typedef enum TIM1_bkcmp2p_e {
    /// COMP2 input polarity is not inverted (active low if BKP=0, active high
    /// if BKP=1)
    TIM1_bkcmp2p_b_0x0 = 0x0,
    /// COMP2 input polarity is inverted (active high if BKP=0, active low if
    /// BKP=1)
    TIM1_bkcmp2p_b_0x1 = 0x1,
} TIM1_bkcmp2p_t;

/**
 * ETR source selection These bits select the ETR input source. Others: Reserved
 * Note: These bits can not be modified as long as LOCK level 1 has been
 * programmed (LOCK bits in TIMx_BDTR register).
 */
typedef enum TIM1_etrsel_e {
    /// ETR legacy mode
    TIM1_etrsel_b_0x0 = 0x00,
    /// COMP1 output
    TIM1_etrsel_b_0x1 = 0x01,
    /// COMP2 output
    TIM1_etrsel_b_0x2 = 0x02,
    /// ADC1 AWD1
    TIM1_etrsel_b_0x3 = 0x03,
    /// ADC1 AWD2
    TIM1_etrsel_b_0x4 = 0x04,
    /// ADC1 AWD3
    TIM1_etrsel_b_0x5 = 0x05,
} TIM1_etrsel_t;

/**
 * DMA address for full transfer
 */
typedef union TIM1_af1_u {
    struct {
        /// BRK BKIN input enable This bit enables the BKIN alternate function
        /// input for the timerâs BRK input. BKIN input is 'ORedâ with
        /// the other BRK sources. Note: This bit can not be modified as long as
        /// LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        TIM1_bkine_t bkine : 1;
        /// BRK COMP1 enable This bit enables the COMP1 for the timerâs BRK
        /// input. COMP1 output is 'ORedâ with the other BRK sources. Note:
        /// This bit can not be modified as long as LOCK level 1 has been
        /// programmed (LOCK bits in TIMx_BDTR register).
        TIM1_bkcmp1e_t bkcmp1e : 1;
        /// BRK COMP2 enable This bit enables the COMP2 for the timerâs BRK
        /// input. COMP2 output is 'ORedâ with the other BRK sources. Note:
        /// This bit can not be modified as long as LOCK level 1 has been
        /// programmed (LOCK bits in TIMx_BDTR register).
        TIM1_bkcmp2e_t bkcmp2e : 1;
        uint32_t const reserved_03 : 6;
        /// BRK BKIN input polarity This bit selects the BKIN alternate function
        /// input sensitivity. It must be programmed together with the BKP
        /// polarity bit. Note: This bit can not be modified as long as LOCK
        /// level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        TIM1_bkinp_t bkinp : 1;
        /// BRK COMP1 input polarity This bit selects the COMP1 input
        /// sensitivity. It must be programmed together with the BKP polarity
        /// bit. Note: This bit can not be modified as long as LOCK level 1 has
        /// been programmed (LOCK bits in TIMx_BDTR register).
        TIM1_bkcmp1p_t bkcmp1p : 1;
        /// BRK COMP2 input polarity This bit selects the COMP2 input
        /// sensitivity. It must be programmed together with the BKP polarity
        /// bit. Note: This bit can not be modified as long as LOCK level 1 has
        /// been programmed (LOCK bits in TIMx_BDTR register).
        TIM1_bkcmp2p_t bkcmp2p : 1;
        uint32_t const reserved_12 : 2;
        /// ETR source selection These bits select the ETR input source. Others:
        /// Reserved Note: These bits can not be modified as long as LOCK level
        /// 1 has been programmed (LOCK bits in TIMx_BDTR register).
        TIM1_etrsel_t etrsel : 4;
    };
    uint32_t bits;
} TIM1_af1_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_af1_t, sizeof(uint32_t));

/**
 * BRK2 BKIN input enable This bit enables the BKIN2 alternate function input
 * for the timerâs BRK2 input. BKIN2 input is 'ORedâ with the other
 * BRK2 sources. Note: This bit can not be modified as long as LOCK level 1 has
 * been programmed (LOCK bits in TIMx_BDTR register).
 */
typedef enum TIM1_bk2ine_e {
    /// BKIN2 input disabled
    TIM1_bk2ine_b_0x0 = 0x0,
    /// BKIN2 input enabled
    TIM1_bk2ine_b_0x1 = 0x1,
} TIM1_bk2ine_t;

/**
 * BRK2 COMP1 enable This bit enables the COMP1 for the timerâs BRK2 input.
 * COMP1 output is 'ORedâ with the other BRK2 sources. Note: This bit can
 * not be modified as long as LOCK level 1 has been programmed (LOCK bits in
 * TIMx_BDTR register).
 */
typedef enum TIM1_bk2cmp1e_e {
    /// COMP1 input disabled
    TIM1_bk2cmp1e_b_0x0 = 0x0,
    /// COMP1 input enabled
    TIM1_bk2cmp1e_b_0x1 = 0x1,
} TIM1_bk2cmp1e_t;

/**
 * BRK2 COMP2 enable This bit enables the COMP2 for the timerâs BRK2 input.
 * COMP2 output is 'ORedâ with the other BRK2 sources. Note: This bit can
 * not be modified as long as LOCK level 1 has been programmed (LOCK bits in
 * TIMx_BDTR register).
 */
typedef enum TIM1_bk2cmp2e_e {
    /// COMP2 input disabled
    TIM1_bk2cmp2e_b_0x0 = 0x0,
    /// COMP2 input enabled
    TIM1_bk2cmp2e_b_0x1 = 0x1,
} TIM1_bk2cmp2e_t;

/**
 * BRK2 BKIN2 input polarity This bit selects the BKIN2 alternate function input
 * sensitivity. It must be programmed together with the BK2P polarity bit. Note:
 * This bit can not be modified as long as LOCK level 1 has been programmed
 * (LOCK bits in TIMx_BDTR register).
 */
typedef enum TIM1_bk2inp_e {
    /// BKIN2 input polarity is not inverted (active low if BK2P=0, active high
    /// if BK2P=1)
    TIM1_bk2inp_b_0x0 = 0x0,
    /// BKIN2 input polarity is inverted (active high if BK2P=0, active low if
    /// BK2P=1)
    TIM1_bk2inp_b_0x1 = 0x1,
} TIM1_bk2inp_t;

/**
 * BRK2 COMP1 input polarity This bit selects the COMP1 input sensitivity. It
 * must be programmed together with the BK2P polarity bit. Note: This bit can
 * not be modified as long as LOCK level 1 has been programmed (LOCK bits in
 * TIMx_BDTR register).
 */
typedef enum TIM1_bk2cmp1p_e {
    /// COMP1 input polarity is not inverted (active low if BK2P=0, active high
    /// if BK2P=1)
    TIM1_bk2cmp1p_b_0x0 = 0x0,
    /// COMP1 input polarity is inverted (active high if BK2P=0, active low if
    /// BK2P=1)
    TIM1_bk2cmp1p_b_0x1 = 0x1,
} TIM1_bk2cmp1p_t;

/**
 * BRK2 COMP2 input polarity This bit selects the COMP2 input sensitivity. It
 * must be programmed together with the BK2P polarity bit. Note: This bit can
 * not be modified as long as LOCK level 1 has been programmed (LOCK bits in
 * TIMx_BDTR register).
 */
typedef enum TIM1_bk2cmp2p_e {
    /// COMP2 input polarity is not inverted (active low if BK2P=0, active high
    /// if BK2P=1)
    TIM1_bk2cmp2p_b_0x0 = 0x0,
    /// COMP2 input polarity is inverted (active high if BK2P=0, active low if
    /// BK2P=1)
    TIM1_bk2cmp2p_b_0x1 = 0x1,
} TIM1_bk2cmp2p_t;

/**
 * DMA address for full transfer
 */
typedef union TIM1_af2_u {
    struct {
        /// BRK2 BKIN input enable This bit enables the BKIN2 alternate function
        /// input for the timerâs BRK2 input. BKIN2 input is 'ORedâ
        /// with the other BRK2 sources. Note: This bit can not be modified as
        /// long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR
        /// register).
        TIM1_bk2ine_t bk2ine : 1;
        /// BRK2 COMP1 enable This bit enables the COMP1 for the timerâs
        /// BRK2 input. COMP1 output is 'ORedâ with the other BRK2 sources.
        /// Note: This bit can not be modified as long as LOCK level 1 has been
        /// programmed (LOCK bits in TIMx_BDTR register).
        TIM1_bk2cmp1e_t bk2cmp1e : 1;
        /// BRK2 COMP2 enable This bit enables the COMP2 for the timerâs
        /// BRK2 input. COMP2 output is 'ORedâ with the other BRK2 sources.
        /// Note: This bit can not be modified as long as LOCK level 1 has been
        /// programmed (LOCK bits in TIMx_BDTR register).
        TIM1_bk2cmp2e_t bk2cmp2e : 1;
        uint32_t const  reserved_03 : 6;
        /// BRK2 BKIN2 input polarity This bit selects the BKIN2 alternate
        /// function input sensitivity. It must be programmed together with the
        /// BK2P polarity bit. Note: This bit can not be modified as long as
        /// LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        TIM1_bk2inp_t bk2inp : 1;
        /// BRK2 COMP1 input polarity This bit selects the COMP1 input
        /// sensitivity. It must be programmed together with the BK2P polarity
        /// bit. Note: This bit can not be modified as long as LOCK level 1 has
        /// been programmed (LOCK bits in TIMx_BDTR register).
        TIM1_bk2cmp1p_t bk2cmp1p : 1;
        /// BRK2 COMP2 input polarity This bit selects the COMP2 input
        /// sensitivity. It must be programmed together with the BK2P polarity
        /// bit. Note: This bit can not be modified as long as LOCK level 1 has
        /// been programmed (LOCK bits in TIMx_BDTR register).
        TIM1_bk2cmp2p_t bk2cmp2p : 1;
    };
    uint32_t bits;
} TIM1_af2_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_af2_t, sizeof(uint32_t));

/**
 * selects TI1[0] to TI1[15] input Others: Reserved
 */
typedef enum TIM1_ti1sel_e {
    /// TIM1_CH1 input
    TIM1_ti1sel_b_0x0 = 0x00,
    /// COMP1 output
    TIM1_ti1sel_b_0x1 = 0x01,
} TIM1_ti1sel_t;

/**
 * selects TI2[0] to TI2[15] input Others: Reserved
 */
typedef enum TIM1_ti2sel_e {
    /// TIM1_CH2 input
    TIM1_ti2sel_b_0x0 = 0x00,
    /// COMP2 output
    TIM1_ti2sel_b_0x1 = 0x01,
} TIM1_ti2sel_t;

/**
 * selects TI3[0] to TI3[15] input Others: Reserved
 */
typedef enum TIM1_ti3sel_e {
    /// TIM1_CH3 input
    TIM1_ti3sel_b_0x0 = 0x00,
} TIM1_ti3sel_t;

/**
 * selects TI4[0] to TI4[15] input Others: Reserved
 */
typedef enum TIM1_ti4sel_e {
    /// TIM1_CH4 input
    TIM1_ti4sel_b_0x0 = 0x00,
} TIM1_ti4sel_t;

/**
 * TIM1 timer input selection register
 */
typedef union TIM1_tisel_u {
    struct {
        /// selects TI1[0] to TI1[15] input Others: Reserved
        TIM1_ti1sel_t  ti1sel : 4;
        uint32_t const reserved_04 : 4;
        /// selects TI2[0] to TI2[15] input Others: Reserved
        TIM1_ti2sel_t  ti2sel : 4;
        uint32_t const reserved_12 : 4;
        /// selects TI3[0] to TI3[15] input Others: Reserved
        TIM1_ti3sel_t  ti3sel : 4;
        uint32_t const reserved_20 : 4;
        /// selects TI4[0] to TI4[15] input Others: Reserved
        TIM1_ti4sel_t ti4sel : 4;
    };
    uint32_t bits;
} TIM1_tisel_t;
STATIC_ASSERT_TYPE_SIZE(TIM1_tisel_t, sizeof(uint32_t));

/**
 * Advanced-timers
 */
typedef struct TIM1_peripheral_registers_s {
    /// control register 1
    TIM1_cr1_t cr1;
    /// control register 2
    TIM1_cr2_t cr2;
    /// slave mode control register
    TIM1_smcr_t smcr;
    /// DMA/Interrupt enable register
    TIM1_dier_t dier;
    /// status register
    TIM1_sr_t sr;
    /// event generation register
    TIM1_egr_t egr;
    union {
        /// capture/compare mode register 1 (output mode)
        TIM1_ccmr1_input_t ccmr1_input;
        /// capture/compare mode register 1 (output mode)
        TIM1_ccmr1_output_t ccmr1_output;
    };
    union {
        /// capture/compare mode register 2 (output mode)
        TIM1_ccmr2_input_t ccmr2_input;
        /// capture/compare mode register 2 (output mode)
        TIM1_ccmr2_output_t ccmr2_output;
    };
    /// capture/compare enable register
    TIM1_ccer_t ccer;
    /// counter
    TIM1_cnt_t cnt;
    /// prescaler
    TIM1_psc_t psc;
    /// auto-reload register
    TIM1_arr_t arr;
    /// repetition counter register
    TIM1_rcr_t rcr;
    /// capture/compare register 1
    TIM1_ccr1_t ccr1;
    /// capture/compare register 2
    TIM1_ccr2_t ccr2;
    /// capture/compare register 3
    TIM1_ccr3_t ccr3;
    /// capture/compare register 4
    TIM1_ccr4_t ccr4;
    /// break and dead-time register
    TIM1_bdtr_t bdtr;
    /// DMA control register
    TIM1_dcr_t dcr;
    /// DMA address for full transfer
    TIM1_dmar_t dmar;
    /// option register 1
    TIM1_or1_t or1;
    /// capture/compare mode register 2 (output mode)
    TIM1_ccmr3_output_t ccmr3_output;
    /// capture/compare register 4
    TIM1_ccr5_t ccr5;
    /// capture/compare register 4
    TIM1_ccr6_t ccr6;
    /// DMA address for full transfer
    TIM1_af1_t af1;
    /// DMA address for full transfer
    TIM1_af2_t af2;
    /// TIM1 timer input selection register
    TIM1_tisel_t tisel;
} TIM1_peripheral_registers_t;
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, cr1, 0x00);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, cr2, 0x04);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, smcr, 0x08);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, dier, 0x0C);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, sr, 0x10);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, egr, 0x14);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, ccmr1_output, 0x18);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, ccmr1_input, 0x18);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, ccmr2_output, 0x1C);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, ccmr2_input, 0x1C);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, ccer, 0x20);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, cnt, 0x24);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, psc, 0x28);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, arr, 0x2C);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, rcr, 0x30);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, ccr1, 0x34);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, ccr2, 0x38);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, ccr3, 0x3C);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, ccr4, 0x40);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, bdtr, 0x44);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, dcr, 0x48);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, dmar, 0x4C);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, or1, 0x50);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, ccmr3_output, 0x54);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, ccr5, 0x58);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, ccr6, 0x5C);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, af1, 0x60);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, af2, 0x64);
STATIC_ASSERT_MEMBER_OFFSET(TIM1_peripheral_registers_t, tisel, 0x68);

#ifdef __cplusplus
}
#endif
#endif // TIM1_H_

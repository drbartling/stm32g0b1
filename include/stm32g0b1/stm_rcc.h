/**
 * @file
 * @version 1.6
 * @brief Register access structs for STM RCC
 *
 * Reset and clock control
 *
 * @note This file is autogenerated using register-code-gen
 */

#ifndef RCC_H_
#define RCC_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "static_assert.h"

#include <stdint.h>

/**
 * Clock control register
 */
typedef union RCC_cr_u {
    struct {
        uint32_t const reserved_00 : 8;
        /// HSI16 clock enable
        uint32_t hsion : 1;
        /// HSI16 always enable for peripheral kernels
        uint32_t hsikeron : 1;
        /// HSI16 clock ready flag
        uint32_t const hsirdy : 1;
        /// HSI16 clock division factor
        uint32_t       hsidiv : 3;
        uint32_t const reserved_14 : 2;
        /// HSE clock enable
        uint32_t hseon : 1;
        /// HSE clock ready flag
        uint32_t hserdy : 1;
        /// HSE crystal oscillator bypass
        uint32_t hsebyp : 1;
        /// Clock security system enable
        uint32_t       csson : 1;
        uint32_t const reserved_20 : 2;
        /// HSI48ON
        uint32_t hsi48on : 1;
        /// HSI48RDY
        uint32_t const hsi48rdy : 1;
        /// PLL enable
        uint32_t pllon : 1;
        /// PLL clock ready flag
        uint32_t const pllrdy : 1;
    };
    uint32_t bits;
} RCC_cr_t;
STATIC_ASSERT_TYPE_SIZE(RCC_cr_t, sizeof(uint32_t));

/**
 * Internal clock sources calibration register
 */
typedef union RCC_icscr_u {
    struct {
        /// HSI16 clock calibration
        uint32_t const hsical : 8;
        /// HSI16 clock trimming
        uint32_t hsitrim : 7;
    };
    uint32_t bits;
} RCC_icscr_t;
STATIC_ASSERT_TYPE_SIZE(RCC_icscr_t, sizeof(uint32_t));

/**
 * Clock configuration register
 */
typedef union RCC_cfgr_u {
    struct {
        /// System clock switch
        uint32_t sw : 3;
        /// System clock switch status
        uint32_t const sws : 3;
        uint32_t const reserved_06 : 2;
        /// AHB prescaler
        uint32_t hpre : 4;
        /// APB prescaler
        uint32_t       ppre : 3;
        uint32_t const reserved_15 : 1;
        /// MCO2SEL
        uint32_t mco2sel : 4;
        /// MCO2PRE
        uint32_t mco2pre : 4;
        /// Microcontroller clock output
        uint32_t mcosel : 4;
        /// Microcontroller clock output prescaler
        uint32_t mcopre : 4;
    };
    uint32_t bits;
} RCC_cfgr_t;
STATIC_ASSERT_TYPE_SIZE(RCC_cfgr_t, sizeof(uint32_t));

/**
 * PLL configuration register
 */
typedef union RCC_pllcfgr_u {
    struct {
        /// PLL input clock source
        uint32_t       pllsrc : 2;
        uint32_t const reserved_02 : 2;
        /// Division factor M of the PLL input clock divider
        uint32_t       pllm : 3;
        uint32_t const reserved_07 : 1;
        /// PLL frequency multiplication factor N
        uint32_t plln : 8;
        /// PLLPCLK clock output enable
        uint32_t pllpen : 1;
        /// PLL VCO division factor P for PLLPCLK clock output
        uint32_t       pllp : 5;
        uint32_t const reserved_22 : 2;
        /// PLLQCLK clock output enable
        uint32_t pllqen : 1;
        /// PLL VCO division factor Q for PLLQCLK clock output
        uint32_t pllq : 3;
        /// PLLRCLK clock output enable
        uint32_t pllren : 1;
        /// PLL VCO division factor R for PLLRCLK clock output
        uint32_t pllr : 3;
    };
    uint32_t bits;
} RCC_pllcfgr_t;
STATIC_ASSERT_TYPE_SIZE(RCC_pllcfgr_t, sizeof(uint32_t));

/**
 * RCC clock recovery RC register
 */
typedef union RCC_crrcr_u {
    struct {
        /// HSI48 clock calibration
        uint32_t const hsi48cal : 9;
    };
    uint32_t bits;
} RCC_crrcr_t;
STATIC_ASSERT_TYPE_SIZE(RCC_crrcr_t, sizeof(uint32_t));

/**
 * Clock interrupt enable register
 */
typedef union RCC_cier_u {
    struct {
        /// LSI ready interrupt enable
        uint32_t lsirdyie : 1;
        /// LSE ready interrupt enable
        uint32_t       lserdyie : 1;
        uint32_t const reserved_02 : 1;
        /// HSI ready interrupt enable
        uint32_t hsirdyie : 1;
        /// HSE ready interrupt enable
        uint32_t hserdyie : 1;
        /// PLL ready interrupt enable
        uint32_t pllsysrdyie : 1;
    };
    uint32_t bits;
} RCC_cier_t;
STATIC_ASSERT_TYPE_SIZE(RCC_cier_t, sizeof(uint32_t));

/**
 * Clock interrupt flag register
 */
typedef union RCC_cifr_u {
    struct {
        /// LSI ready interrupt flag
        uint32_t const lsirdyf : 1;
        /// LSE ready interrupt flag
        uint32_t const lserdyf : 1;
        /// HSI48RDYF
        uint32_t const hsi48rdyf : 1;
        /// HSI ready interrupt flag
        uint32_t const hsirdyf : 1;
        /// HSE ready interrupt flag
        uint32_t const hserdyf : 1;
        /// PLL ready interrupt flag
        uint32_t const pllsysrdyf : 1;
        uint32_t const reserved_06 : 2;
        /// Clock security system interrupt flag
        uint32_t const cssf : 1;
        /// LSE Clock security system interrupt flag
        uint32_t const lsecssf : 1;
    };
    uint32_t bits;
} RCC_cifr_t;
STATIC_ASSERT_TYPE_SIZE(RCC_cifr_t, sizeof(uint32_t));

/**
 * Clock interrupt clear register
 */
typedef union RCC_cicr_u {
    struct {
        /// LSI ready interrupt clear
        uint32_t lsirdyc : 1;
        /// LSE ready interrupt clear
        uint32_t lserdyc : 1;
        /// HSI48RDYC
        uint32_t hsi48rdyc : 1;
        /// HSI ready interrupt clear
        uint32_t hsirdyc : 1;
        /// HSE ready interrupt clear
        uint32_t hserdyc : 1;
        /// PLL ready interrupt clear
        uint32_t       pllsysrdyc : 1;
        uint32_t const reserved_06 : 2;
        /// Clock security system interrupt clear
        uint32_t cssc : 1;
        /// LSE Clock security system interrupt clear
        uint32_t lsecssc : 1;
    };
    uint32_t bits;
} RCC_cicr_t;
STATIC_ASSERT_TYPE_SIZE(RCC_cicr_t, sizeof(uint32_t));

/**
 * I/O port reset register
 */
typedef union RCC_ioprstr_u {
    struct {
        /// GPIOARST
        uint32_t gpioarst : 1;
        /// GPIOBRST
        uint32_t gpiobrst : 1;
        /// GPIOCRST
        uint32_t gpiocrst : 1;
        /// GPIODRST
        uint32_t gpiodrst : 1;
        /// GPIOERST
        uint32_t gpioerst : 1;
        /// GPIOFRST
        uint32_t gpiofrst : 1;
    };
    uint32_t bits;
} RCC_ioprstr_t;
STATIC_ASSERT_TYPE_SIZE(RCC_ioprstr_t, sizeof(uint32_t));

/**
 * AHB peripheral reset register
 */
typedef union RCC_ahbrstr_u {
    struct {
        /// DMA1 reset
        uint32_t dma1rst : 1;
        /// DMA1 reset
        uint32_t       dma2rst : 1;
        uint32_t const reserved_02 : 6;
        /// FLITF reset
        uint32_t       flashrst : 1;
        uint32_t const reserved_09 : 3;
        /// CRC reset
        uint32_t crcrst : 1;
    };
    uint32_t bits;
} RCC_ahbrstr_t;
STATIC_ASSERT_TYPE_SIZE(RCC_ahbrstr_t, sizeof(uint32_t));

/**
 * APB peripheral reset register 1
 */
typedef union RCC_apbrstr1_u {
    struct {
        /// TIM2 timer reset
        uint32_t tim2rst : 1;
        /// TIM3 timer reset
        uint32_t tim3rst : 1;
        /// TIM4 timer reset
        uint32_t       tim4rst : 1;
        uint32_t const reserved_03 : 1;
        /// TIM6 timer reset
        uint32_t tim6rst : 1;
        /// TIM7 timer reset
        uint32_t       tim7rst : 1;
        uint32_t const reserved_06 : 1;
        /// LPUART2RST
        uint32_t lpuart2rst : 1;
        /// USART5RST
        uint32_t usart5rst : 1;
        /// USART6RST
        uint32_t       usart6rst : 1;
        uint32_t const reserved_10 : 2;
        /// FDCANRST
        uint32_t fdcanrst : 1;
        /// USBRST
        uint32_t usbrst : 1;
        /// SPI2 reset
        uint32_t spi2rst : 1;
        /// SPI3 reset
        uint32_t spi3rst : 1;
        /// CRSRST
        uint32_t crsrst : 1;
        /// USART2 reset
        uint32_t usart2rst : 1;
        /// USART3 reset
        uint32_t usart3rst : 1;
        /// USART4 reset
        uint32_t usart4rst : 1;
        /// LPUART1 reset
        uint32_t lpuart1rst : 1;
        /// I2C1 reset
        uint32_t i2c1rst : 1;
        /// I2C2 reset
        uint32_t i2c2rst : 1;
        /// I2C3RST reset
        uint32_t i2c3rst : 1;
        /// HDMI CEC reset
        uint32_t cecrst : 1;
        /// UCPD1 reset
        uint32_t ucpd1rst : 1;
        /// UCPD2 reset
        uint32_t ucpd2rst : 1;
        /// Debug support reset
        uint32_t dbgrst : 1;
        /// Power interface reset
        uint32_t pwrrst : 1;
        /// DAC1 interface reset
        uint32_t dac1rst : 1;
        /// Low Power Timer 2 reset
        uint32_t lptim2rst : 1;
        /// Low Power Timer 1 reset
        uint32_t lptim1rst : 1;
    };
    uint32_t bits;
} RCC_apbrstr1_t;
STATIC_ASSERT_TYPE_SIZE(RCC_apbrstr1_t, sizeof(uint32_t));

/**
 * APB peripheral reset register 2
 */
typedef union RCC_apbrstr2_u {
    struct {
        /// SYSCFG, COMP and VREFBUF reset
        uint32_t       syscfgrst : 1;
        uint32_t const reserved_01 : 10;
        /// TIM1 timer reset
        uint32_t tim1rst : 1;
        /// SPI1 reset
        uint32_t       spi1rst : 1;
        uint32_t const reserved_13 : 1;
        /// USART1 reset
        uint32_t usart1rst : 1;
        /// TIM14 timer reset
        uint32_t tim14rst : 1;
        /// TIM15 timer reset
        uint32_t tim15rst : 1;
        /// TIM16 timer reset
        uint32_t tim16rst : 1;
        /// TIM17 timer reset
        uint32_t       tim17rst : 1;
        uint32_t const reserved_19 : 1;
        /// ADC reset
        uint32_t adcrst : 1;
    };
    uint32_t bits;
} RCC_apbrstr2_t;
STATIC_ASSERT_TYPE_SIZE(RCC_apbrstr2_t, sizeof(uint32_t));

/**
 * GPIO clock enable register
 */
typedef union RCC_iopenr_u {
    struct {
        /// I/O port A clock enable during Sleep mode
        uint32_t gpioaen : 1;
        /// I/O port B clock enable during Sleep mode
        uint32_t gpioben : 1;
        /// I/O port C clock enable during Sleep mode
        uint32_t gpiocen : 1;
        /// I/O port D clock enable during Sleep mode
        uint32_t gpioden : 1;
        /// I/O port E clock enable during Sleep mode
        uint32_t gpioeen : 1;
        /// I/O port F clock enable during Sleep mode
        uint32_t gpiofen : 1;
    };
    uint32_t bits;
} RCC_iopenr_t;
STATIC_ASSERT_TYPE_SIZE(RCC_iopenr_t, sizeof(uint32_t));

/**
 * AHB peripheral clock enable register
 */
typedef union RCC_ahbenr_u {
    struct {
        /// DMA1 clock enable
        uint32_t dma1en : 1;
        /// DMA2 clock enable
        uint32_t       dma2en : 1;
        uint32_t const reserved_02 : 6;
        /// Flash memory interface clock enable
        uint32_t       flashen : 1;
        uint32_t const reserved_09 : 3;
        /// CRC clock enable
        uint32_t crcen : 1;
    };
    uint32_t bits;
} RCC_ahbenr_t;
STATIC_ASSERT_TYPE_SIZE(RCC_ahbenr_t, sizeof(uint32_t));

/**
 * APB peripheral clock enable register 1
 */
typedef union RCC_apbenr1_u {
    struct {
        /// TIM2 timer clock enable
        uint32_t tim2en : 1;
        /// TIM3 timer clock enable
        uint32_t tim3en : 1;
        /// TIM4 timer clock enable
        uint32_t       tim4en : 1;
        uint32_t const reserved_03 : 1;
        /// TIM6 timer clock enable
        uint32_t tim6en : 1;
        /// TIM7 timer clock enable
        uint32_t       tim7en : 1;
        uint32_t const reserved_06 : 1;
        /// LPUART2 clock enable
        uint32_t lpuart2en : 1;
        /// USART5EN
        uint32_t usart5en : 1;
        /// USART6EN
        uint32_t usart6en : 1;
        /// RTC APB clock enable
        uint32_t rtcapben : 1;
        /// WWDG clock enable
        uint32_t wwdgen : 1;
        /// USBEN
        uint32_t fdcanen : 1;
        /// USBEN
        uint32_t usben : 1;
        /// SPI2 clock enable
        uint32_t spi2en : 1;
        /// SPI3 clock enable
        uint32_t spi3en : 1;
        /// CRSEN
        uint32_t crsen : 1;
        /// USART2 clock enable
        uint32_t usart2en : 1;
        /// USART3 clock enable
        uint32_t usart3en : 1;
        /// USART4 clock enable
        uint32_t usart4en : 1;
        /// LPUART1 clock enable
        uint32_t lpuart1en : 1;
        /// I2C1 clock enable
        uint32_t i2c1en : 1;
        /// I2C2 clock enable
        uint32_t i2c2en : 1;
        /// I2C3 clock enable
        uint32_t i2c3en : 1;
        /// HDMI CEC clock enable
        uint32_t cecen : 1;
        /// UCPD1 clock enable
        uint32_t ucpd1en : 1;
        /// UCPD2 clock enable
        uint32_t ucpd2en : 1;
        /// Debug support clock enable
        uint32_t dbgen : 1;
        /// Power interface clock enable
        uint32_t pwren : 1;
        /// DAC1 interface clock enable
        uint32_t dac1en : 1;
        /// LPTIM2 clock enable
        uint32_t lptim2en : 1;
        /// LPTIM1 clock enable
        uint32_t lptim1en : 1;
    };
    uint32_t bits;
} RCC_apbenr1_t;
STATIC_ASSERT_TYPE_SIZE(RCC_apbenr1_t, sizeof(uint32_t));

/**
 * APB peripheral clock enable register 2
 */
typedef union RCC_apbenr2_u {
    struct {
        /// SYSCFG, COMP and VREFBUF clock enable
        uint32_t       syscfgen : 1;
        uint32_t const reserved_01 : 10;
        /// TIM1 timer clock enable
        uint32_t tim1en : 1;
        /// SPI1 clock enable
        uint32_t       spi1en : 1;
        uint32_t const reserved_13 : 1;
        /// USART1 clock enable
        uint32_t usart1en : 1;
        /// TIM14 timer clock enable
        uint32_t tim14en : 1;
        /// TIM15 timer clock enable
        uint32_t tim15en : 1;
        /// TIM16 timer clock enable
        uint32_t tim16en : 1;
        /// TIM16 timer clock enable
        uint32_t       tim17en : 1;
        uint32_t const reserved_19 : 1;
        /// ADC clock enable
        uint32_t adcen : 1;
    };
    uint32_t bits;
} RCC_apbenr2_t;
STATIC_ASSERT_TYPE_SIZE(RCC_apbenr2_t, sizeof(uint32_t));

/**
 * GPIO in Sleep mode clock enable register
 */
typedef union RCC_iopsmenr_u {
    struct {
        /// I/O port A clock enable during Sleep mode
        uint32_t gpioasmen : 1;
        /// I/O port B clock enable during Sleep mode
        uint32_t gpiobsmen : 1;
        /// I/O port C clock enable during Sleep mode
        uint32_t gpiocsmen : 1;
        /// I/O port D clock enable during Sleep mode
        uint32_t gpiodsmen : 1;
        /// I/O port E clock enable during Sleep mode
        uint32_t gpioesmen : 1;
        /// I/O port F clock enable during Sleep mode
        uint32_t gpiofsmen : 1;
    };
    uint32_t bits;
} RCC_iopsmenr_t;
STATIC_ASSERT_TYPE_SIZE(RCC_iopsmenr_t, sizeof(uint32_t));

/**
 * AHB peripheral clock enable in Sleep mode register
 */
typedef union RCC_ahbsmenr_u {
    struct {
        /// DMA1 clock enable during Sleep mode
        uint32_t dma1smen : 1;
        /// DMA2 clock enable during Sleep mode
        uint32_t       dma2smen : 1;
        uint32_t const reserved_02 : 6;
        /// Flash memory interface clock enable during Sleep mode
        uint32_t flashsmen : 1;
        /// SRAM clock enable during Sleep mode
        uint32_t       sramsmen : 1;
        uint32_t const reserved_10 : 2;
        /// CRC clock enable during Sleep mode
        uint32_t crcsmen : 1;
    };
    uint32_t bits;
} RCC_ahbsmenr_t;
STATIC_ASSERT_TYPE_SIZE(RCC_ahbsmenr_t, sizeof(uint32_t));

/**
 * APB peripheral clock enable in Sleep mode register 1
 */
typedef union RCC_apbsmenr1_u {
    struct {
        /// TIM2 timer clock enable during Sleep mode
        uint32_t tim2smen : 1;
        /// TIM3 timer clock enable during Sleep mode
        uint32_t tim3smen : 1;
        /// TIM4 timer clock enable during Sleep mode
        uint32_t       tim4smen : 1;
        uint32_t const reserved_03 : 1;
        /// TIM6 timer clock enable during Sleep mode
        uint32_t tim6smen : 1;
        /// TIM7 timer clock enable during Sleep mode
        uint32_t       tim7smen : 1;
        uint32_t const reserved_06 : 1;
        /// LPUART2 clock enable
        uint32_t lpuart2smen : 1;
        /// USART5 clock enable
        uint32_t usart5smen : 1;
        /// USART6 clock enable
        uint32_t usart6smen : 1;
        /// RTC APB clock enable during Sleep mode
        uint32_t rtcapbsmen : 1;
        /// WWDG clock enable during Sleep mode
        uint32_t wwdgsmen : 1;
        /// FDCAN clock enable during Sleep mode
        uint32_t fdcansmen : 1;
        /// USB clock enable during Sleep mode
        uint32_t usbsmen : 1;
        /// SPI2 clock enable during Sleep mode
        uint32_t spi2smen : 1;
        /// SPI3 clock enable during Sleep mode
        uint32_t spi3smen : 1;
        /// CRSS clock enable during Sleep mode
        uint32_t crsssmen : 1;
        /// USART2 clock enable during Sleep mode
        uint32_t usart2smen : 1;
        /// USART3 clock enable during Sleep mode
        uint32_t usart3smen : 1;
        /// USART4 clock enable during Sleep mode
        uint32_t usart4smen : 1;
        /// LPUART1 clock enable during Sleep mode
        uint32_t lpuart1smen : 1;
        /// I2C1 clock enable during Sleep mode
        uint32_t i2c1smen : 1;
        /// I2C2 clock enable during Sleep mode
        uint32_t i2c2smen : 1;
        /// I2C3 clock enable during Sleep mode
        uint32_t i2c3smen : 1;
        /// HDMI CEC clock enable during Sleep mode
        uint32_t cecsmen : 1;
        /// UCPD1 clock enable during Sleep mode
        uint32_t ucpd1smen : 1;
        /// UCPD2 clock enable during Sleep mode
        uint32_t ucpd2smen : 1;
        /// Debug support clock enable during Sleep mode
        uint32_t dbgsmen : 1;
        /// Power interface clock enable during Sleep mode
        uint32_t pwrsmen : 1;
        /// DAC1 interface clock enable during Sleep mode
        uint32_t dac1smen : 1;
        /// Low Power Timer 2 clock enable during Sleep mode
        uint32_t lptim2smen : 1;
        /// Low Power Timer 1 clock enable during Sleep mode
        uint32_t lptim1smen : 1;
    };
    uint32_t bits;
} RCC_apbsmenr1_t;
STATIC_ASSERT_TYPE_SIZE(RCC_apbsmenr1_t, sizeof(uint32_t));

/**
 * APB peripheral clock enable in Sleep mode register 2
 */
typedef union RCC_apbsmenr2_u {
    struct {
        /// SYSCFG, COMP and VREFBUF clock enable during Sleep mode
        uint32_t       syscfgsmen : 1;
        uint32_t const reserved_01 : 10;
        /// TIM1 timer clock enable during Sleep mode
        uint32_t tim1smen : 1;
        /// SPI1 clock enable during Sleep mode
        uint32_t       spi1smen : 1;
        uint32_t const reserved_13 : 1;
        /// USART1 clock enable during Sleep mode
        uint32_t usart1smen : 1;
        /// TIM14 timer clock enable during Sleep mode
        uint32_t tim14smen : 1;
        /// TIM15 timer clock enable during Sleep mode
        uint32_t tim15smen : 1;
        /// TIM16 timer clock enable during Sleep mode
        uint32_t tim16smen : 1;
        /// TIM16 timer clock enable during Sleep mode
        uint32_t       tim17smen : 1;
        uint32_t const reserved_19 : 1;
        /// ADC clock enable during Sleep mode
        uint32_t adcsmen : 1;
    };
    uint32_t bits;
} RCC_apbsmenr2_t;
STATIC_ASSERT_TYPE_SIZE(RCC_apbsmenr2_t, sizeof(uint32_t));

/**
 * Peripherals independent clock configuration register
 */
typedef union RCC_ccipr_u {
    struct {
        /// USART1 clock source selection
        uint32_t usart1sel : 2;
        /// USART2 clock source selection
        uint32_t usart2sel : 2;
        /// USART3 clock source selection
        uint32_t usart3sel : 2;
        /// HDMI CEC clock source selection
        uint32_t       cecsel : 1;
        uint32_t const reserved_07 : 1;
        /// LPUART2 clock source selection
        uint32_t lpuart2sel : 2;
        /// LPUART1 clock source selection
        uint32_t lpuart1sel : 2;
        /// I2C1 clock source selection
        uint32_t i2c1sel : 2;
        /// I2S1 clock source selection
        uint32_t       i2s2sel : 2;
        uint32_t const reserved_16 : 2;
        /// LPTIM1 clock source selection
        uint32_t lptim1sel : 2;
        /// LPTIM2 clock source selection
        uint32_t lptim2sel : 2;
        /// TIM1 clock source selection
        uint32_t       tim1sel : 1;
        uint32_t const reserved_23 : 1;
        /// TIM15 clock source selection
        uint32_t       tim15sel : 1;
        uint32_t const reserved_25 : 5;
        /// ADCs clock source selection
        uint32_t adcsel : 2;
    };
    uint32_t bits;
} RCC_ccipr_t;
STATIC_ASSERT_TYPE_SIZE(RCC_ccipr_t, sizeof(uint32_t));

/**
 * Peripherals independent clock configuration register 2
 */
typedef union RCC_ccipr2_u {
    struct {
        /// 2S1SEL
        uint32_t i2s1sel : 2;
        /// I2S2SEL
        uint32_t       i2s2sel : 2;
        uint32_t const reserved_04 : 4;
        /// FDCANSEL
        uint32_t       fdcansel : 2;
        uint32_t const reserved_10 : 2;
        /// USBSEL
        uint32_t usbsel : 2;
    };
    uint32_t bits;
} RCC_ccipr2_t;
STATIC_ASSERT_TYPE_SIZE(RCC_ccipr2_t, sizeof(uint32_t));

/**
 * RTC domain control register
 */
typedef union RCC_bdcr_u {
    struct {
        /// LSE oscillator enable
        uint32_t lseon : 1;
        /// LSE oscillator ready
        uint32_t const lserdy : 1;
        /// LSE oscillator bypass
        uint32_t lsebyp : 1;
        /// LSE oscillator drive capability
        uint32_t lsedrv : 2;
        /// CSS on LSE enable
        uint32_t lsecsson : 1;
        /// CSS on LSE failure Detection
        uint32_t const lsecssd : 1;
        uint32_t const reserved_07 : 1;
        /// RTC clock source selection
        uint32_t       rtcsel : 2;
        uint32_t const reserved_10 : 5;
        /// RTC clock enable
        uint32_t rtcen : 1;
        /// RTC domain software reset
        uint32_t       bdrst : 1;
        uint32_t const reserved_17 : 7;
        /// Low-speed clock output (LSCO) enable
        uint32_t lscoen : 1;
        /// Low-speed clock output selection
        uint32_t lscosel : 1;
    };
    uint32_t bits;
} RCC_bdcr_t;
STATIC_ASSERT_TYPE_SIZE(RCC_bdcr_t, sizeof(uint32_t));

/**
 * Control/status register
 */
typedef union RCC_csr_u {
    struct {
        /// LSI oscillator enable
        uint32_t lsion : 1;
        /// LSI oscillator ready
        uint32_t const lsirdy : 1;
        uint32_t const reserved_02 : 21;
        /// Remove reset flags
        uint32_t       rmvf : 1;
        uint32_t const reserved_24 : 1;
        /// Option byte loader reset flag
        uint32_t const oblrstf : 1;
        /// Pin reset flag
        uint32_t const pinrstf : 1;
        /// BOR or POR/PDR flag
        uint32_t const pwrrstf : 1;
        /// Software reset flag
        uint32_t const sftrstf : 1;
        /// Independent window watchdog reset flag
        uint32_t const iwdgrstf : 1;
        /// Window watchdog reset flag
        uint32_t const wwdgrstf : 1;
        /// Low-power reset flag
        uint32_t const lpwrrstf : 1;
    };
    uint32_t bits;
} RCC_csr_t;
STATIC_ASSERT_TYPE_SIZE(RCC_csr_t, sizeof(uint32_t));

/**
 * Reset and clock control
 */
typedef struct RCC_peripheral_registers_s {
    /// Clock control register
    RCC_cr_t cr;
    /// Internal clock sources calibration register
    RCC_icscr_t icscr;
    /// Clock configuration register
    RCC_cfgr_t cfgr;
    /// PLL configuration register
    RCC_pllcfgr_t pllcfgr;
    uint8_t const reserved_0x10[4];
    /// RCC clock recovery RC register
    RCC_crrcr_t crrcr;
    /// Clock interrupt enable register
    RCC_cier_t cier;
    /// Clock interrupt flag register
    RCC_cifr_t cifr;
    /// Clock interrupt clear register
    RCC_cicr_t cicr;
    /// I/O port reset register
    RCC_ioprstr_t ioprstr;
    /// AHB peripheral reset register
    RCC_ahbrstr_t ahbrstr;
    /// APB peripheral reset register 1
    RCC_apbrstr1_t apbrstr1;
    /// APB peripheral reset register 2
    RCC_apbrstr2_t apbrstr2;
    /// GPIO clock enable register
    RCC_iopenr_t iopenr;
    /// AHB peripheral clock enable register
    RCC_ahbenr_t ahbenr;
    /// APB peripheral clock enable register 1
    RCC_apbenr1_t apbenr1;
    /// APB peripheral clock enable register 2
    RCC_apbenr2_t apbenr2;
    /// GPIO in Sleep mode clock enable register
    RCC_iopsmenr_t iopsmenr;
    /// AHB peripheral clock enable in Sleep mode register
    RCC_ahbsmenr_t ahbsmenr;
    /// APB peripheral clock enable in Sleep mode register 1
    RCC_apbsmenr1_t apbsmenr1;
    /// APB peripheral clock enable in Sleep mode register 2
    RCC_apbsmenr2_t apbsmenr2;
    /// Peripherals independent clock configuration register
    RCC_ccipr_t ccipr;
    /// Peripherals independent clock configuration register 2
    RCC_ccipr2_t ccipr2;
    /// RTC domain control register
    RCC_bdcr_t bdcr;
    /// Control/status register
    RCC_csr_t csr;
} RCC_peripheral_registers_t;
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, cr, 0x00);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, icscr, 0x04);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, cfgr, 0x08);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, pllcfgr, 0x0C);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, crrcr, 0x14);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, cier, 0x18);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, cifr, 0x1C);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, cicr, 0x20);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, ioprstr, 0x24);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, ahbrstr, 0x28);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, apbrstr1, 0x2C);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, apbrstr2, 0x30);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, iopenr, 0x34);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, ahbenr, 0x38);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, apbenr1, 0x3C);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, apbenr2, 0x40);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, iopsmenr, 0x44);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, ahbsmenr, 0x48);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, apbsmenr1, 0x4C);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, apbsmenr2, 0x50);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, ccipr, 0x54);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, ccipr2, 0x58);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, bdcr, 0x5C);
STATIC_ASSERT_MEMBER_OFFSET(RCC_peripheral_registers_t, csr, 0x60);

#ifdef __cplusplus
}
#endif
#endif // RCC_H_
